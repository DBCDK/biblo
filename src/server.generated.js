module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {'use strict';
	__webpack_require__(/*! babel/register */ 1);
	
	// loading config etc.
	var newrelic = __webpack_require__(/*! newrelic */ 429);
	var config = __webpack_require__(/*! ../config */ 430);
	var version = __webpack_require__(/*! ../package.json */ 431).version;
	
	// loading libraries
	var express = __webpack_require__(/*! express */ 432);
	var app = express();
	var server = __webpack_require__(/*! http */ 433).Server(app);
	var io = __webpack_require__(/*! socket.io */ 434);
	var socket = io(server);
	var path = __webpack_require__(/*! path */ 96);
	var logger = __webpack_require__(/*! ./logger */ 506);
	
	// settings up our provider
	//var serviceProvider = require('dbc-node-serviceprovider');
	//serviceProvider.init(config.services, socket);
	
	// Port config
	app.set('port', process.env.PORT || 8080); // eslint-disable-line no-process-env
	
	// Configure templating
	app.set('views', path.join(__dirname, 'views'));
	app.set('view engine', 'jade');
	
	// setting paths
	app.use(express['static'](path.join(__dirname, '../public')));
	app.use(express['static'](path.join(__dirname, '../static')));
	
	// setting local vars that should be availbe to our template engine
	app.locals.newrelic = newrelic;
	app.locals.version = version;
	app.locals.env = process.env; // eslint-disable-line no-process-env
	
	// setting basic routes -- should be moved elsewhere in the future
	app.get('/', function (req, res) {
	  res.render('logo');
	});
	
	app.get('/autocomplete', function (req, res) {
	  res.render('autocomplete');
	});
	
	app.get('/querysearch', function (req, res) {
	  var search = React.renderToString(React.createElement(QueryField, null));
	  res.render('querysearch', { search: search });
	});
	
	// starting server
	server.listen(app.get('port'), function () {
	  logger.info('Server listening on ' + app.get('port'));
	  logger.info({ message: 'Versions: ', data: process.versions });
	  logger.info(version + ' is up and running');
	});
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 1 */
/*!*****************************!*\
  !*** ./~/babel/register.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! babel-core/register */ 2);


/***/ },
/* 2 */
/*!**********************************!*\
  !*** ./~/babel-core/register.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/babel/api/register/node-polyfill */ 3);


/***/ },
/* 3 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/api/register/node-polyfill.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequire(obj) { return obj && obj.__esModule ? obj["default"] : obj; }
	
	__webpack_require__(/*! ../../polyfill */ 4);
	
	var _node = __webpack_require__(/*! ./node */ 93);
	
	exports["default"] = _interopRequire(_node);
	module.exports = exports["default"];

/***/ },
/* 4 */
/*!********************************************!*\
  !*** ./~/babel-core/lib/babel/polyfill.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	__webpack_require__(/*! core-js/shim */ 5);
	
	__webpack_require__(/*! regenerator/runtime */ 92);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel/polyfill is allowed");
	}
	global._babelPolyfill = true;

/***/ },
/* 5 */
/*!****************************************!*\
  !*** ./~/babel-core/~/core-js/shim.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./modules/es5 */ 6);
	__webpack_require__(/*! ./modules/es6.symbol */ 23);
	__webpack_require__(/*! ./modules/es6.object.assign */ 26);
	__webpack_require__(/*! ./modules/es6.object.is */ 28);
	__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ 29);
	__webpack_require__(/*! ./modules/es6.object.to-string */ 31);
	__webpack_require__(/*! ./modules/es6.object.statics-accept-primitives */ 32);
	__webpack_require__(/*! ./modules/es6.function.name */ 33);
	__webpack_require__(/*! ./modules/es6.function.has-instance */ 34);
	__webpack_require__(/*! ./modules/es6.number.constructor */ 35);
	__webpack_require__(/*! ./modules/es6.number.statics */ 36);
	__webpack_require__(/*! ./modules/es6.math */ 37);
	__webpack_require__(/*! ./modules/es6.string.from-code-point */ 38);
	__webpack_require__(/*! ./modules/es6.string.raw */ 39);
	__webpack_require__(/*! ./modules/es6.string.iterator */ 40);
	__webpack_require__(/*! ./modules/es6.string.code-point-at */ 44);
	__webpack_require__(/*! ./modules/es6.string.ends-with */ 45);
	__webpack_require__(/*! ./modules/es6.string.includes */ 46);
	__webpack_require__(/*! ./modules/es6.string.repeat */ 47);
	__webpack_require__(/*! ./modules/es6.string.starts-with */ 49);
	__webpack_require__(/*! ./modules/es6.array.from */ 50);
	__webpack_require__(/*! ./modules/es6.array.of */ 53);
	__webpack_require__(/*! ./modules/es6.array.iterator */ 54);
	__webpack_require__(/*! ./modules/es6.array.species */ 56);
	__webpack_require__(/*! ./modules/es6.array.copy-within */ 58);
	__webpack_require__(/*! ./modules/es6.array.fill */ 59);
	__webpack_require__(/*! ./modules/es6.array.find */ 60);
	__webpack_require__(/*! ./modules/es6.array.find-index */ 61);
	__webpack_require__(/*! ./modules/es6.regexp */ 62);
	__webpack_require__(/*! ./modules/es6.promise */ 63);
	__webpack_require__(/*! ./modules/es6.map */ 67);
	__webpack_require__(/*! ./modules/es6.set */ 70);
	__webpack_require__(/*! ./modules/es6.weak-map */ 71);
	__webpack_require__(/*! ./modules/es6.weak-set */ 73);
	__webpack_require__(/*! ./modules/es6.reflect */ 74);
	__webpack_require__(/*! ./modules/es7.array.includes */ 76);
	__webpack_require__(/*! ./modules/es7.string.at */ 77);
	__webpack_require__(/*! ./modules/es7.string.lpad */ 78);
	__webpack_require__(/*! ./modules/es7.string.rpad */ 80);
	__webpack_require__(/*! ./modules/es7.regexp.escape */ 81);
	__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ 82);
	__webpack_require__(/*! ./modules/es7.object.to-array */ 83);
	__webpack_require__(/*! ./modules/es7.map.to-json */ 84);
	__webpack_require__(/*! ./modules/es7.set.to-json */ 86);
	__webpack_require__(/*! ./modules/js.array.statics */ 87);
	__webpack_require__(/*! ./modules/web.timers */ 88);
	__webpack_require__(/*! ./modules/web.immediate */ 90);
	__webpack_require__(/*! ./modules/web.dom.iterable */ 91);
	module.exports = __webpack_require__(/*! ./modules/$ */ 7).core;


/***/ },
/* 6 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es5.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var $                = __webpack_require__(/*! ./$ */ 7)
	  , cel              = __webpack_require__(/*! ./$.dom-create */ 9)
	  , cof              = __webpack_require__(/*! ./$.cof */ 10)
	  , $def             = __webpack_require__(/*! ./$.def */ 14)
	  , invoke           = __webpack_require__(/*! ./$.invoke */ 16)
	  , arrayMethod      = __webpack_require__(/*! ./$.array-methods */ 17)
	  , IE_PROTO         = __webpack_require__(/*! ./$.uid */ 13).safe('__proto__')
	  , assert           = __webpack_require__(/*! ./$.assert */ 19)
	  , assertObject     = assert.obj
	  , ObjectProto      = Object.prototype
	  , html             = $.html
	  , A                = []
	  , _slice           = A.slice
	  , _join            = A.join
	  , classof          = cof.classof
	  , has              = $.has
	  , defineProperty   = $.setDesc
	  , getOwnDescriptor = $.getDesc
	  , defineProperties = $.setDescs
	  , isFunction       = $.isFunction
	  , isObject         = $.isObject
	  , toObject         = $.toObject
	  , toLength         = $.toLength
	  , toIndex          = $.toIndex
	  , IE8_DOM_DEFINE   = false
	  , $indexOf         = __webpack_require__(/*! ./$.array-includes */ 20)(false)
	  , $forEach         = arrayMethod(0)
	  , $map             = arrayMethod(1)
	  , $filter          = arrayMethod(2)
	  , $some            = arrayMethod(3)
	  , $every           = arrayMethod(4);
	
	if(!$.DESC){
	  try {
	    IE8_DOM_DEFINE = defineProperty(cel('div'), 'x',
	      {get: function(){ return 8; }}
	    ).x == 8;
	  } catch(e){ /* empty */ }
	  $.setDesc = function(O, P, Attributes){
	    if(IE8_DOM_DEFINE)try {
	      return defineProperty(O, P, Attributes);
	    } catch(e){ /* empty */ }
	    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	    if('value' in Attributes)assertObject(O)[P] = Attributes.value;
	    return O;
	  };
	  $.getDesc = function(O, P){
	    if(IE8_DOM_DEFINE)try {
	      return getOwnDescriptor(O, P);
	    } catch(e){ /* empty */ }
	    if(has(O, P))return $.desc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
	  };
	  $.setDescs = defineProperties = function(O, Properties){
	    assertObject(O);
	    var keys   = $.getKeys(Properties)
	      , length = keys.length
	      , i = 0
	      , P;
	    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
	    return O;
	  };
	}
	$def($def.S + $def.F * !$.DESC, 'Object', {
	  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $.getDesc,
	  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	  defineProperty: $.setDesc,
	  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	  defineProperties: defineProperties
	});
	
	  // IE 8- don't enum bug keys
	var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
	            'toLocaleString,toString,valueOf').split(',')
	  // Additional keys for getOwnPropertyNames
	  , keys2 = keys1.concat('length', 'prototype')
	  , keysLen1 = keys1.length;
	
	// Create object with `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = cel('iframe')
	    , i      = keysLen1
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict.prototype[keys1[i]];
	  return createDict();
	};
	function createGetKeys(names, length){
	  return function(object){
	    var O      = toObject(object)
	      , i      = 0
	      , result = []
	      , key;
	    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	    // Don't enum bug & hidden keys
	    while(length > i)if(has(O, key = names[i++])){
	      ~$indexOf(result, key) || result.push(key);
	    }
	    return result;
	  };
	}
	function Empty(){}
	$def($def.S, 'Object', {
	  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	  getPrototypeOf: $.getProto = $.getProto || function(O){
	    O = Object(assert.def(O));
	    if(has(O, IE_PROTO))return O[IE_PROTO];
	    if(isFunction(O.constructor) && O instanceof O.constructor){
	      return O.constructor.prototype;
	    } return O instanceof Object ? ObjectProto : null;
	  },
	  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
	  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	  create: $.create = $.create || function(O, /*?*/Properties){
	    var result;
	    if(O !== null){
	      Empty.prototype = assertObject(O);
	      result = new Empty();
	      Empty.prototype = null;
	      // add "__proto__" for Object.getPrototypeOf shim
	      result[IE_PROTO] = O;
	    } else result = createDict();
	    return Properties === undefined ? result : defineProperties(result, Properties);
	  },
	  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
	  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false),
	  // 19.1.2.17 / 15.2.3.8 Object.seal(O)
	  seal: function seal(it){
	    return it; // <- cap
	  },
	  // 19.1.2.5 / 15.2.3.9 Object.freeze(O)
	  freeze: function freeze(it){
	    return it; // <- cap
	  },
	  // 19.1.2.15 / 15.2.3.10 Object.preventExtensions(O)
	  preventExtensions: function preventExtensions(it){
	    return it; // <- cap
	  },
	  // 19.1.2.13 / 15.2.3.11 Object.isSealed(O)
	  isSealed: function isSealed(it){
	    return !isObject(it); // <- cap
	  },
	  // 19.1.2.12 / 15.2.3.12 Object.isFrozen(O)
	  isFrozen: function isFrozen(it){
	    return !isObject(it); // <- cap
	  },
	  // 19.1.2.11 / 15.2.3.13 Object.isExtensible(O)
	  isExtensible: function isExtensible(it){
	    return isObject(it); // <- cap
	  }
	});
	
	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	$def($def.P, 'Function', {
	  bind: function(that /*, args... */){
	    var fn       = assert.fn(this)
	      , partArgs = _slice.call(arguments, 1);
	    function bound(/* args... */){
	      var args   = partArgs.concat(_slice.call(arguments))
	        , constr = this instanceof bound
	        , ctx    = constr ? $.create(fn.prototype) : that
	        , result = invoke(fn, args, ctx);
	      return constr ? ctx : result;
	    }
	    if(fn.prototype)bound.prototype = fn.prototype;
	    return bound;
	  }
	});
	
	// Fix for not array-like ES3 string and DOM objects
	if(!(0 in Object('z') && 'z'[0] == 'z')){
	  $.ES5Object = function(it){
	    return cof(it) == 'String' ? it.split('') : Object(it);
	  };
	}
	
	var buggySlice = true;
	try {
	  if(html)_slice.call(html);
	  buggySlice = false;
	} catch(e){ /* empty */ }
	
	$def($def.P + $def.F * buggySlice, 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return _slice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});
	
	$def($def.P + $def.F * ($.ES5Object != Object), 'Array', {
	  join: function join(){
	    return _join.apply($.ES5Object(this), arguments);
	  }
	});
	
	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	$def($def.S, 'Array', {
	  isArray: function(arg){
	    return cof(arg) == 'Array';
	  }
	});
	function createArrayReduce(isRight){
	  return function(callbackfn, memo){
	    assert.fn(callbackfn);
	    var O      = toObject(this)
	      , length = toLength(O.length)
	      , index  = isRight ? length - 1 : 0
	      , i      = isRight ? -1 : 1;
	    if(arguments.length < 2)for(;;){
	      if(index in O){
	        memo = O[index];
	        index += i;
	        break;
	      }
	      index += i;
	      assert(isRight ? index >= 0 : length > index, 'Reduce of empty array with no initial value');
	    }
	    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
	      memo = callbackfn(memo, O[index], index, this);
	    }
	    return memo;
	  };
	}
	$def($def.P, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: $.each = $.each || function forEach(callbackfn/*, that = undefined */){
	    return $forEach(this, callbackfn, arguments[1]);
	  },
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn/*, that = undefined */){
	    return $map(this, callbackfn, arguments[1]);
	  },
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn/*, that = undefined */){
	    return $filter(this, callbackfn, arguments[1]);
	  },
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn/*, that = undefined */){
	    return $some(this, callbackfn, arguments[1]);
	  },
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn/*, that = undefined */){
	    return $every(this, callbackfn, arguments[1]);
	  },
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: createArrayReduce(false),
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: createArrayReduce(true),
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(el /*, fromIndex = 0 */){
	    return $indexOf(this, el, arguments[1]);
	  },
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
	    var O      = toObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, $.toInteger(fromIndex));
	    if(index < 0)index = toLength(length + index);
	    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
	    return -1;
	  }
	});
	
	// 21.1.3.25 / 15.5.4.20 String.prototype.trim()
	$def($def.P, 'String', {trim: __webpack_require__(/*! ./$.replacer */ 21)(/^\s*([\s\S]*\S)?\s*$/, '$1')});
	
	// 20.3.3.1 / 15.9.4.4 Date.now()
	$def($def.S, 'Date', {now: function(){
	  return +new Date;
	}});
	
	function lz(num){
	  return num > 9 ? num : '0' + num;
	}
	
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	// PhantomJS and old webkit had a broken Date implementation.
	var date       = new Date(-5e13 - 1)
	  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
	      && __webpack_require__(/*! ./$.throws */ 22)(function(){ new Date(NaN).toISOString(); }));
	$def($def.P + $def.F * brokenDate, 'Date', {toISOString: function(){
	  if(!isFinite(this))throw RangeError('Invalid time value');
	  var d = this
	    , y = d.getUTCFullYear()
	    , m = d.getUTCMilliseconds()
	    , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	}});
	
	if(classof(function(){ return arguments; }()) == 'Object')cof.classof = function(it){
	  var tag = classof(it);
	  return tag == 'Object' && isFunction(it.callee) ? 'Arguments' : tag;
	};

/***/ },
/* 7 */
/*!*********************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global = typeof self != 'undefined' ? self : Function('return this')()
	  , core   = {}
	  , defineProperty = Object.defineProperty
	  , hasOwnProperty = {}.hasOwnProperty
	  , ceil  = Math.ceil
	  , floor = Math.floor
	  , max   = Math.max
	  , min   = Math.min;
	// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
	var DESC = !!function(){
	  try {
	    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
	  } catch(e){ /* empty */ }
	}();
	var hide = createDefiner(1);
	// 7.1.4 ToInteger
	function toInteger(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	}
	function desc(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	}
	function simpleSet(object, key, value){
	  object[key] = value;
	  return object;
	}
	function createDefiner(bitmap){
	  return DESC ? function(object, key, value){
	    return $.setDesc(object, key, desc(bitmap, value));
	  } : simpleSet;
	}
	
	function isObject(it){
	  return it !== null && (typeof it == 'object' || typeof it == 'function');
	}
	function isFunction(it){
	  return typeof it == 'function';
	}
	function assertDefined(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	}
	
	var $ = module.exports = __webpack_require__(/*! ./$.fw */ 8)({
	  g: global,
	  core: core,
	  html: global.document && document.documentElement,
	  // http://jsperf.com/core-js-isobject
	  isObject:   isObject,
	  isFunction: isFunction,
	  that: function(){
	    return this;
	  },
	  // 7.1.4 ToInteger
	  toInteger: toInteger,
	  // 7.1.15 ToLength
	  toLength: function(it){
	    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	  },
	  toIndex: function(index, length){
	    index = toInteger(index);
	    return index < 0 ? max(index + length, 0) : min(index, length);
	  },
	  has: function(it, key){
	    return hasOwnProperty.call(it, key);
	  },
	  create:     Object.create,
	  getProto:   Object.getPrototypeOf,
	  DESC:       DESC,
	  desc:       desc,
	  getDesc:    Object.getOwnPropertyDescriptor,
	  setDesc:    defineProperty,
	  setDescs:   Object.defineProperties,
	  getKeys:    Object.keys,
	  getNames:   Object.getOwnPropertyNames,
	  getSymbols: Object.getOwnPropertySymbols,
	  assertDefined: assertDefined,
	  // Dummy, fix for not array-like ES3 string in es5 module
	  ES5Object: Object,
	  toObject: function(it){
	    return $.ES5Object(assertDefined(it));
	  },
	  hide: hide,
	  def: createDefiner(0),
	  set: global.Symbol ? simpleSet : hide,
	  each: [].forEach
	});
	/* eslint-disable no-undef */
	if(typeof __e != 'undefined')__e = core;
	if(typeof __g != 'undefined')__g = global;

/***/ },
/* 8 */
/*!************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.fw.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function($){
	  $.FW   = true;
	  $.path = $.g;
	  return $;
	};

/***/ },
/* 9 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.dom-create.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(/*! ./$ */ 7)
	  , document = $.g.document
	  , isObject = $.isObject
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 10 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.cof.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(/*! ./$ */ 7)
	  , TAG      = __webpack_require__(/*! ./$.wks */ 11)('toStringTag')
	  , toString = {}.toString;
	function cof(it){
	  return toString.call(it).slice(8, -1);
	}
	cof.classof = function(it){
	  var O, T;
	  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
	    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
	};
	cof.set = function(it, tag, stat){
	  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
	};
	module.exports = cof;

/***/ },
/* 11 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.wks.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(/*! ./$ */ 7).g
	  , store  = __webpack_require__(/*! ./$.shared */ 12)('wks');
	module.exports = function(name){
	  return store[name] || (store[name] =
	    global.Symbol && global.Symbol[name] || __webpack_require__(/*! ./$.uid */ 13).safe('Symbol.' + name));
	};

/***/ },
/* 12 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.shared.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $      = __webpack_require__(/*! ./$ */ 7)
	  , SHARED = '__core-js_shared__'
	  , store  = $.g[SHARED] || $.hide($.g, SHARED, {})[SHARED];
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 13 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.uid.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var sid = 0;
	function uid(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));
	}
	uid.safe = __webpack_require__(/*! ./$ */ 7).g.Symbol || uid;
	module.exports = uid;

/***/ },
/* 14 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.def.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(/*! ./$ */ 7)
	  , global     = $.g
	  , core       = $.core
	  , isFunction = $.isFunction
	  , $redef     = __webpack_require__(/*! ./$.redef */ 15);
	function ctx(fn, that){
	  return function(){
	    return fn.apply(that, arguments);
	  };
	}
	global.core = core;
	// type bitmap
	$def.F = 1;  // forced
	$def.G = 2;  // global
	$def.S = 4;  // static
	$def.P = 8;  // proto
	$def.B = 16; // bind
	$def.W = 32; // wrap
	function $def(type, name, source){
	  var key, own, out, exp
	    , isGlobal = type & $def.G
	    , isProto  = type & $def.P
	    , target   = isGlobal ? global : type & $def.S
	        ? global[name] : (global[name] || {}).prototype
	    , exports  = isGlobal ? core : core[name] || (core[name] = {});
	  if(isGlobal)source = name;
	  for(key in source){
	    // contains in native
	    own = !(type & $def.F) && target && key in target;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    if(type & $def.B && own)exp = ctx(out, global);
	    else exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
	    // extend global
	    if(target && !own)$redef(target, key, out);
	    // export
	    if(exports[key] != out)$.hide(exports, key, exp);
	    if(isProto)(exports.prototype || (exports.prototype = {}))[key] = out;
	  }
	}
	module.exports = $def;

/***/ },
/* 15 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.redef.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $   = __webpack_require__(/*! ./$ */ 7)
	  , tpl = String({}.hasOwnProperty)
	  , SRC = __webpack_require__(/*! ./$.uid */ 13).safe('src')
	  , _toString = Function.toString;
	
	function $redef(O, key, val, safe){
	  if($.isFunction(val)){
	    var base = O[key];
	    $.hide(val, SRC, base ? String(base) : tpl.replace(/hasOwnProperty/, String(key)));
	  }
	  if(O === $.g){
	    O[key] = val;
	  } else {
	    if(!safe)delete O[key];
	    $.hide(O, key, val);
	  }
	}
	
	// add fake Function#toString for correct work wrapped methods / constructors
	// with methods similar to LoDash isNative
	$redef(Function.prototype, 'toString', function toString(){
	  return $.has(this, SRC) ? this[SRC] : _toString.call(this);
	});
	
	$.core.inspectSource = function(it){
	  return _toString.call(it);
	};
	
	module.exports = $redef;

/***/ },
/* 16 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.invoke.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Fast apply
	// http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
	                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 17 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.array-methods.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var $   = __webpack_require__(/*! ./$ */ 7)
	  , ctx = __webpack_require__(/*! ./$.ctx */ 18);
	module.exports = function(TYPE){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
	  return function($this, callbackfn, that){
	    var O      = Object($.assertDefined($this))
	      , self   = $.ES5Object(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = $.toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 18 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.ctx.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Optional / simple context binding
	var assertFunction = __webpack_require__(/*! ./$.assert */ 19).fn;
	module.exports = function(fn, that, length){
	  assertFunction(fn);
	  if(~length && that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  } return function(/* ...args */){
	      return fn.apply(that, arguments);
	    };
	};

/***/ },
/* 19 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.assert.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(/*! ./$ */ 7);
	function assert(condition, msg1, msg2){
	  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
	}
	assert.def = $.assertDefined;
	assert.fn = function(it){
	  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
	  return it;
	};
	assert.obj = function(it){
	  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};
	assert.inst = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};
	module.exports = assert;

/***/ },
/* 20 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.array-includes.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var $ = __webpack_require__(/*! ./$ */ 7);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = $.toObject($this)
	      , length = $.toLength(O.length)
	      , index  = $.toIndex(fromIndex, length)
	      , value;
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 21 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.replacer.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	module.exports = function(regExp, replace, isStatic){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(isStatic ? it : this).replace(regExp, replacer);
	  };
	};

/***/ },
/* 22 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.throws.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(exec){
	  try {
	    exec();
	    return false;
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 23 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.symbol.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , setTag   = __webpack_require__(/*! ./$.cof */ 10).set
	  , uid      = __webpack_require__(/*! ./$.uid */ 13)
	  , shared   = __webpack_require__(/*! ./$.shared */ 12)
	  , $def     = __webpack_require__(/*! ./$.def */ 14)
	  , $redef   = __webpack_require__(/*! ./$.redef */ 15)
	  , keyOf    = __webpack_require__(/*! ./$.keyof */ 24)
	  , enumKeys = __webpack_require__(/*! ./$.enum-keys */ 25)
	  , assertObject = __webpack_require__(/*! ./$.assert */ 19).obj
	  , ObjectProto = Object.prototype
	  , DESC     = $.DESC
	  , has      = $.has
	  , $create  = $.create
	  , getDesc  = $.getDesc
	  , setDesc  = $.setDesc
	  , desc     = $.desc
	  , getNames = $.getNames
	  , toObject = $.toObject
	  , $Symbol  = $.g.Symbol
	  , setter   = false
	  , TAG      = uid('tag')
	  , HIDDEN   = uid('hidden')
	  , _propertyIsEnumerable = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols = shared('symbols')
	  , useNative = $.isFunction($Symbol);
	
	var setSymbolDesc = DESC ? function(){ // fallback for old Android
	  try {
	    return $create(setDesc({}, HIDDEN, {
	      get: function(){
	        return setDesc(this, HIDDEN, {value: false})[HIDDEN];
	      }
	    }))[HIDDEN] || setDesc;
	  } catch(e){
	    return function(it, key, D){
	      var protoDesc = getDesc(ObjectProto, key);
	      if(protoDesc)delete ObjectProto[key];
	      setDesc(it, key, D);
	      if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	    };
	  }
	}() : setDesc;
	
	function wrap(tag){
	  var sym = AllSymbols[tag] = $.set($create($Symbol.prototype), TAG, tag);
	  DESC && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, desc(1, value));
	    }
	  });
	  return sym;
	}
	
	function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, desc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = $create(D, {enumerable: desc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	}
	function defineProperties(it, P){
	  assertObject(it);
	  var keys = enumKeys(P = toObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)defineProperty(it, key = keys[i++], P[key]);
	  return it;
	}
	function create(it, P){
	  return P === undefined ? $create(it) : defineProperties($create(it), P);
	}
	function propertyIsEnumerable(key){
	  var E = _propertyIsEnumerable.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	}
	function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	}
	function getOwnPropertyNames(it){
	  var names  = getNames(toObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	}
	function getOwnPropertySymbols(it){
	  var names  = getNames(toObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	}
	
	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments[0]));
	  };
	  $redef($Symbol.prototype, 'toString', function(){
	    return this[TAG];
	  });
	
	  $.create     = create;
	  $.setDesc    = defineProperty;
	  $.getDesc    = getOwnPropertyDescriptor;
	  $.setDescs   = defineProperties;
	  $.getNames   = getOwnPropertyNames;
	  $.getSymbols = getOwnPropertySymbols;
	
	  if($.DESC && $.FW)$redef(Object.prototype, 'propertyIsEnumerable', propertyIsEnumerable, true);
	}
	
	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	    'species,split,toPrimitive,toStringTag,unscopables'
	  ).split(','), function(it){
	    var sym = __webpack_require__(/*! ./$.wks */ 11)(it);
	    symbolStatics[it] = useNative ? sym : wrap(sym);
	  }
	);
	
	setter = true;
	
	$def($def.G + $def.W, {Symbol: $Symbol});
	
	$def($def.S, 'Symbol', symbolStatics);
	
	$def($def.S + $def.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: getOwnPropertySymbols
	});
	
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setTag($.g.JSON, 'JSON', true);

/***/ },
/* 24 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.keyof.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(/*! ./$ */ 7);
	module.exports = function(object, el){
	  var O      = $.toObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 25 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.enum-keys.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(/*! ./$ */ 7);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getDesc    = $.getDesc
	    , getSymbols = $.getSymbols;
	  if(getSymbols)$.each.call(getSymbols(it), function(key){
	    if(getDesc(it, key).enumerable)keys.push(key);
	  });
	  return keys;
	};

/***/ },
/* 26 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.assign.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $def = __webpack_require__(/*! ./$.def */ 14);
	$def($def.S, 'Object', {assign: __webpack_require__(/*! ./$.assign */ 27)});

/***/ },
/* 27 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.assign.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(/*! ./$ */ 7)
	  , enumKeys = __webpack_require__(/*! ./$.enum-keys */ 25);
	// 19.1.2.1 Object.assign(target, source, ...)
	/* eslint-disable no-unused-vars */
	module.exports = Object.assign || function assign(target, source){
	/* eslint-enable no-unused-vars */
	  var T = Object($.assertDefined(target))
	    , l = arguments.length
	    , i = 1;
	  while(l > i){
	    var S      = $.ES5Object(arguments[i++])
	      , keys   = enumKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)T[key = keys[j++]] = S[key];
	  }
	  return T;
	};

/***/ },
/* 28 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.is.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $def = __webpack_require__(/*! ./$.def */ 14);
	$def($def.S, 'Object', {
	  is: function is(x, y){
	    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	  }
	});

/***/ },
/* 29 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.set-prototype-of.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $def = __webpack_require__(/*! ./$.def */ 14);
	$def($def.S, 'Object', {setPrototypeOf: __webpack_require__(/*! ./$.set-proto */ 30).set});

/***/ },
/* 30 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.set-proto.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var $      = __webpack_require__(/*! ./$ */ 7)
	  , assert = __webpack_require__(/*! ./$.assert */ 19);
	function check(O, proto){
	  assert.obj(O);
	  assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
	}
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
	    ? function(buggy, set){
	        try {
	          set = __webpack_require__(/*! ./$.ctx */ 18)(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
	          set({}, []);
	        } catch(e){ buggy = true; }
	        return function setPrototypeOf(O, proto){
	          check(O, proto);
	          if(buggy)O.__proto__ = proto;
	          else set(O, proto);
	          return O;
	        };
	      }()
	    : undefined),
	  check: check
	};

/***/ },
/* 31 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.to-string.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(/*! ./$.cof */ 10)
	  , tmp = {};
	tmp[__webpack_require__(/*! ./$.wks */ 11)('toStringTag')] = 'z';
	if(__webpack_require__(/*! ./$ */ 7).FW && cof(tmp) != 'z'){
	  __webpack_require__(/*! ./$.redef */ 15)(Object.prototype, 'toString', function toString(){
	    return '[object ' + cof.classof(this) + ']';
	  }, true);
	}

/***/ },
/* 32 */
/*!********************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.object.statics-accept-primitives.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(/*! ./$ */ 7)
	  , $def     = __webpack_require__(/*! ./$.def */ 14)
	  , isObject = $.isObject
	  , toObject = $.toObject;
	$.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' +
	  'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(',')
	, function(KEY, ID){
	  var fn     = ($.core.Object || {})[KEY] || Object[KEY]
	    , forced = 0
	    , method = {};
	  method[KEY] = ID == 0 ? function freeze(it){
	    return isObject(it) ? fn(it) : it;
	  } : ID == 1 ? function seal(it){
	    return isObject(it) ? fn(it) : it;
	  } : ID == 2 ? function preventExtensions(it){
	    return isObject(it) ? fn(it) : it;
	  } : ID == 3 ? function isFrozen(it){
	    return isObject(it) ? fn(it) : true;
	  } : ID == 4 ? function isSealed(it){
	    return isObject(it) ? fn(it) : true;
	  } : ID == 5 ? function isExtensible(it){
	    return isObject(it) ? fn(it) : false;
	  } : ID == 6 ? function getOwnPropertyDescriptor(it, key){
	    return fn(toObject(it), key);
	  } : ID == 7 ? function getPrototypeOf(it){
	    return fn(Object($.assertDefined(it)));
	  } : ID == 8 ? function keys(it){
	    return fn(toObject(it));
	  } : function getOwnPropertyNames(it){
	    return fn(toObject(it));
	  };
	  try {
	    fn('z');
	  } catch(e){
	    forced = 1;
	  }
	  $def($def.S + $def.F * forced, 'Object', method);
	});

/***/ },
/* 33 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.function.name.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $    = __webpack_require__(/*! ./$ */ 7)
	  , NAME = 'name'
	  , setDesc = $.setDesc
	  , FunctionProto = Function.prototype;
	// 19.2.4.2 name
	NAME in FunctionProto || $.FW && $.DESC && setDesc(FunctionProto, NAME, {
	  configurable: true,
	  get: function(){
	    var match = String(this).match(/^\s*function ([^ (]*)/)
	      , name  = match ? match[1] : '';
	    $.has(this, NAME) || setDesc(this, NAME, $.desc(5, name));
	    return name;
	  },
	  set: function(value){
	    $.has(this, NAME) || setDesc(this, NAME, $.desc(0, value));
	  }
	});

/***/ },
/* 34 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.function.has-instance.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $             = __webpack_require__(/*! ./$ */ 7)
	  , HAS_INSTANCE  = __webpack_require__(/*! ./$.wks */ 11)('hasInstance')
	  , FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(!$.isFunction(this) || !$.isObject(O))return false;
	  if(!$.isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = $.getProto(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 35 */
/*!******************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.constructor.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(/*! ./$ */ 7)
	  , isObject   = $.isObject
	  , isFunction = $.isFunction
	  , NUMBER     = 'Number'
	  , $Number    = $.g[NUMBER]
	  , Base       = $Number
	  , proto      = $Number.prototype;
	function toPrimitive(it){
	  var fn, val;
	  if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
	  if(isFunction(fn = it.toString) && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to number");
	}
	function toNumber(it){
	  if(isObject(it))it = toPrimitive(it);
	  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
	    var binary = false;
	    switch(it.charCodeAt(1)){
	      case 66 : case 98  : binary = true;
	      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
	    }
	  } return +it;
	}
	if($.FW && !($Number('0o1') && $Number('0b1'))){
	  $Number = function Number(it){
	    return this instanceof $Number ? new Base(toNumber(it)) : toNumber(it);
	  };
	  $.each.call($.DESC ? $.getNames(Base) : (
	      // ES3:
	      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	      // ES6 (in case, if modules with ES6 Number statics required before):
	      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	    ).split(','), function(key){
	      if($.has(Base, key) && !$.has($Number, key)){
	        $.setDesc($Number, key, $.getDesc(Base, key));
	      }
	    }
	  );
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(/*! ./$.redef */ 15)($.g, NUMBER, $Number);
	}

/***/ },
/* 36 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.number.statics.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $     = __webpack_require__(/*! ./$ */ 7)
	  , $def  = __webpack_require__(/*! ./$.def */ 14)
	  , abs   = Math.abs
	  , floor = Math.floor
	  , _isFinite = $.g.isFinite
	  , MAX_SAFE_INTEGER = 0x1fffffffffffff; // pow(2, 53) - 1 == 9007199254740991;
	function isInteger(it){
	  return !$.isObject(it) && _isFinite(it) && floor(it) === it;
	}
	$def($def.S, 'Number', {
	  // 20.1.2.1 Number.EPSILON
	  EPSILON: Math.pow(2, -52),
	  // 20.1.2.2 Number.isFinite(number)
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  },
	  // 20.1.2.3 Number.isInteger(number)
	  isInteger: isInteger,
	  // 20.1.2.4 Number.isNaN(number)
	  isNaN: function isNaN(number){
	    return number != number;
	  },
	  // 20.1.2.5 Number.isSafeInteger(number)
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
	  },
	  // 20.1.2.6 Number.MAX_SAFE_INTEGER
	  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
	  // 20.1.2.10 Number.MIN_SAFE_INTEGER
	  MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
	  // 20.1.2.12 Number.parseFloat(string)
	  parseFloat: parseFloat,
	  // 20.1.2.13 Number.parseInt(string, radix)
	  parseInt: parseInt
	});

/***/ },
/* 37 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.math.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var Infinity = 1 / 0
	  , $def  = __webpack_require__(/*! ./$.def */ 14)
	  , E     = Math.E
	  , pow   = Math.pow
	  , abs   = Math.abs
	  , exp   = Math.exp
	  , log   = Math.log
	  , sqrt  = Math.sqrt
	  , ceil  = Math.ceil
	  , floor = Math.floor
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	function roundTiesToEven(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	}
	
	// 20.2.2.28 Math.sign(x)
	function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	}
	// 20.2.2.5 Math.asinh(x)
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
	}
	// 20.2.2.14 Math.expm1(x)
	function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
	}
	
	$def($def.S, 'Math', {
	  // 20.2.2.3 Math.acosh(x)
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
	  },
	  // 20.2.2.5 Math.asinh(x)
	  asinh: asinh,
	  // 20.2.2.7 Math.atanh(x)
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
	  },
	  // 20.2.2.9 Math.cbrt(x)
	  cbrt: function cbrt(x){
	    return sign(x = +x) * pow(abs(x), 1 / 3);
	  },
	  // 20.2.2.11 Math.clz32(x)
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * Math.LOG2E) : 32;
	  },
	  // 20.2.2.12 Math.cosh(x)
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  },
	  // 20.2.2.14 Math.expm1(x)
	  expm1: expm1,
	  // 20.2.2.16 Math.fround(x)
	  fround: function fround(x){
	    var $abs  = abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  },
	  // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , len  = arguments.length
	      , args = Array(len)
	      , larg = 0
	      , arg;
	    while(i < len){
	      arg = args[i] = abs(arguments[i++]);
	      if(arg == Infinity)return Infinity;
	      if(arg > larg)larg = arg;
	    }
	    larg = larg || 1;
	    while(len--)sum += pow(args[len] / larg, 2);
	    return larg * sqrt(sum);
	  },
	  // 20.2.2.18 Math.imul(x, y)
	  imul: function imul(x, y){
	    var UInt16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UInt16 & xn
	      , yl = UInt16 & yn;
	    return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
	  },
	  // 20.2.2.20 Math.log1p(x)
	  log1p: function log1p(x){
	    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
	  },
	  // 20.2.2.21 Math.log10(x)
	  log10: function log10(x){
	    return log(x) / Math.LN10;
	  },
	  // 20.2.2.22 Math.log2(x)
	  log2: function log2(x){
	    return log(x) / Math.LN2;
	  },
	  // 20.2.2.28 Math.sign(x)
	  sign: sign,
	  // 20.2.2.30 Math.sinh(x)
	  sinh: function sinh(x){
	    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
	  },
	  // 20.2.2.33 Math.tanh(x)
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  },
	  // 20.2.2.34 Math.trunc(x)
	  trunc: function trunc(it){
	    return (it > 0 ? floor : ceil)(it);
	  }
	});

/***/ },
/* 38 */
/*!**********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.from-code-point.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def    = __webpack_require__(/*! ./$.def */ 14)
	  , toIndex = __webpack_require__(/*! ./$ */ 7).toIndex
	  , fromCharCode = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res = []
	      , len = arguments.length
	      , i   = 0
	      , code;
	    while(len > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 39 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.raw.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $    = __webpack_require__(/*! ./$ */ 7)
	  , $def = __webpack_require__(/*! ./$.def */ 14);
	
	$def($def.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl = $.toObject(callSite.raw)
	      , len = $.toLength(tpl.length)
	      , sln = arguments.length
	      , res = []
	      , i   = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < sln)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 40 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.iterator.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var set   = __webpack_require__(/*! ./$ */ 7).set
	  , $at   = __webpack_require__(/*! ./$.string-at */ 41)(true)
	  , ITER  = __webpack_require__(/*! ./$.uid */ 13).safe('iter')
	  , $iter = __webpack_require__(/*! ./$.iter */ 42)
	  , step  = $iter.step;
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(/*! ./$.iter-define */ 43)(String, 'String', function(iterated){
	  set(this, ITER, {o: String(iterated), i: 0});
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var iter  = this[ITER]
	    , O     = iter.o
	    , index = iter.i
	    , point;
	  if(index >= O.length)return step(1);
	  point = $at(O, index);
	  iter.i += point.length;
	  return step(0, point);
	});

/***/ },
/* 41 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-at.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// true  -> String#at
	// false -> String#codePointAt
	var $ = __webpack_require__(/*! ./$ */ 7);
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String($.assertDefined(that))
	      , i = $.toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l
	      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	        ? TO_STRING ? s.charAt(i) : a
	        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 42 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $                 = __webpack_require__(/*! ./$ */ 7)
	  , cof               = __webpack_require__(/*! ./$.cof */ 10)
	  , assertObject      = __webpack_require__(/*! ./$.assert */ 19).obj
	  , SYMBOL_ITERATOR   = __webpack_require__(/*! ./$.wks */ 11)('iterator')
	  , FF_ITERATOR       = '@@iterator'
	  , Iterators         = __webpack_require__(/*! ./$.shared */ 12)('iterators')
	  , IteratorPrototype = {};
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	setIterator(IteratorPrototype, $.that);
	function setIterator(O, value){
	  $.hide(O, SYMBOL_ITERATOR, value);
	  // Add iterator for FF iterator protocol
	  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
	}
	
	module.exports = {
	  // Safari has buggy iterators w/o `next`
	  BUGGY: 'keys' in [] && !('next' in [].keys()),
	  Iterators: Iterators,
	  step: function(done, value){
	    return {value: value, done: !!done};
	  },
	  is: function(it){
	    var O      = Object(it)
	      , Symbol = $.g.Symbol
	      , SYM    = Symbol && Symbol.iterator || FF_ITERATOR;
	    return SYM in O || SYMBOL_ITERATOR in O || $.has(Iterators, cof.classof(O));
	  },
	  get: function(it){
	    var Symbol  = $.g.Symbol
	      , ext     = it[Symbol && Symbol.iterator || FF_ITERATOR]
	      , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[cof.classof(it)];
	    return assertObject(getIter.call(it));
	  },
	  set: setIterator,
	  create: function(Constructor, NAME, next, proto){
	    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
	    cof.set(Constructor, NAME + ' Iterator');
	  }
	};

/***/ },
/* 43 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-define.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def            = __webpack_require__(/*! ./$.def */ 14)
	  , $redef          = __webpack_require__(/*! ./$.redef */ 15)
	  , $               = __webpack_require__(/*! ./$ */ 7)
	  , cof             = __webpack_require__(/*! ./$.cof */ 10)
	  , $iter           = __webpack_require__(/*! ./$.iter */ 42)
	  , SYMBOL_ITERATOR = __webpack_require__(/*! ./$.wks */ 11)('iterator')
	  , FF_ITERATOR     = '@@iterator'
	  , KEYS            = 'keys'
	  , VALUES          = 'values'
	  , Iterators       = $iter.Iterators;
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
	  $iter.create(Constructor, NAME, next);
	  function createMethod(kind){
	    function $$(that){
	      return new Constructor(that, kind);
	    }
	    switch(kind){
	      case KEYS: return function keys(){ return $$(this); };
	      case VALUES: return function values(){ return $$(this); };
	    } return function entries(){ return $$(this); };
	  }
	  var TAG      = NAME + ' Iterator'
	    , proto    = Base.prototype
	    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , _default = _native || createMethod(DEFAULT)
	    , methods, key;
	  // Fix native
	  if(_native){
	    var IteratorPrototype = $.getProto(_default.call(new Base));
	    // Set @@toStringTag to native iterators
	    cof.set(IteratorPrototype, TAG, true);
	    // FF fix
	    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);
	  }
	  // Define iterator
	  if($.FW)$iter.set(proto, _default);
	  // Plug for library
	  Iterators[NAME] = _default;
	  Iterators[TAG]  = $.that;
	  if(DEFAULT){
	    methods = {
	      keys:    IS_SET            ? _default : createMethod(KEYS),
	      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
	      entries: DEFAULT != VALUES ? _default : createMethod('entries')
	    };
	    if(FORCE)for(key in methods){
	      if(!(key in proto))$redef(proto, key, methods[key]);
	    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
	  }
	};

/***/ },
/* 44 */
/*!********************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.code-point-at.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 14)
	  , $at  = __webpack_require__(/*! ./$.string-at */ 41)(false);
	$def($def.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 45 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.ends-with.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $    = __webpack_require__(/*! ./$ */ 7)
	  , cof  = __webpack_require__(/*! ./$.cof */ 10)
	  , $def = __webpack_require__(/*! ./$.def */ 14)
	  , toLength = $.toLength;
	
	// should throw error on regex
	$def($def.P + $def.F * !__webpack_require__(/*! ./$.throws */ 22)(function(){ 'q'.endsWith(/./); }), 'String', {
	  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    if(cof(searchString) == 'RegExp')throw TypeError();
	    var that = String($.assertDefined(this))
	      , endPosition = arguments[1]
	      , len = toLength(that.length)
	      , end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    searchString += '';
	    return that.slice(end - searchString.length, end) === searchString;
	  }
	});

/***/ },
/* 46 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.includes.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $    = __webpack_require__(/*! ./$ */ 7)
	  , cof  = __webpack_require__(/*! ./$.cof */ 10)
	  , $def = __webpack_require__(/*! ./$.def */ 14);
	
	$def($def.P, 'String', {
	  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
	  includes: function includes(searchString /*, position = 0 */){
	    if(cof(searchString) == 'RegExp')throw TypeError();
	    return !!~String($.assertDefined(this)).indexOf(searchString, arguments[1]);
	  }
	});

/***/ },
/* 47 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.repeat.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def = __webpack_require__(/*! ./$.def */ 14);
	
	$def($def.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(/*! ./$.string-repeat */ 48)
	});

/***/ },
/* 48 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-repeat.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $ = __webpack_require__(/*! ./$ */ 7);
	
	module.exports = function repeat(count){
	  var str = String($.assertDefined(this))
	    , res = ''
	    , n   = $.toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 49 */
/*!******************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.string.starts-with.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $    = __webpack_require__(/*! ./$ */ 7)
	  , cof  = __webpack_require__(/*! ./$.cof */ 10)
	  , $def = __webpack_require__(/*! ./$.def */ 14);
	
	// should throw error on regex
	$def($def.P + $def.F * !__webpack_require__(/*! ./$.throws */ 22)(function(){ 'q'.startsWith(/./); }), 'String', {
	  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    if(cof(searchString) == 'RegExp')throw TypeError();
	    var that  = String($.assertDefined(this))
	      , index = $.toLength(Math.min(arguments[1], that.length));
	    searchString += '';
	    return that.slice(index, index + searchString.length) === searchString;
	  }
	});

/***/ },
/* 50 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.from.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $     = __webpack_require__(/*! ./$ */ 7)
	  , ctx   = __webpack_require__(/*! ./$.ctx */ 18)
	  , $def  = __webpack_require__(/*! ./$.def */ 14)
	  , $iter = __webpack_require__(/*! ./$.iter */ 42)
	  , call  = __webpack_require__(/*! ./$.iter-call */ 51);
	$def($def.S + $def.F * !__webpack_require__(/*! ./$.iter-detect */ 52)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = Object($.assertDefined(arrayLike))
	      , mapfn   = arguments[1]
	      , mapping = mapfn !== undefined
	      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
	      , index   = 0
	      , length, result, step, iterator;
	    if($iter.is(O)){
	      iterator = $iter.get(O);
	      // strange IE quirks mode bug -> use typeof instead of isFunction
	      result   = new (typeof this == 'function' ? this : Array);
	      for(; !(step = iterator.next()).done; index++){
	        result[index] = mapping ? call(iterator, f, [step.value, index], true) : step.value;
	      }
	    } else {
	      // strange IE quirks mode bug -> use typeof instead of isFunction
	      result = new (typeof this == 'function' ? this : Array)(length = $.toLength(O.length));
	      for(; length > index; index++){
	        result[index] = mapping ? f(O[index], index) : O[index];
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});

/***/ },
/* 51 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-call.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var assertObject = __webpack_require__(/*! ./$.assert */ 19).obj;
	function close(iterator){
	  var ret = iterator['return'];
	  if(ret !== undefined)assertObject(ret.call(iterator));
	}
	function call(iterator, fn, value, entries){
	  try {
	    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
	  } catch(e){
	    close(iterator);
	    throw e;
	  }
	}
	call.close = close;
	module.exports = call;

/***/ },
/* 52 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.iter-detect.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var SYMBOL_ITERATOR = __webpack_require__(/*! ./$.wks */ 11)('iterator')
	  , SAFE_CLOSING    = false;
	try {
	  var riter = [7][SYMBOL_ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	module.exports = function(exec){
	  if(!SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[SYMBOL_ITERATOR]();
	    iter.next = function(){ safe = true; };
	    arr[SYMBOL_ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 53 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.of.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def = __webpack_require__(/*! ./$.def */ 14);
	$def($def.S, 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , length = arguments.length
	      // strange IE quirks mode bug -> use typeof instead of isFunction
	      , result = new (typeof this == 'function' ? this : Array)(length);
	    while(length > index)result[index] = arguments[index++];
	    result.length = length;
	    return result;
	  }
	});

/***/ },
/* 54 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.iterator.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(/*! ./$ */ 7)
	  , setUnscope = __webpack_require__(/*! ./$.unscope */ 55)
	  , ITER       = __webpack_require__(/*! ./$.uid */ 13).safe('iter')
	  , $iter      = __webpack_require__(/*! ./$.iter */ 42)
	  , step       = $iter.step
	  , Iterators  = $iter.Iterators;
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	__webpack_require__(/*! ./$.iter-define */ 43)(Array, 'Array', function(iterated, kind){
	  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var iter  = this[ITER]
	    , O     = iter.o
	    , kind  = iter.k
	    , index = iter.i++;
	  if(!O || index >= O.length){
	    iter.o = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	setUnscope('keys');
	setUnscope('values');
	setUnscope('entries');

/***/ },
/* 55 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.unscope.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var $           = __webpack_require__(/*! ./$ */ 7)
	  , UNSCOPABLES = __webpack_require__(/*! ./$.wks */ 11)('unscopables');
	if($.FW && !(UNSCOPABLES in []))$.hide(Array.prototype, UNSCOPABLES, {});
	module.exports = function(key){
	  if($.FW)[][UNSCOPABLES][key] = true;
	};

/***/ },
/* 56 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.species.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./$.species */ 57)(Array);

/***/ },
/* 57 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.species.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $       = __webpack_require__(/*! ./$ */ 7)
	  , SPECIES = __webpack_require__(/*! ./$.wks */ 11)('species');
	module.exports = function(C){
	  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: $.that
	  });
	};

/***/ },
/* 58 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.copy-within.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $       = __webpack_require__(/*! ./$ */ 7)
	  , $def    = __webpack_require__(/*! ./$.def */ 14)
	  , toIndex = $.toIndex;
	$def($def.P, 'Array', {
	  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
	    var O     = Object($.assertDefined(this))
	      , len   = $.toLength(O.length)
	      , to    = toIndex(target, len)
	      , from  = toIndex(start, len)
	      , end   = arguments[2]
	      , fin   = end === undefined ? len : toIndex(end, len)
	      , count = Math.min(fin - from, len - to)
	      , inc   = 1;
	    if(from < to && to < from + count){
	      inc  = -1;
	      from = from + count - 1;
	      to   = to   + count - 1;
	    }
	    while(count-- > 0){
	      if(from in O)O[to] = O[from];
	      else delete O[to];
	      to   += inc;
	      from += inc;
	    } return O;
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 55)('copyWithin');

/***/ },
/* 59 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.fill.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $       = __webpack_require__(/*! ./$ */ 7)
	  , $def    = __webpack_require__(/*! ./$.def */ 14)
	  , toIndex = $.toIndex;
	$def($def.P, 'Array', {
	  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	  fill: function fill(value /*, start = 0, end = @length */){
	    var O      = Object($.assertDefined(this))
	      , length = $.toLength(O.length)
	      , index  = toIndex(arguments[1], length)
	      , end    = arguments[2]
	      , endPos = end === undefined ? length : toIndex(end, length);
	    while(endPos > index)O[index++] = value;
	    return O;
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 55)('fill');

/***/ },
/* 60 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.find.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var KEY    = 'find'
	  , $def   = __webpack_require__(/*! ./$.def */ 14)
	  , forced = true
	  , $find  = __webpack_require__(/*! ./$.array-methods */ 17)(5);
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$def($def.P + $def.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments[1]);
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 55)(KEY);

/***/ },
/* 61 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.array.find-index.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var KEY    = 'findIndex'
	  , $def   = __webpack_require__(/*! ./$.def */ 14)
	  , forced = true
	  , $find  = __webpack_require__(/*! ./$.array-methods */ 17)(6);
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$def($def.P + $def.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments[1]);
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 55)(KEY);

/***/ },
/* 62 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.regexp.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $       = __webpack_require__(/*! ./$ */ 7)
	  , cof     = __webpack_require__(/*! ./$.cof */ 10)
	  , $RegExp = $.g.RegExp
	  , Base    = $RegExp
	  , proto   = $RegExp.prototype
	  , re      = /a/g
	  // "new" creates a new object
	  , CORRECT_NEW = new $RegExp(re) !== re
	  // RegExp allows a regex with flags as the pattern
	  , ALLOWS_RE_WITH_FLAGS = function(){
	    try {
	      return $RegExp(re, 'i') == '/a/i';
	    } catch(e){ /* empty */ }
	  }();
	if($.FW && $.DESC){
	  if(!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS){
	    $RegExp = function RegExp(pattern, flags){
	      var patternIsRegExp  = cof(pattern) == 'RegExp'
	        , flagsIsUndefined = flags === undefined;
	      if(!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)return pattern;
	      return CORRECT_NEW
	        ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags)
	        : new Base(patternIsRegExp ? pattern.source : pattern
	          , patternIsRegExp && flagsIsUndefined ? pattern.flags : flags);
	    };
	    $.each.call($.getNames(Base), function(key){
	      key in $RegExp || $.setDesc($RegExp, key, {
	        configurable: true,
	        get: function(){ return Base[key]; },
	        set: function(it){ Base[key] = it; }
	      });
	    });
	    proto.constructor = $RegExp;
	    $RegExp.prototype = proto;
	    __webpack_require__(/*! ./$.redef */ 15)($.g, 'RegExp', $RegExp);
	  }
	  // 21.2.5.3 get RegExp.prototype.flags()
	  if(/./g.flags != 'g')$.setDesc(proto, 'flags', {
	    configurable: true,
	    get: __webpack_require__(/*! ./$.replacer */ 21)(/^.*\/(\w*)$/, '$1')
	  });
	}
	__webpack_require__(/*! ./$.species */ 57)($RegExp);

/***/ },
/* 63 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.promise.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , ctx      = __webpack_require__(/*! ./$.ctx */ 18)
	  , cof      = __webpack_require__(/*! ./$.cof */ 10)
	  , $def     = __webpack_require__(/*! ./$.def */ 14)
	  , assert   = __webpack_require__(/*! ./$.assert */ 19)
	  , forOf    = __webpack_require__(/*! ./$.for-of */ 64)
	  , setProto = __webpack_require__(/*! ./$.set-proto */ 30).set
	  , species  = __webpack_require__(/*! ./$.species */ 57)
	  , SPECIES  = __webpack_require__(/*! ./$.wks */ 11)('species')
	  , RECORD   = __webpack_require__(/*! ./$.uid */ 13).safe('record')
	  , PROMISE  = 'Promise'
	  , global   = $.g
	  , process  = global.process
	  , asap     = process && process.nextTick || __webpack_require__(/*! ./$.task */ 65).set
	  , P        = global[PROMISE]
	  , isFunction     = $.isFunction
	  , isObject       = $.isObject
	  , assertFunction = assert.fn
	  , assertObject   = assert.obj;
	
	var useNative = function(){
	  var test, works = false;
	  function P2(x){
	    var self = new P(x);
	    setProto(self, P2.prototype);
	    return self;
	  }
	  try {
	    works = isFunction(P) && isFunction(P.resolve) && P.resolve(test = new P(function(){})) == test;
	    setProto(P2, P);
	    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
	    // actual Firefox has broken subclass support, test that
	    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
	      works = false;
	    }
	  } catch(e){ works = false; }
	  return works;
	}();
	
	// helpers
	function getConstructor(C){
	  var S = assertObject(C)[SPECIES];
	  return S != undefined ? S : C;
	}
	function isThenable(it){
	  var then;
	  if(isObject(it))then = it.then;
	  return isFunction(then) ? then : false;
	}
	function notify(record){
	  var chain = record.c;
	  if(chain.length)asap(function(){
	    var value = record.v
	      , ok    = record.s == 1
	      , i     = 0;
	    function run(react){
	      var cb = ok ? react.ok : react.fail
	        , ret, then;
	      try {
	        if(cb){
	          if(!ok)record.h = true;
	          ret = cb === true ? value : cb(value);
	          if(ret === react.P){
	            react.rej(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(ret)){
	            then.call(ret, react.res, react.rej);
	          } else react.res(ret);
	        } else react.rej(value);
	      } catch(err){
	        react.rej(err);
	      }
	    }
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    chain.length = 0;
	  });
	}
	function isUnhandled(promise){
	  var record = promise[RECORD]
	    , chain  = record.a || record.c
	    , i      = 0
	    , react;
	  if(record.h)return false;
	  while(chain.length > i){
	    react = chain[i++];
	    if(react.fail || !isUnhandled(react.P))return false;
	  } return true;
	}
	function $reject(value){
	  var record = this
	    , promise;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  record.v = value;
	  record.s = 2;
	  record.a = record.c.slice();
	  setTimeout(function(){
	    asap(function(){
	      if(isUnhandled(promise = record.p)){
	        if(cof(process) == 'process'){
	          process.emit('unhandledRejection', value, promise);
	        } else if(global.console && isFunction(console.error)){
	          console.error('Unhandled promise rejection', value);
	        }
	      }
	      record.a = undefined;
	    });
	  }, 1);
	  notify(record);
	}
	function $resolve(value){
	  var record = this
	    , then, wrapper;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  try {
	    if(then = isThenable(value)){
	      wrapper = {r: record, d: false}; // wrap
	      then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	    } else {
	      record.v = value;
	      record.s = 1;
	      notify(record);
	    }
	  } catch(err){
	    $reject.call(wrapper || {r: record, d: false}, err); // wrap
	  }
	}
	
	// constructor polyfill
	if(!useNative){
	  // 25.4.3.1 Promise(executor)
	  P = function Promise(executor){
	    assertFunction(executor);
	    var record = {
	      p: assert.inst(this, P, PROMISE),       // <- promise
	      c: [],                                  // <- awaiting reactions
	      a: undefined,                           // <- checked in isUnhandled reactions
	      s: 0,                                   // <- state
	      d: false,                               // <- done
	      v: undefined,                           // <- value
	      h: false                                // <- handled rejection
	    };
	    $.hide(this, RECORD, record);
	    try {
	      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
	    } catch(err){
	      $reject.call(record, err);
	    }
	  };
	  __webpack_require__(/*! ./$.mix */ 66)(P.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var S = assertObject(assertObject(this).constructor)[SPECIES];
	      var react = {
	        ok:   isFunction(onFulfilled) ? onFulfilled : true,
	        fail: isFunction(onRejected)  ? onRejected  : false
	      };
	      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
	        react.res = assertFunction(res);
	        react.rej = assertFunction(rej);
	      });
	      var record = this[RECORD];
	      record.c.push(react);
	      if(record.a)record.a.push(react);
	      record.s && notify(record);
	      return promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	}
	
	// export
	$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
	cof.set(P, PROMISE);
	species(P);
	species($.core[PROMISE]); // for wrapper
	
	// statics
	$def($def.S + $def.F * !useNative, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    return new (getConstructor(this))(function(res, rej){
	      rej(r);
	    });
	  },
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    return isObject(x) && RECORD in x && $.getProto(x) === this.prototype
	      ? x : new (getConstructor(this))(function(res){
	        res(x);
	      });
	  }
	});
	$def($def.S + $def.F * !(useNative && __webpack_require__(/*! ./$.iter-detect */ 52)(function(iter){
	  P.all(iter)['catch'](function(){});
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C      = getConstructor(this)
	      , values = [];
	    return new C(function(res, rej){
	      forOf(iterable, false, values.push, values);
	      var remaining = values.length
	        , results   = Array(remaining);
	      if(remaining)$.each.call(values, function(promise, index){
	        C.resolve(promise).then(function(value){
	          results[index] = value;
	          --remaining || res(results);
	        }, rej);
	      });
	      else res(results);
	    });
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C = getConstructor(this);
	    return new C(function(res, rej){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(res, rej);
	      });
	    });
	  }
	});

/***/ },
/* 64 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.for-of.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx  = __webpack_require__(/*! ./$.ctx */ 18)
	  , get  = __webpack_require__(/*! ./$.iter */ 42).get
	  , call = __webpack_require__(/*! ./$.iter-call */ 51);
	module.exports = function(iterable, entries, fn, that){
	  var iterator = get(iterable)
	    , f        = ctx(fn, that, entries ? 2 : 1)
	    , step;
	  while(!(step = iterator.next()).done){
	    if(call(iterator, f, step.value, entries) === false){
	      return call.close(iterator);
	    }
	  }
	};

/***/ },
/* 65 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.task.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $      = __webpack_require__(/*! ./$ */ 7)
	  , ctx    = __webpack_require__(/*! ./$.ctx */ 18)
	  , cof    = __webpack_require__(/*! ./$.cof */ 10)
	  , invoke = __webpack_require__(/*! ./$.invoke */ 16)
	  , cel    = __webpack_require__(/*! ./$.dom-create */ 9)
	  , global             = $.g
	  , isFunction         = $.isFunction
	  , html               = $.html
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , postMessage        = global.postMessage
	  , addEventListener   = global.addEventListener
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	function run(){
	  var id = +this;
	  if($.has(queue, id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	}
	function listner(event){
	  run.call(event.data);
	}
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!isFunction(setTask) || !isFunction(clearTask)){
	  setTask = function(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(isFunction(fn) ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(cof(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Modern browsers, skip implementation for WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is object
	  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
	    defer = function(id){
	      postMessage(id, '*');
	    };
	    addEventListener('message', listner, false);
	  // WebWorkers
	  } else if(isFunction(MessageChannel)){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listner;
	    defer = ctx(port.postMessage, port, 1);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 66 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.mix.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $redef = __webpack_require__(/*! ./$.redef */ 15);
	module.exports = function(target, src){
	  for(var key in src)$redef(target, key, src[key]);
	  return target;
	};

/***/ },
/* 67 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.map.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./$.collection-strong */ 68);
	
	// 23.1 Map Objects
	__webpack_require__(/*! ./$.collection */ 69)('Map', {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 68 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection-strong.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $        = __webpack_require__(/*! ./$ */ 7)
	  , ctx      = __webpack_require__(/*! ./$.ctx */ 18)
	  , safe     = __webpack_require__(/*! ./$.uid */ 13).safe
	  , assert   = __webpack_require__(/*! ./$.assert */ 19)
	  , forOf    = __webpack_require__(/*! ./$.for-of */ 64)
	  , step     = __webpack_require__(/*! ./$.iter */ 42).step
	  , has      = $.has
	  , set      = $.set
	  , isObject = $.isObject
	  , hide     = $.hide
	  , isExtensible = Object.isExtensible || isObject
	  , ID       = safe('id')
	  , O1       = safe('O1')
	  , LAST     = safe('last')
	  , FIRST    = safe('first')
	  , ITER     = safe('iter')
	  , SIZE     = $.DESC ? safe('size') : 'size'
	  , id       = 0;
	
	function fastKey(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	}
	
	function getEntry(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that[O1][index];
	  // frozen object case
	  for(entry = that[FIRST]; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	}
	
	module.exports = {
	  getConstructor: function(NAME, IS_MAP, ADDER){
	    function C(){
	      var that     = assert.inst(this, C, NAME)
	        , iterable = arguments[0];
	      set(that, O1, $.create(null));
	      set(that, SIZE, 0);
	      set(that, LAST, undefined);
	      set(that, FIRST, undefined);
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    }
	    __webpack_require__(/*! ./$.mix */ 66)(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that[FIRST] = that[LAST] = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that[O1][entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that[FIRST] == entry)that[FIRST] = next;
	          if(that[LAST] == entry)that[LAST] = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments[1], 3)
	          , entry;
	        while(entry = entry ? entry.n : this[FIRST]){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if($.DESC)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return assert.def(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that[LAST] = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that[LAST],          // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that[FIRST])that[FIRST] = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that[O1][index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  // add .keys, .values, .entries, [@@iterator]
	  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	  setIter: function(C, NAME, IS_MAP){
	    __webpack_require__(/*! ./$.iter-define */ 43)(C, NAME, function(iterated, kind){
	      set(this, ITER, {o: iterated, k: kind});
	    }, function(){
	      var iter  = this[ITER]
	        , kind  = iter.k
	        , entry = iter.l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
	        // or finish the iteration
	        iter.o = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	  }
	};

/***/ },
/* 69 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $     = __webpack_require__(/*! ./$ */ 7)
	  , $def  = __webpack_require__(/*! ./$.def */ 14)
	  , BUGGY = __webpack_require__(/*! ./$.iter */ 42).BUGGY
	  , forOf = __webpack_require__(/*! ./$.for-of */ 64)
	  , species = __webpack_require__(/*! ./$.species */ 57)
	  , assertInstance = __webpack_require__(/*! ./$.assert */ 19).inst;
	
	module.exports = function(NAME, methods, common, IS_MAP, IS_WEAK){
	  var Base  = $.g[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  function fixMethod(KEY, CHAIN){
	    if($.FW){
	      var method = proto[KEY];
	      __webpack_require__(/*! ./$.redef */ 15)(proto, KEY, function(a, b){
	        var result = method.call(this, a === 0 ? 0 : a, b);
	        return CHAIN ? this : result;
	      });
	    }
	  }
	  if(!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)){
	    // create collection constructor
	    C = common.getConstructor(NAME, IS_MAP, ADDER);
	    __webpack_require__(/*! ./$.mix */ 66)(C.prototype, methods);
	  } else {
	    var inst  = new C
	      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
	      , buggyZero;
	    // wrap for init collections from iterable
	    if(!__webpack_require__(/*! ./$.iter-detect */ 52)(function(iter){ new C(iter); })){ // eslint-disable-line no-new
	      C = function(){
	        assertInstance(this, C, NAME);
	        var that     = new Base
	          , iterable = arguments[0];
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      };
	      C.prototype = proto;
	      if($.FW)proto.constructor = C;
	    }
	    IS_WEAK || inst.forEach(function(val, key){
	      buggyZero = 1 / key === -Infinity;
	    });
	    // fix converting -0 key to +0
	    if(buggyZero){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    // + fix .add & .set for chaining
	    if(buggyZero || chain !== inst)fixMethod(ADDER, true);
	  }
	
	  __webpack_require__(/*! ./$.cof */ 10).set(C, NAME);
	
	  O[NAME] = C;
	  $def($def.G + $def.W + $def.F * (C != Base), O);
	  species(C);
	  species($.core[NAME]); // for wrapper
	
	  if(!IS_WEAK)common.setIter(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 70 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.set.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./$.collection-strong */ 68);
	
	// 23.2 Set Objects
	__webpack_require__(/*! ./$.collection */ 69)('Set', {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 71 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.weak-map.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $         = __webpack_require__(/*! ./$ */ 7)
	  , weak      = __webpack_require__(/*! ./$.collection-weak */ 72)
	  , leakStore = weak.leakStore
	  , ID        = weak.ID
	  , WEAK      = weak.WEAK
	  , has       = $.has
	  , isObject  = $.isObject
	  , isExtensible = Object.isExtensible || isObject
	  , tmp       = {};
	
	// 23.3 WeakMap Objects
	var WeakMap = __webpack_require__(/*! ./$.collection */ 69)('WeakMap', {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      if(!isExtensible(key))return leakStore(this).get(key);
	      if(has(key, WEAK))return key[WEAK][this[ID]];
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	}, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if($.FW && new WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  $.each.call(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = WeakMap.prototype
	      , method = proto[key];
	    __webpack_require__(/*! ./$.redef */ 15)(proto, key, function(a, b){
	      // store frozen objects on leaky map
	      if(isObject(a) && !isExtensible(a)){
	        var result = leakStore(this)[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 72 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection-weak.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $         = __webpack_require__(/*! ./$ */ 7)
	  , safe      = __webpack_require__(/*! ./$.uid */ 13).safe
	  , assert    = __webpack_require__(/*! ./$.assert */ 19)
	  , forOf     = __webpack_require__(/*! ./$.for-of */ 64)
	  , _has      = $.has
	  , isObject  = $.isObject
	  , hide      = $.hide
	  , isExtensible = Object.isExtensible || isObject
	  , id        = 0
	  , ID        = safe('id')
	  , WEAK      = safe('weak')
	  , LEAK      = safe('leak')
	  , method    = __webpack_require__(/*! ./$.array-methods */ 17)
	  , find      = method(5)
	  , findIndex = method(6);
	function findFrozen(store, key){
	  return find(store.array, function(it){
	    return it[0] === key;
	  });
	}
	// fallback for frozen keys
	function leakStore(that){
	  return that[LEAK] || hide(that, LEAK, {
	    array: [],
	    get: function(key){
	      var entry = findFrozen(this, key);
	      if(entry)return entry[1];
	    },
	    has: function(key){
	      return !!findFrozen(this, key);
	    },
	    set: function(key, value){
	      var entry = findFrozen(this, key);
	      if(entry)entry[1] = value;
	      else this.array.push([key, value]);
	    },
	    'delete': function(key){
	      var index = findIndex(this.array, function(it){
	        return it[0] === key;
	      });
	      if(~index)this.array.splice(index, 1);
	      return !!~index;
	    }
	  })[LEAK];
	}
	
	module.exports = {
	  getConstructor: function(NAME, IS_MAP, ADDER){
	    function C(){
	      $.set(assert.inst(this, C, NAME), ID, id++);
	      var iterable = arguments[0];
	      if(iterable != undefined)forOf(iterable, IS_MAP, this[ADDER], this);
	    }
	    __webpack_require__(/*! ./$.mix */ 66)(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return leakStore(this)['delete'](key);
	        return _has(key, WEAK) && _has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return leakStore(this).has(key);
	        return _has(key, WEAK) && _has(key[WEAK], this[ID]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    if(!isExtensible(assert.obj(key))){
	      leakStore(that).set(key, value);
	    } else {
	      _has(key, WEAK) || hide(key, WEAK, {});
	      key[WEAK][that[ID]] = value;
	    } return that;
	  },
	  leakStore: leakStore,
	  WEAK: WEAK,
	  ID: ID
	};

/***/ },
/* 73 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.weak-set.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(/*! ./$.collection-weak */ 72);
	
	// 23.4 WeakSet Objects
	__webpack_require__(/*! ./$.collection */ 69)('WeakSet', {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 74 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es6.reflect.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(/*! ./$ */ 7)
	  , $def      = __webpack_require__(/*! ./$.def */ 14)
	  , setProto  = __webpack_require__(/*! ./$.set-proto */ 30)
	  , $iter     = __webpack_require__(/*! ./$.iter */ 42)
	  , ITERATOR  = __webpack_require__(/*! ./$.wks */ 11)('iterator')
	  , ITER      = __webpack_require__(/*! ./$.uid */ 13).safe('iter')
	  , step      = $iter.step
	  , assert    = __webpack_require__(/*! ./$.assert */ 19)
	  , isObject  = $.isObject
	  , getProto  = $.getProto
	  , $Reflect  = $.g.Reflect
	  , _apply    = Function.apply
	  , assertObject = assert.obj
	  , _isExtensible = Object.isExtensible || isObject
	  , _preventExtensions = Object.preventExtensions
	  // IE TP has broken Reflect.enumerate
	  , buggyEnumerate = !($Reflect && $Reflect.enumerate && ITERATOR in $Reflect.enumerate({}));
	
	function Enumerate(iterated){
	  $.set(this, ITER, {o: iterated, k: undefined, i: 0});
	}
	$iter.create(Enumerate, 'Object', function(){
	  var iter = this[ITER]
	    , keys = iter.k
	    , key;
	  if(keys == undefined){
	    iter.k = keys = [];
	    for(key in iter.o)keys.push(key);
	  }
	  do {
	    if(iter.i >= keys.length)return step(1);
	  } while(!((key = keys[iter.i++]) in iter.o));
	  return step(0, key);
	});
	
	var reflect = {
	  // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	  apply: function apply(target, thisArgument, argumentsList){
	    return _apply.call(target, thisArgument, argumentsList);
	  },
	  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	  construct: function construct(target, argumentsList /*, newTarget*/){
	    var proto    = assert.fn(arguments.length < 3 ? target : arguments[2]).prototype
	      , instance = $.create(isObject(proto) ? proto : Object.prototype)
	      , result   = _apply.call(target, instance, argumentsList);
	    return isObject(result) ? result : instance;
	  },
	  // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    assertObject(target);
	    try {
	      $.setDesc(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  },
	  // 26.1.4 Reflect.deleteProperty(target, propertyKey)
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = $.getDesc(assertObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  },
	  // 26.1.6 Reflect.get(target, propertyKey [, receiver])
	  get: function get(target, propertyKey/*, receiver*/){
	    var receiver = arguments.length < 3 ? target : arguments[2]
	      , desc = $.getDesc(assertObject(target), propertyKey), proto;
	    if(desc)return $.has(desc, 'value')
	      ? desc.value
	      : desc.get === undefined
	        ? undefined
	        : desc.get.call(receiver);
	    return isObject(proto = getProto(target))
	      ? get(proto, propertyKey, receiver)
	      : undefined;
	  },
	  // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return $.getDesc(assertObject(target), propertyKey);
	  },
	  // 26.1.8 Reflect.getPrototypeOf(target)
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(assertObject(target));
	  },
	  // 26.1.9 Reflect.has(target, propertyKey)
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  },
	  // 26.1.10 Reflect.isExtensible(target)
	  isExtensible: function isExtensible(target){
	    return _isExtensible(assertObject(target));
	  },
	  // 26.1.11 Reflect.ownKeys(target)
	  ownKeys: __webpack_require__(/*! ./$.own-keys */ 75),
	  // 26.1.12 Reflect.preventExtensions(target)
	  preventExtensions: function preventExtensions(target){
	    assertObject(target);
	    try {
	      if(_preventExtensions)_preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  },
	  // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	  set: function set(target, propertyKey, V/*, receiver*/){
	    var receiver = arguments.length < 4 ? target : arguments[3]
	      , ownDesc  = $.getDesc(assertObject(target), propertyKey)
	      , existingDescriptor, proto;
	    if(!ownDesc){
	      if(isObject(proto = getProto(target))){
	        return set(proto, propertyKey, V, receiver);
	      }
	      ownDesc = $.desc(0);
	    }
	    if($.has(ownDesc, 'value')){
	      if(ownDesc.writable === false || !isObject(receiver))return false;
	      existingDescriptor = $.getDesc(receiver, propertyKey) || $.desc(0);
	      existingDescriptor.value = V;
	      $.setDesc(receiver, propertyKey, existingDescriptor);
	      return true;
	    }
	    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	  }
	};
	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	if(setProto)reflect.setPrototypeOf = function setPrototypeOf(target, proto){
	  setProto.check(target, proto);
	  try {
	    setProto.set(target, proto);
	    return true;
	  } catch(e){
	    return false;
	  }
	};
	
	$def($def.G, {Reflect: {}});
	
	$def($def.S + $def.F * buggyEnumerate, 'Reflect', {
	  // 26.1.5 Reflect.enumerate(target)
	  enumerate: function enumerate(target){
	    return new Enumerate(assertObject(target));
	  }
	});
	
	$def($def.S, 'Reflect', reflect);

/***/ },
/* 75 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.own-keys.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $            = __webpack_require__(/*! ./$ */ 7)
	  , assertObject = __webpack_require__(/*! ./$.assert */ 19).obj;
	module.exports = function ownKeys(it){
	  assertObject(it);
	  var keys       = $.getNames(it)
	    , getSymbols = $.getSymbols;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 76 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.array.includes.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/domenic/Array.prototype.includes
	var $def      = __webpack_require__(/*! ./$.def */ 14)
	  , $includes = __webpack_require__(/*! ./$.array-includes */ 20)(true);
	$def($def.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments[1]);
	  }
	});
	__webpack_require__(/*! ./$.unscope */ 55)('includes');

/***/ },
/* 77 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.at.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/mathiasbynens/String.prototype.at
	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 14)
	  , $at  = __webpack_require__(/*! ./$.string-at */ 41)(true);
	$def($def.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 78 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.lpad.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 14)
	  , $pad = __webpack_require__(/*! ./$.string-pad */ 79);
	$def($def.P, 'String', {
	  lpad: function lpad(n){
	    return $pad(this, n, arguments[1], true);
	  }
	});

/***/ },
/* 79 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.string-pad.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.ecmascript.org/doku.php?id=strawman:string_padding
	var $      = __webpack_require__(/*! ./$ */ 7)
	  , repeat = __webpack_require__(/*! ./$.string-repeat */ 48);
	
	module.exports = function(that, minLength, fillChar, left){
	  // 1. Let O be CheckObjectCoercible(this value).
	  // 2. Let S be ToString(O).
	  var S = String($.assertDefined(that));
	  // 4. If intMinLength is undefined, return S.
	  if(minLength === undefined)return S;
	  // 4. Let intMinLength be ToInteger(minLength).
	  var intMinLength = $.toInteger(minLength);
	  // 5. Let fillLen be the number of characters in S minus intMinLength.
	  var fillLen = intMinLength - S.length;
	  // 6. If fillLen < 0, then throw a RangeError exception.
	  // 7. If fillLen is +∞, then throw a RangeError exception.
	  if(fillLen < 0 || fillLen === Infinity){
	    throw new RangeError('Cannot satisfy string length ' + minLength + ' for string: ' + S);
	  }
	  // 8. Let sFillStr be the string represented by fillStr.
	  // 9. If sFillStr is undefined, let sFillStr be a space character.
	  var sFillStr = fillChar === undefined ? ' ' : String(fillChar);
	  // 10. Let sFillVal be a String made of sFillStr, repeated until fillLen is met.
	  var sFillVal = repeat.call(sFillStr, Math.ceil(fillLen / sFillStr.length));
	  // truncate if we overflowed
	  if(sFillVal.length > fillLen)sFillVal = left
	    ? sFillVal.slice(sFillVal.length - fillLen)
	    : sFillVal.slice(0, fillLen);
	  // 11. Return a string made from sFillVal, followed by S.
	  // 11. Return a String made from S, followed by sFillVal.
	  return left ? sFillVal.concat(S) : S.concat(sFillVal);
	};

/***/ },
/* 80 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.string.rpad.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $def = __webpack_require__(/*! ./$.def */ 14)
	  , $pad = __webpack_require__(/*! ./$.string-pad */ 79);
	$def($def.P, 'String', {
	  rpad: function rpad(n){
	    return $pad(this, n, arguments[1], false);
	  }
	});

/***/ },
/* 81 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.regexp.escape.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/kangax/9698100
	var $def = __webpack_require__(/*! ./$.def */ 14);
	$def($def.S, 'RegExp', {
	  escape: __webpack_require__(/*! ./$.replacer */ 21)(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
	});

/***/ },
/* 82 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/WebReflection/9353781
	var $       = __webpack_require__(/*! ./$ */ 7)
	  , $def    = __webpack_require__(/*! ./$.def */ 14)
	  , ownKeys = __webpack_require__(/*! ./$.own-keys */ 75);
	
	$def($def.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O      = $.toObject(object)
	      , result = {};
	    $.each.call(ownKeys(O), function(key){
	      $.setDesc(result, key, $.desc(0, $.getDesc(O, key)));
	    });
	    return result;
	  }
	});

/***/ },
/* 83 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.object.to-array.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// http://goo.gl/XkBrjD
	var $    = __webpack_require__(/*! ./$ */ 7)
	  , $def = __webpack_require__(/*! ./$.def */ 14);
	function createObjectToArray(isEntries){
	  return function(object){
	    var O      = $.toObject(object)
	      , keys   = $.getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = Array(length)
	      , key;
	    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
	    else while(length > i)result[i] = O[keys[i++]];
	    return result;
	  };
	}
	$def($def.S, 'Object', {
	  values:  createObjectToArray(false),
	  entries: createObjectToArray(true)
	});

/***/ },
/* 84 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.map.to-json.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	__webpack_require__(/*! ./$.collection-to-json */ 85)('Map');

/***/ },
/* 85 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.collection-to-json.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $def  = __webpack_require__(/*! ./$.def */ 14)
	  , forOf = __webpack_require__(/*! ./$.for-of */ 64);
	module.exports = function(NAME){
	  $def($def.P, NAME, {
	    toJSON: function toJSON(){
	      var arr = [];
	      forOf(this, false, arr.push, arr);
	      return arr;
	    }
	  });
	};

/***/ },
/* 86 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/es7.set.to-json.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	__webpack_require__(/*! ./$.collection-to-json */ 85)('Set');

/***/ },
/* 87 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/js.array.statics.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// JavaScript 1.6 / Strawman array statics shim
	var $       = __webpack_require__(/*! ./$ */ 7)
	  , $def    = __webpack_require__(/*! ./$.def */ 14)
	  , $Array  = $.core.Array || Array
	  , statics = {};
	function setStatics(keys, length){
	  $.each.call(keys.split(','), function(key){
	    if(length == undefined && key in $Array)statics[key] = $Array[key];
	    else if(key in [])statics[key] = __webpack_require__(/*! ./$.ctx */ 18)(Function.call, [][key], length);
	  });
	}
	setStatics('pop,reverse,shift,keys,values,entries', 1);
	setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
	setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
	           'reduce,reduceRight,copyWithin,fill,turn');
	$def($def.S, 'Array', statics);

/***/ },
/* 88 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/web.timers.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var $         = __webpack_require__(/*! ./$ */ 7)
	  , $def      = __webpack_require__(/*! ./$.def */ 14)
	  , invoke    = __webpack_require__(/*! ./$.invoke */ 16)
	  , partial   = __webpack_require__(/*! ./$.partial */ 89)
	  , navigator = $.g.navigator
	  , MSIE      = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	function wrap(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      $.isFunction(fn) ? fn : Function(fn)
	    ), time);
	  } : set;
	}
	$def($def.G + $def.B + $def.F * MSIE, {
	  setTimeout:  wrap($.g.setTimeout),
	  setInterval: wrap($.g.setInterval)
	});

/***/ },
/* 89 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/$.partial.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $      = __webpack_require__(/*! ./$ */ 7)
	  , invoke = __webpack_require__(/*! ./$.invoke */ 16)
	  , assertFunction = __webpack_require__(/*! ./$.assert */ 19).fn;
	module.exports = function(/* ...pargs */){
	  var fn     = assertFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = $.path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that    = this
	      , _length = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !_length)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(_length > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 90 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/web.immediate.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $def  = __webpack_require__(/*! ./$.def */ 14)
	  , $task = __webpack_require__(/*! ./$.task */ 65);
	$def($def.G + $def.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 91 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/core-js/modules/web.dom.iterable.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./es6.array.iterator */ 54);
	var $           = __webpack_require__(/*! ./$ */ 7)
	  , Iterators   = __webpack_require__(/*! ./$.iter */ 42).Iterators
	  , ITERATOR    = __webpack_require__(/*! ./$.wks */ 11)('iterator')
	  , ArrayValues = Iterators.Array
	  , NL          = $.g.NodeList
	  , HTC         = $.g.HTMLCollection
	  , NLProto     = NL && NL.prototype
	  , HTCProto    = HTC && HTC.prototype;
	if($.FW){
	  if(NL && !(ITERATOR in NLProto))$.hide(NLProto, ITERATOR, ArrayValues);
	  if(HTC && !(ITERATOR in HTCProto))$.hide(HTCProto, ITERATOR, ArrayValues);
	}
	Iterators.NodeList = Iterators.HTMLCollection = ArrayValues;

/***/ },
/* 92 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/regenerator/runtime.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	
	    generator._invoke = makeInvokeMethod(
	      innerFn, self || null,
	      new Context(tryLocsList || [])
	    );
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    genFun.__proto__ = GeneratorFunctionPrototype;
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    return new Promise(function(resolve, reject) {
	      var generator = wrap(innerFn, outerFn, self, tryLocsList);
	
	      var step = function(method, arg) {
	        var record = tryCatch(generator[method], generator, arg);
	        if (record.type === "throw") {
	          reject(record.arg);
	          return;
	        }
	
	        var info = record.arg;
	        if (info.done) {
	          resolve(info.value);
	        } else {
	          Promise.resolve(info.value).then(callNext, callThrow);
	        }
	      };
	
	      if (typeof process !== "undefined" && process.domain) {
	        step = process.domain.bind(step);
	      }
	
	      var callNext = step.bind(generator, "next");
	      var callThrow = step.bind(generator, "throw");
	
	      callNext();
	    });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            delete context.sent;
	          }
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  function defineGeneratorMethod(method) {
	    Gp[method] = function(arg) {
	      return this._invoke(method, arg);
	    };
	  }
	  defineGeneratorMethod("next");
	  defineGeneratorMethod("throw");
	  defineGeneratorMethod("return");
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset();
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function() {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      // Pre-initialize at least 20 temporary variables to enable hidden
	      // class optimizations for simple generators.
	      for (var tempIndex = 0, tempName;
	           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
	           ++tempIndex) {
	        this[tempName] = null;
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);


/***/ },
/* 93 */
/*!*****************************************************!*\
  !*** ./~/babel-core/lib/babel/api/register/node.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _sourceMapSupport = __webpack_require__(/*! source-map-support */ 94);
	
	var _sourceMapSupport2 = _interopRequireDefault(_sourceMapSupport);
	
	var _cache = __webpack_require__(/*! ./cache */ 95);
	
	var registerCache = _interopRequireWildcard(_cache);
	
	var _toolsResolveRc = __webpack_require__(/*! ../../tools/resolve-rc */ 100);
	
	var _toolsResolveRc2 = _interopRequireDefault(_toolsResolveRc);
	
	var _lodashObjectExtend = __webpack_require__(/*! lodash/object/extend */ 138);
	
	var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
	
	var _node = __webpack_require__(/*! ../node */ 142);
	
	var babel = _interopRequireWildcard(_node);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _fs = __webpack_require__(/*! fs */ 98);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _slash = __webpack_require__(/*! slash */ 265);
	
	var _slash2 = _interopRequireDefault(_slash);
	
	_sourceMapSupport2["default"].install({
	  handleUncaughtExceptions: false,
	  retrieveSourceMap: function retrieveSourceMap(source) {
	    var map = maps && maps[source];
	    if (map) {
	      return {
	        url: null,
	        map: map
	      };
	    } else {
	      return null;
	    }
	  }
	});
	
	//
	
	registerCache.load();
	var cache = registerCache.get();
	
	//
	
	var transformOpts = {};
	
	var ignore;
	var only;
	
	var oldHandlers = {};
	var maps = {};
	
	var mtime = function mtime(filename) {
	  return +_fs2["default"].statSync(filename).mtime;
	};
	
	var compile = function compile(filename) {
	  var result;
	
	  var opts = (0, _lodashObjectExtend2["default"])({}, transformOpts);
	
	  // this will be done when the file is transformed anyway but we need all
	  // the options so we can generate the cache key
	  (0, _toolsResolveRc2["default"])(filename, opts);
	
	  var cacheKey = "" + filename + ":" + JSON.stringify(opts) + ":" + babel.version;
	
	  var env = process.env.BABEL_ENV || process.env.NODE_ENV;
	  if (env) cacheKey += ":" + env;
	
	  if (cache) {
	    var cached = cache[cacheKey];
	    if (cached && cached.mtime === mtime(filename)) {
	      result = cached;
	    }
	  }
	
	  if (!result) {
	    result = babel.transformFileSync(filename, (0, _lodashObjectExtend2["default"])(opts, {
	      sourceMap: "both",
	      ast: false
	    }));
	  }
	
	  if (cache) {
	    result.mtime = mtime(filename);
	    cache[cacheKey] = result;
	  }
	
	  maps[filename] = result.map;
	
	  return result.code;
	};
	
	var shouldIgnore = function shouldIgnore(filename) {
	  if (!ignore && !only) {
	    return /node_modules/.test(filename);
	  } else {
	    return util.shouldIgnore(filename, ignore || [], only || []);
	  }
	};
	
	var istanbulMonkey = {};
	
	if (process.env.running_under_istanbul) {
	  // we need to monkey patch fs.readFileSync so we can hook into
	  // what istanbul gets, it's extremely dirty but it's the only way
	  var _readFileSync = _fs2["default"].readFileSync;
	
	  _fs2["default"].readFileSync = function (filename) {
	    if (istanbulMonkey[filename]) {
	      delete istanbulMonkey[filename];
	      var code = compile(filename);
	      istanbulMonkey[filename] = true;
	      return code;
	    } else {
	      return _readFileSync.apply(this, arguments);
	    }
	  };
	}
	
	var istanbulLoader = function istanbulLoader(m, filename, old) {
	  istanbulMonkey[filename] = true;
	  old(m, filename);
	};
	
	var normalLoader = function normalLoader(m, filename) {
	  m._compile(compile(filename), filename);
	};
	
	var registerExtension = function registerExtension(ext) {
	  var old = oldHandlers[ext] || oldHandlers[".js"];
	
	  var loader = normalLoader;
	  if (process.env.running_under_istanbul) loader = istanbulLoader;
	
	  (void 0)[ext] = function (m, filename) {
	    if (shouldIgnore(filename)) {
	      old(m, filename);
	    } else {
	      loader(m, filename, old);
	    }
	  };
	};
	
	var hookExtensions = function hookExtensions(_exts) {
	  (0, _lodashCollectionEach2["default"])(oldHandlers, function (old, ext) {
	    if (old === undefined) {
	      delete (void 0)[ext];
	    } else {
	      (void 0)[ext] = old;
	    }
	  });
	
	  oldHandlers = {};
	
	  (0, _lodashCollectionEach2["default"])(_exts, function (ext) {
	    oldHandlers[ext] = (void 0)[ext];
	    registerExtension(ext);
	  });
	};
	
	hookExtensions(util.canCompile.EXTENSIONS);
	
	exports["default"] = function () {
	  var opts = arguments[0] === undefined ? {} : arguments[0];
	
	  if (opts.only != null) only = util.arrayify(opts.only, util.regexify);
	  if (opts.ignore != null) ignore = util.arrayify(opts.ignore, util.regexify);
	
	  if (opts.extensions) hookExtensions(util.arrayify(opts.extensions));
	
	  if (opts.cache === false) cache = null;
	
	  delete opts.extensions;
	  delete opts.ignore;
	  delete opts.cache;
	  delete opts.only;
	
	  (0, _lodashObjectExtend2["default"])(transformOpts, opts);
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 94 */
/*!*************************************!*\
  !*** external "source-map-support" ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("source-map-support");

/***/ },
/* 95 */
/*!******************************************************!*\
  !*** ./~/babel-core/lib/babel/api/register/cache.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.save = save;
	exports.load = load;
	exports.get = get;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _path = __webpack_require__(/*! path */ 96);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _os = __webpack_require__(/*! os */ 97);
	
	var _os2 = _interopRequireDefault(_os);
	
	var _fs = __webpack_require__(/*! fs */ 98);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _homeOrTmp = __webpack_require__(/*! home-or-tmp */ 99);
	
	var _homeOrTmp2 = _interopRequireDefault(_homeOrTmp);
	
	var FILENAME = process.env.BABEL_CACHE_PATH || _path2["default"].join(_homeOrTmp2["default"], ".babel.json");
	var data = {};
	
	function save() {
	  _fs2["default"].writeFileSync(FILENAME, JSON.stringify(data, null, "  "));
	}
	
	function load() {
	  if (process.env.BABEL_DISABLE_CACHE) return;
	
	  process.on("exit", save);
	  process.nextTick(save);
	
	  if (!_fs2["default"].existsSync(FILENAME)) return;
	
	  try {
	    data = JSON.parse(_fs2["default"].readFileSync(FILENAME));
	  } catch (err) {
	    return;
	  }
	}
	
	function get() {
	  return data;
	}

/***/ },
/* 96 */
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("path");

/***/ },
/* 97 */
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("os");

/***/ },
/* 98 */
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("fs");

/***/ },
/* 99 */
/*!******************************!*\
  !*** external "home-or-tmp" ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("home-or-tmp");

/***/ },
/* 100 */
/*!****************************************************!*\
  !*** ./~/babel-core/lib/babel/tools/resolve-rc.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _stripJsonComments = __webpack_require__(/*! strip-json-comments */ 101);
	
	var _stripJsonComments2 = _interopRequireDefault(_stripJsonComments);
	
	var _helpersMerge = __webpack_require__(/*! ../helpers/merge */ 102);
	
	var _helpersMerge2 = _interopRequireDefault(_helpersMerge);
	
	var _path = __webpack_require__(/*! path */ 96);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(/*! fs */ 98);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var cache = {};
	var jsons = {};
	
	function exists(filename) {
	  if (!_fs2["default"].existsSync) return false;
	
	  var cached = cache[filename];
	  if (cached != null) return cached;
	  return cache[filename] = _fs2["default"].existsSync(filename);
	}
	
	exports["default"] = function (loc) {
	  var opts = arguments[1] === undefined ? {} : arguments[1];
	
	  var rel = ".babelrc";
	
	  if (!opts.babelrc) {
	    opts.babelrc = [];
	  }
	
	  function find(start, rel) {
	    var file = _path2["default"].join(start, rel);
	
	    if (opts.babelrc.indexOf(file) >= 0) {
	      return;
	    }
	
	    if (exists(file)) {
	      var content = _fs2["default"].readFileSync(file, "utf8");
	      var json;
	
	      try {
	        json = jsons[content] = jsons[content] || JSON.parse((0, _stripJsonComments2["default"])(content));
	      } catch (err) {
	        err.message = "" + file + ": " + err.message;
	        throw err;
	      }
	
	      opts.babelrc.push(file);
	
	      if (json.breakConfig) return;
	      (0, _helpersMerge2["default"])(opts, json);
	    }
	
	    var up = _path2["default"].dirname(start);
	    if (up !== start) {
	      // root
	      find(up, rel);
	    }
	  }
	
	  if (opts.babelrc.indexOf(loc) < 0 && opts.breakConfig !== true) {
	    find(loc, rel);
	  }
	
	  return opts;
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 101 */
/*!**************************************!*\
  !*** external "strip-json-comments" ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("strip-json-comments");

/***/ },
/* 102 */
/*!*************************************************!*\
  !*** ./~/babel-core/lib/babel/helpers/merge.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashObjectMerge = __webpack_require__(/*! lodash/object/merge */ 103);
	
	var _lodashObjectMerge2 = _interopRequireDefault(_lodashObjectMerge);
	
	exports["default"] = function (dest, src) {
	  if (!dest || !src) return;
	
	  return (0, _lodashObjectMerge2["default"])(dest, src, function (a, b) {
	    if (Array.isArray(a)) {
	      var c = a.slice(0);
	      for (var _iterator = b, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var v = _ref;
	
	        if (a.indexOf(v) < 0) {
	          c.push(v);
	        }
	      }
	      return c;
	    }
	  });
	};
	
	module.exports = exports["default"];

/***/ },
/* 103 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/lodash/object/merge.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(/*! ../internal/baseMerge */ 104),
	    createAssigner = __webpack_require__(/*! ../internal/createAssigner */ 133);
	
	/**
	 * Recursively merges own enumerable properties of the source object(s), that
	 * don't resolve to `undefined` into the destination object. Subsequent sources
	 * overwrite property assignments of previous sources. If `customizer` is
	 * provided it is invoked to produce the merged values of the destination and
	 * source properties. If `customizer` returns `undefined` merging is handled
	 * by the method instead. The `customizer` is bound to `thisArg` and invoked
	 * with five arguments: (objectValue, sourceValue, key, object, source).
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var users = {
	 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	 * };
	 *
	 * var ages = {
	 *   'data': [{ 'age': 36 }, { 'age': 40 }]
	 * };
	 *
	 * _.merge(users, ages);
	 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	 *
	 * // using a customizer callback
	 * var object = {
	 *   'fruits': ['apple'],
	 *   'vegetables': ['beet']
	 * };
	 *
	 * var other = {
	 *   'fruits': ['banana'],
	 *   'vegetables': ['carrot']
	 * };
	 *
	 * _.merge(object, other, function(a, b) {
	 *   if (_.isArray(a)) {
	 *     return a.concat(b);
	 *   }
	 * });
	 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	 */
	var merge = createAssigner(baseMerge);
	
	module.exports = merge;


/***/ },
/* 104 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseMerge.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(/*! ./arrayEach */ 106),
	    baseMergeDeep = __webpack_require__(/*! ./baseMergeDeep */ 107),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isArrayLike = __webpack_require__(/*! ./isArrayLike */ 110),
	    isObject = __webpack_require__(/*! ../lang/isObject */ 105),
	    isObjectLike = __webpack_require__(/*! ./isObjectLike */ 114),
	    isTypedArray = __webpack_require__(/*! ../lang/isTypedArray */ 128),
	    keys = __webpack_require__(/*! ../object/keys */ 131);
	
	/**
	 * The base implementation of `_.merge` without support for argument juggling,
	 * multiple sources, and `this` binding `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {Function} [customizer] The function to customize merging properties.
	 * @param {Array} [stackA=[]] Tracks traversed source objects.
	 * @param {Array} [stackB=[]] Associates values with source counterparts.
	 * @returns {Object} Returns `object`.
	 */
	function baseMerge(object, source, customizer, stackA, stackB) {
	  if (!isObject(object)) {
	    return object;
	  }
	  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
	      props = isSrcArr ? null : keys(source);
	
	  arrayEach(props || source, function(srcValue, key) {
	    if (props) {
	      key = srcValue;
	      srcValue = source[key];
	    }
	    if (isObjectLike(srcValue)) {
	      stackA || (stackA = []);
	      stackB || (stackB = []);
	      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	    }
	    else {
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = result === undefined;
	
	      if (isCommon) {
	        result = srcValue;
	      }
	      if ((result !== undefined || (isSrcArr && !(key in object))) &&
	          (isCommon || (result === result ? (result !== value) : (value === value)))) {
	        object[key] = result;
	      }
	    }
	  });
	  return object;
	}
	
	module.exports = baseMerge;


/***/ },
/* 105 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isObject.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ },
/* 106 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/arrayEach.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `_.forEach` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	
	module.exports = arrayEach;


/***/ },
/* 107 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseMergeDeep.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arrayCopy = __webpack_require__(/*! ./arrayCopy */ 108),
	    isArguments = __webpack_require__(/*! ../lang/isArguments */ 109),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isArrayLike = __webpack_require__(/*! ./isArrayLike */ 110),
	    isPlainObject = __webpack_require__(/*! ../lang/isPlainObject */ 120),
	    isTypedArray = __webpack_require__(/*! ../lang/isTypedArray */ 128),
	    toPlainObject = __webpack_require__(/*! ../lang/toPlainObject */ 129);
	
	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize merging properties.
	 * @param {Array} [stackA=[]] Tracks traversed source objects.
	 * @param {Array} [stackB=[]] Associates values with source counterparts.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	  var length = stackA.length,
	      srcValue = source[key];
	
	  while (length--) {
	    if (stackA[length] == srcValue) {
	      object[key] = stackB[length];
	      return;
	    }
	  }
	  var value = object[key],
	      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	      isCommon = result === undefined;
	
	  if (isCommon) {
	    result = srcValue;
	    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
	      result = isArray(value)
	        ? value
	        : (isArrayLike(value) ? arrayCopy(value) : []);
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      result = isArguments(value)
	        ? toPlainObject(value)
	        : (isPlainObject(value) ? value : {});
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  // Add the source value to the stack of traversed objects and associate
	  // it with its merged value.
	  stackA.push(srcValue);
	  stackB.push(result);
	
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	  } else if (result === result ? (result !== value) : (value === value)) {
	    object[key] = result;
	  }
	}
	
	module.exports = baseMergeDeep;


/***/ },
/* 108 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/arrayCopy.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function arrayCopy(source, array) {
	  var index = -1,
	      length = source.length;
	
	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}
	
	module.exports = arrayCopy;


/***/ },
/* 109 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isArguments.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(/*! ../internal/isArrayLike */ 110),
	    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
	}
	
	module.exports = isArguments;


/***/ },
/* 110 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/isArrayLike.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var getLength = __webpack_require__(/*! ./getLength */ 111),
	    isLength = __webpack_require__(/*! ./isLength */ 113);
	
	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}
	
	module.exports = isArrayLike;


/***/ },
/* 111 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/getLength.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(/*! ./baseProperty */ 112);
	
	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');
	
	module.exports = getLength;


/***/ },
/* 112 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseProperty.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	module.exports = baseProperty;


/***/ },
/* 113 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/isLength.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ },
/* 114 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/isObjectLike.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 115 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isArray.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(/*! ../internal/getNative */ 116),
	    isLength = __webpack_require__(/*! ../internal/isLength */ 113),
	    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var arrayTag = '[object Array]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};
	
	module.exports = isArray;


/***/ },
/* 116 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/getNative.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isNative = __webpack_require__(/*! ../lang/isNative */ 117);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ },
/* 117 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isNative.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var escapeRegExp = __webpack_require__(/*! ../string/escapeRegExp */ 118),
	    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]';
	
	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  escapeRegExp(fnToString.call(hasOwnProperty))
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (objToString.call(value) == funcTag) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}
	
	module.exports = isNative;


/***/ },
/* 118 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/string/escapeRegExp.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(/*! ../internal/baseToString */ 119);
	
	/**
	 * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
	 * In addition to special characters the forward slash is escaped to allow for
	 * easier `eval` use and `Function` compilation.
	 */
	var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
	    reHasRegExpChars = RegExp(reRegExpChars.source);
	
	/**
	 * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
	 * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
	 */
	function escapeRegExp(string) {
	  string = baseToString(string);
	  return (string && reHasRegExpChars.test(string))
	    ? string.replace(reRegExpChars, '\\$&')
	    : string;
	}
	
	module.exports = escapeRegExp;


/***/ },
/* 119 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseToString.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  if (typeof value == 'string') {
	    return value;
	  }
	  return value == null ? '' : (value + '');
	}
	
	module.exports = baseToString;


/***/ },
/* 120 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isPlainObject.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(/*! ../internal/getNative */ 116),
	    shimIsPlainObject = __webpack_require__(/*! ../internal/shimIsPlainObject */ 121);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/** Native method references. */
	var getPrototypeOf = getNative(Object, 'getPrototypeOf');
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * **Note:** This method assumes objects created by the `Object` constructor
	 * have no inherited enumerable properties.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
	  if (!(value && objToString.call(value) == objectTag)) {
	    return false;
	  }
	  var valueOf = getNative(value, 'valueOf'),
	      objProto = valueOf && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
	
	  return objProto
	    ? (value == objProto || getPrototypeOf(value) == objProto)
	    : shimIsPlainObject(value);
	};
	
	module.exports = isPlainObject;


/***/ },
/* 121 */
/*!*************************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/shimIsPlainObject.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseForIn = __webpack_require__(/*! ./baseForIn */ 122),
	    isObjectLike = __webpack_require__(/*! ./isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * A fallback implementation of `_.isPlainObject` which checks if `value`
	 * is an object created by the `Object` constructor or has a `[[Prototype]]`
	 * of `null`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 */
	function shimIsPlainObject(value) {
	  var Ctor;
	
	  // Exit early for non `Object` objects.
	  if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
	      (!hasOwnProperty.call(value, 'constructor') &&
	        (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	    return false;
	  }
	  // IE < 9 iterates inherited properties before own properties. If the first
	  // iterated property is an object's own property then there are no inherited
	  // enumerable properties.
	  var result;
	  // In most environments an object's own properties are iterated before
	  // its inherited properties. If the last iterated property is an object's
	  // own property then there are no inherited enumerable properties.
	  baseForIn(value, function(subValue, key) {
	    result = key;
	  });
	  return result === undefined || hasOwnProperty.call(value, result);
	}
	
	module.exports = shimIsPlainObject;


/***/ },
/* 122 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseForIn.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(/*! ./baseFor */ 123),
	    keysIn = __webpack_require__(/*! ../object/keysIn */ 126);
	
	/**
	 * The base implementation of `_.forIn` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForIn(object, iteratee) {
	  return baseFor(object, iteratee, keysIn);
	}
	
	module.exports = baseForIn;


/***/ },
/* 123 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseFor.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(/*! ./createBaseFor */ 124);
	
	/**
	 * The base implementation of `baseForIn` and `baseForOwn` which iterates
	 * over `object` properties returned by `keysFunc` invoking `iteratee` for
	 * each property. Iteratee functions may exit iteration early by explicitly
	 * returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	module.exports = baseFor;


/***/ },
/* 124 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/createBaseFor.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var toObject = __webpack_require__(/*! ./toObject */ 125);
	
	/**
	 * Creates a base function for `_.forIn` or `_.forInRight`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var iterable = toObject(object),
	        props = keysFunc(object),
	        length = props.length,
	        index = fromRight ? length : -1;
	
	    while ((fromRight ? index-- : ++index < length)) {
	      var key = props[index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	module.exports = createBaseFor;


/***/ },
/* 125 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/toObject.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ../lang/isObject */ 105);
	
	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}
	
	module.exports = toObject;


/***/ },
/* 126 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/object/keysIn.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(/*! ../lang/isArguments */ 109),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isIndex = __webpack_require__(/*! ../internal/isIndex */ 127),
	    isLength = __webpack_require__(/*! ../internal/isLength */ 113),
	    isObject = __webpack_require__(/*! ../lang/isObject */ 105);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || isArguments(object)) && length) || 0;
	
	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;
	
	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = keysIn;


/***/ },
/* 127 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/isIndex.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;
	
	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}
	
	module.exports = isIndex;


/***/ },
/* 128 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isTypedArray.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(/*! ../internal/isLength */ 113),
	    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	function isTypedArray(value) {
	  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	}
	
	module.exports = isTypedArray;


/***/ },
/* 129 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/toPlainObject.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseCopy = __webpack_require__(/*! ../internal/baseCopy */ 130),
	    keysIn = __webpack_require__(/*! ../object/keysIn */ 126);
	
	/**
	 * Converts `value` to a plain object flattening inherited enumerable
	 * properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return baseCopy(value, keysIn(value));
	}
	
	module.exports = toPlainObject;


/***/ },
/* 130 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseCopy.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property names to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @returns {Object} Returns `object`.
	 */
	function baseCopy(source, props, object) {
	  object || (object = {});
	
	  var index = -1,
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index];
	    object[key] = source[key];
	  }
	  return object;
	}
	
	module.exports = baseCopy;


/***/ },
/* 131 */
/*!**********************************************!*\
  !*** ./~/babel-core/~/lodash/object/keys.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(/*! ../internal/getNative */ 116),
	    isArrayLike = __webpack_require__(/*! ../internal/isArrayLike */ 110),
	    isObject = __webpack_require__(/*! ../lang/isObject */ 105),
	    shimKeys = __webpack_require__(/*! ../internal/shimKeys */ 132);
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  var Ctor = object == null ? null : object.constructor;
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && isArrayLike(object))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};
	
	module.exports = keys;


/***/ },
/* 132 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/shimKeys.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(/*! ../lang/isArguments */ 109),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isIndex = __webpack_require__(/*! ./isIndex */ 127),
	    isLength = __webpack_require__(/*! ./isLength */ 113),
	    keysIn = __webpack_require__(/*! ../object/keysIn */ 126);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;
	
	  var allowIndexes = !!length && isLength(length) &&
	    (isArray(object) || isArguments(object));
	
	  var index = -1,
	      result = [];
	
	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = shimKeys;


/***/ },
/* 133 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/createAssigner.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var bindCallback = __webpack_require__(/*! ./bindCallback */ 134),
	    isIterateeCall = __webpack_require__(/*! ./isIterateeCall */ 136),
	    restParam = __webpack_require__(/*! ../function/restParam */ 137);
	
	/**
	 * Creates a function that assigns properties of source object(s) to a given
	 * destination object.
	 *
	 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return restParam(function(object, sources) {
	    var index = -1,
	        length = object == null ? 0 : sources.length,
	        customizer = length > 2 ? sources[length - 2] : undefined,
	        guard = length > 2 ? sources[2] : undefined,
	        thisArg = length > 1 ? sources[length - 1] : undefined;
	
	    if (typeof customizer == 'function') {
	      customizer = bindCallback(customizer, thisArg, 5);
	      length -= 2;
	    } else {
	      customizer = typeof thisArg == 'function' ? thisArg : undefined;
	      length -= (customizer ? 1 : 0);
	    }
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, customizer);
	      }
	    }
	    return object;
	  });
	}
	
	module.exports = createAssigner;


/***/ },
/* 134 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/bindCallback.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(/*! ../utility/identity */ 135);
	
	/**
	 * A specialized version of `baseCallback` which only supports `this` binding
	 * and specifying the number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function bindCallback(func, thisArg, argCount) {
	  if (typeof func != 'function') {
	    return identity;
	  }
	  if (thisArg === undefined) {
	    return func;
	  }
	  switch (argCount) {
	    case 1: return function(value) {
	      return func.call(thisArg, value);
	    };
	    case 3: return function(value, index, collection) {
	      return func.call(thisArg, value, index, collection);
	    };
	    case 4: return function(accumulator, value, index, collection) {
	      return func.call(thisArg, accumulator, value, index, collection);
	    };
	    case 5: return function(value, other, key, object, source) {
	      return func.call(thisArg, value, other, key, object, source);
	    };
	  }
	  return function() {
	    return func.apply(thisArg, arguments);
	  };
	}
	
	module.exports = bindCallback;


/***/ },
/* 135 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/utility/identity.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This method returns the first argument provided to it.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = identity;


/***/ },
/* 136 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/isIterateeCall.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(/*! ./isArrayLike */ 110),
	    isIndex = __webpack_require__(/*! ./isIndex */ 127),
	    isObject = __webpack_require__(/*! ../lang/isObject */ 105);
	
	/**
	 * Checks if the provided arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	      ? (isArrayLike(object) && isIndex(index, object.length))
	      : (type == 'string' && index in object)) {
	    var other = object[index];
	    return value === value ? (value === other) : (other !== other);
	  }
	  return false;
	}
	
	module.exports = isIterateeCall;


/***/ },
/* 137 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/function/restParam.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * created function and arguments from `start` and beyond provided as an array.
	 *
	 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	 *
	 * @static
	 * @memberOf _
	 * @category Function
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.restParam(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
	 *
	 * say('hello', 'fred', 'barney', 'pebbles');
	 * // => 'hello fred, barney, & pebbles'
	 */
	function restParam(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        rest = Array(length);
	
	    while (++index < length) {
	      rest[index] = args[start + index];
	    }
	    switch (start) {
	      case 0: return func.call(this, rest);
	      case 1: return func.call(this, args[0], rest);
	      case 2: return func.call(this, args[0], args[1], rest);
	    }
	    var otherArgs = Array(start + 1);
	    index = -1;
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = rest;
	    return func.apply(this, otherArgs);
	  };
	}
	
	module.exports = restParam;


/***/ },
/* 138 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/object/extend.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./assign */ 139);


/***/ },
/* 139 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/object/assign.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var assignWith = __webpack_require__(/*! ../internal/assignWith */ 140),
	    baseAssign = __webpack_require__(/*! ../internal/baseAssign */ 141),
	    createAssigner = __webpack_require__(/*! ../internal/createAssigner */ 133);
	
	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object. Subsequent sources overwrite property assignments of previous sources.
	 * If `customizer` is provided it is invoked to produce the assigned values.
	 * The `customizer` is bound to `thisArg` and invoked with five arguments:
	 * (objectValue, sourceValue, key, object, source).
	 *
	 * **Note:** This method mutates `object` and is based on
	 * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
	 *
	 * @static
	 * @memberOf _
	 * @alias extend
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	 * // => { 'user': 'fred', 'age': 40 }
	 *
	 * // using a customizer callback
	 * var defaults = _.partialRight(_.assign, function(value, other) {
	 *   return _.isUndefined(value) ? other : value;
	 * });
	 *
	 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	 * // => { 'user': 'barney', 'age': 36 }
	 */
	var assign = createAssigner(function(object, source, customizer) {
	  return customizer
	    ? assignWith(object, source, customizer)
	    : baseAssign(object, source);
	});
	
	module.exports = assign;


/***/ },
/* 140 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/assignWith.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(/*! ../object/keys */ 131);
	
	/**
	 * A specialized version of `_.assign` for customizing assigned values without
	 * support for argument juggling, multiple sources, and `this` binding `customizer`
	 * functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 */
	function assignWith(object, source, customizer) {
	  var index = -1,
	      props = keys(source),
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index],
	        value = object[key],
	        result = customizer(value, source[key], key, object, source);
	
	    if ((result === result ? (result !== value) : (value === value)) ||
	        (value === undefined && !(key in object))) {
	      object[key] = result;
	    }
	  }
	  return object;
	}
	
	module.exports = assignWith;


/***/ },
/* 141 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseAssign.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseCopy = __webpack_require__(/*! ./baseCopy */ 130),
	    keys = __webpack_require__(/*! ../object/keys */ 131);
	
	/**
	 * The base implementation of `_.assign` without support for argument juggling,
	 * multiple sources, and `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return source == null
	    ? object
	    : baseCopy(source, keys(source), object);
	}
	
	module.exports = baseAssign;


/***/ },
/* 142 */
/*!********************************************!*\
  !*** ./~/babel-core/lib/babel/api/node.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.register = register;
	exports.polyfill = polyfill;
	exports.transformFile = transformFile;
	exports.transformFileSync = transformFileSync;
	exports.parse = parse;
	
	function _interopRequire(obj) { return obj && obj.__esModule ? obj["default"] : obj; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangIsFunction = __webpack_require__(/*! lodash/lang/isFunction */ 245);
	
	var _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);
	
	var _transformation = __webpack_require__(/*! ../transformation */ 268);
	
	var _transformation2 = _interopRequireDefault(_transformation);
	
	var _acorn = __webpack_require__(/*! ../../acorn */ 217);
	
	var acorn = _interopRequireWildcard(_acorn);
	
	var _util = __webpack_require__(/*! ../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _fs = __webpack_require__(/*! fs */ 98);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	exports.util = util;
	exports.acorn = acorn;
	exports.transform = _transformation2["default"];
	exports.pipeline = _transformation.pipeline;
	exports.canCompile = _util.canCompile;
	
	var _transformationFileOptions = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../transformation/file/options\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	exports.options = _interopRequire(_transformationFileOptions);
	
	var _transformationTransformer = __webpack_require__(/*! ../transformation/transformer */ 143);
	
	exports.Transformer = _interopRequire(_transformationTransformer);
	
	var _transformationTransformerPipeline = __webpack_require__(/*! ../transformation/transformer-pipeline */ 269);
	
	exports.TransformerPipeline = _interopRequire(_transformationTransformerPipeline);
	
	var _traversal = __webpack_require__(/*! ../traversal */ 151);
	
	exports.traverse = _interopRequire(_traversal);
	
	var _toolsBuildExternalHelpers = __webpack_require__(/*! ../tools/build-external-helpers */ 405);
	
	exports.buildExternalHelpers = _interopRequire(_toolsBuildExternalHelpers);
	
	var _package = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../../../package\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	exports.version = _package.version;
	exports.types = t;
	
	function register(opts) {
	  var callback = __webpack_require__(/*! ./register/node-polyfill */ 3);
	  if (opts != null) callback(opts);
	  return callback;
	}
	
	function polyfill() {
	  __webpack_require__(/*! ../polyfill */ 4);
	}
	
	function transformFile(filename, opts, callback) {
	  if ((0, _lodashLangIsFunction2["default"])(opts)) {
	    callback = opts;
	    opts = {};
	  }
	
	  opts.filename = filename;
	
	  _fs2["default"].readFile(filename, function (err, code) {
	    if (err) return callback(err);
	
	    var result;
	
	    try {
	      result = (0, _transformation2["default"])(code, opts);
	    } catch (err) {
	      return callback(err);
	    }
	
	    callback(null, result);
	  });
	}
	
	function transformFileSync(filename) {
	  var opts = arguments[1] === undefined ? {} : arguments[1];
	
	  opts.filename = filename;
	  return (0, _transformation2["default"])(_fs2["default"].readFileSync(filename, "utf8"), opts);
	}
	
	function parse(code) {
	  var opts = arguments[1] === undefined ? {} : arguments[1];
	
	  opts.allowHashBang = true;
	  opts.sourceType = "module";
	  opts.ecmaVersion = Infinity;
	  opts.plugins = {
	    jsx: true,
	    flow: true
	  };
	  opts.features = {};
	
	  for (var key in _transformation2["default"].pipeline.transformers) {
	    opts.features[key] = true;
	  }
	
	  return acorn.parse(code, opts);
	}

/***/ },
/* 143 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformer.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _transformerPass = __webpack_require__(/*! ./transformer-pass */ 144);
	
	var _transformerPass2 = _interopRequireDefault(_transformerPass);
	
	var _messages = __webpack_require__(/*! ../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _lodashLangIsFunction = __webpack_require__(/*! lodash/lang/isFunction */ 245);
	
	var _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);
	
	var _traversal = __webpack_require__(/*! ../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _lodashLangIsObject = __webpack_require__(/*! lodash/lang/isObject */ 105);
	
	var _lodashLangIsObject2 = _interopRequireDefault(_lodashLangIsObject);
	
	var _lodashObjectAssign = __webpack_require__(/*! lodash/object/assign */ 139);
	
	var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
	
	var _acorn = __webpack_require__(/*! ../../acorn */ 217);
	
	var acorn = _interopRequireWildcard(_acorn);
	
	var _file = __webpack_require__(/*! ./file */ 247);
	
	var _file2 = _interopRequireDefault(_file);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	/**
	 * This is the class responsible for normalising a transformers handlers
	 * as well as constructing a `TransformerPass` that is responsible for
	 * actually running the transformer over the provided `File`.
	 */
	
	var Transformer = (function () {
	  function Transformer(transformerKey, transformer) {
	    _classCallCheck(this, Transformer);
	
	    transformer = (0, _lodashObjectAssign2["default"])({}, transformer);
	
	    var take = function take(key) {
	      var val = transformer[key];
	      delete transformer[key];
	      return val;
	    };
	
	    this.manipulateOptions = take("manipulateOptions");
	    this.metadata = take("metadata") || {};
	    this.dependencies = this.metadata.dependencies || [];
	    this.parser = take("parser");
	    this.post = take("post");
	    this.pre = take("pre");
	
	    //
	
	    if (this.metadata.stage != null) {
	      this.metadata.optional = true;
	    }
	
	    //
	
	    this.handlers = this.normalize(transformer);
	    this.key = transformerKey;
	  }
	
	  Transformer.prototype.normalize = function normalize(transformer) {
	    var _this = this;
	
	    if ((0, _lodashLangIsFunction2["default"])(transformer)) {
	      transformer = { ast: transformer };
	    }
	
	    _traversal2["default"].explode(transformer);
	
	    (0, _lodashCollectionEach2["default"])(transformer, function (fns, type) {
	      // hidden property
	      if (type[0] === "_") {
	        _this[type] = fns;
	        return;
	      }
	
	      if (type === "enter" || type === "exit") return;
	
	      if ((0, _lodashLangIsFunction2["default"])(fns)) fns = { enter: fns };
	
	      if (!(0, _lodashLangIsObject2["default"])(fns)) return;
	
	      if (!fns.enter) fns.enter = function () {};
	      if (!fns.exit) fns.exit = function () {};
	
	      transformer[type] = fns;
	    });
	
	    return transformer;
	  };
	
	  Transformer.prototype.buildPass = function buildPass(file) {
	    // validate Transformer instance
	    if (!(file instanceof _file2["default"])) {
	      throw new TypeError(messages.get("transformerNotFile", this.key));
	    }
	
	    return new _transformerPass2["default"](file, this);
	  };
	
	  return Transformer;
	})();
	
	exports["default"] = Transformer;
	module.exports = exports["default"];

/***/ },
/* 144 */
/*!*******************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformer-pass.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _traversal = __webpack_require__(/*! ../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	/**
	 * This class is responsible for traversing over the provided `File`s
	 * AST and running it's parent transformers handlers over it.
	 */
	
	var TransformerPass = (function () {
	  function TransformerPass(file, transformer) {
	    _classCallCheck(this, TransformerPass);
	
	    this.transformer = transformer;
	    this.handlers = transformer.handlers;
	    this.file = file;
	    this.ran = false;
	    this.key = transformer.key;
	  }
	
	  TransformerPass.prototype.canTransform = function canTransform() {
	    return this.file.transformerDependencies[this.key] || this.file.pipeline.canTransform(this.transformer, this.file.opts);
	  };
	
	  TransformerPass.prototype.transform = function transform() {
	    var file = this.file;
	
	    file.log.debug("Start transformer " + this.key);
	
	    (0, _traversal2["default"])(file.ast, this.handlers, file.scope, file);
	
	    file.log.debug("Finish transformer " + this.key);
	
	    this.ran = true;
	  };
	
	  return TransformerPass;
	})();
	
	exports["default"] = TransformerPass;
	module.exports = exports["default"];

/***/ },
/* 145 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/includes.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(/*! ../internal/baseIndexOf */ 146),
	    getLength = __webpack_require__(/*! ../internal/getLength */ 111),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ 136),
	    isLength = __webpack_require__(/*! ../internal/isLength */ 113),
	    isString = __webpack_require__(/*! ../lang/isString */ 148),
	    values = __webpack_require__(/*! ../object/values */ 149);
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * Checks if `value` is in `collection` using
	 * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	 * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	 * from the end of `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @alias contains, include
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to search.
	 * @param {*} target The value to search for.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	 * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	 * @example
	 *
	 * _.includes([1, 2, 3], 1);
	 * // => true
	 *
	 * _.includes([1, 2, 3], 1, 2);
	 * // => false
	 *
	 * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	 * // => true
	 *
	 * _.includes('pebbles', 'eb');
	 * // => true
	 */
	function includes(collection, target, fromIndex, guard) {
	  var length = collection ? getLength(collection) : 0;
	  if (!isLength(length)) {
	    collection = values(collection);
	    length = collection.length;
	  }
	  if (!length) {
	    return false;
	  }
	  if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
	    fromIndex = 0;
	  } else {
	    fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	  }
	  return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	    ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
	    : (baseIndexOf(collection, target, fromIndex) > -1);
	}
	
	module.exports = includes;


/***/ },
/* 146 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseIndexOf.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var indexOfNaN = __webpack_require__(/*! ./indexOfNaN */ 147);
	
	/**
	 * The base implementation of `_.indexOf` without support for binary searches.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return indexOfNaN(array, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;
	
	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = baseIndexOf;


/***/ },
/* 147 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/indexOfNaN.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Gets the index at which the first occurrence of `NaN` is found in `array`.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	 */
	function indexOfNaN(array, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 0 : -1);
	
	  while ((fromRight ? index-- : ++index < length)) {
	    var other = array[index];
	    if (other !== other) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = indexOfNaN;


/***/ },
/* 148 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isString.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var stringTag = '[object String]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	}
	
	module.exports = isString;


/***/ },
/* 149 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/object/values.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseValues = __webpack_require__(/*! ../internal/baseValues */ 150),
	    keys = __webpack_require__(/*! ./keys */ 131);
	
	/**
	 * Creates an array of the own enumerable property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return baseValues(object, keys(object));
	}
	
	module.exports = values;


/***/ },
/* 150 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseValues.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  var index = -1,
	      length = props.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = object[props[index]];
	  }
	  return result;
	}
	
	module.exports = baseValues;


/***/ },
/* 151 */
/*!***************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/index.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = traverse;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _context = __webpack_require__(/*! ./context */ 152);
	
	var _context2 = _interopRequireDefault(_context);
	
	var _visitors = __webpack_require__(/*! ./visitors */ 154);
	
	var visitors = _interopRequireWildcard(_visitors);
	
	var _messages = __webpack_require__(/*! ../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function traverse(parent, opts, scope, state, parentPath) {
	  if (!parent) return;
	
	  if (!opts.noScope && !scope) {
	    if (parent.type !== "Program" && parent.type !== "File") {
	      throw new Error(messages.get("traverseNeedsParent", parent.type));
	    }
	  }
	
	  if (!opts) opts = {};
	
	  visitors.verify(opts);
	  visitors.explode(opts);
	
	  // array of nodes
	  if (Array.isArray(parent)) {
	    for (var i = 0; i < parent.length; i++) {
	      traverse.node(parent[i], opts, scope, state, parentPath);
	    }
	  } else {
	    traverse.node(parent, opts, scope, state, parentPath);
	  }
	}
	
	traverse.visitors = visitors;
	traverse.verify = visitors.verify;
	traverse.explode = visitors.explode;
	
	traverse.node = function (node, opts, scope, state, parentPath) {
	  var keys = t.VISITOR_KEYS[node.type];
	  if (!keys) return;
	
	  var context = new _context2["default"](scope, opts, state, parentPath);
	  for (var i = 0; i < keys.length; i++) {
	    if (context.visit(node, keys[i])) {
	      return;
	    }
	  }
	};
	
	var CLEAR_KEYS = ["trailingComments", "leadingComments", "extendedRange", "_scopeInfo", "_paths", "tokens", "range", "start", "end", "loc", "raw"];
	
	function clearNode(node) {
	  for (var i = 0; i < CLEAR_KEYS.length; i++) {
	    var key = CLEAR_KEYS[i];
	    if (node[key] != null) node[key] = null;
	  }
	
	  for (var key in node) {
	    var val = node[key];
	    if (Array.isArray(val)) {
	      delete val._paths;
	    }
	  }
	}
	
	var clearVisitor = {
	  noScope: true,
	  exit: clearNode
	};
	
	function clearComments(comments) {
	  for (var i = 0; i < comments.length; i++) {
	    clearNode(comments[i]);
	  }
	}
	
	traverse.removeProperties = function (tree) {
	  traverse(tree, clearVisitor);
	  clearNode(tree);
	
	  return tree;
	};
	
	function hasBlacklistedType(node, parent, scope, state) {
	  if (node.type === state.type) {
	    state.has = true;
	    this.skip();
	  }
	}
	
	traverse.hasType = function (tree, scope, type, blacklistTypes) {
	  // the node we're searching in is blacklisted
	  if ((0, _lodashCollectionIncludes2["default"])(blacklistTypes, tree.type)) return false;
	
	  // the type we're looking for is the same as the passed node
	  if (tree.type === type) return true;
	
	  var state = {
	    has: false,
	    type: type
	  };
	
	  traverse(tree, {
	    blacklist: blacklistTypes,
	    enter: hasBlacklistedType
	  }, scope, state);
	
	  return state.has;
	};
	module.exports = exports["default"];

/***/ },
/* 152 */
/*!*****************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/context.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _path = __webpack_require__(/*! ./path */ 153);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _lodashArrayCompact = __webpack_require__(/*! lodash/array/compact */ 158);
	
	var _lodashArrayCompact2 = _interopRequireDefault(_lodashArrayCompact);
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var TraversalContext = (function () {
	  function TraversalContext(scope, opts, state, parentPath) {
	    _classCallCheck(this, TraversalContext);
	
	    this.parentPath = parentPath;
	    this.scope = scope;
	    this.state = state;
	    this.opts = opts;
	  }
	
	  TraversalContext.prototype.shouldVisit = function shouldVisit(node) {
	    var keys = t.VISITOR_KEYS[node.type];
	    return !!(this.opts.enter || this.opts.exit || this.opts[node.type] || keys && keys.length);
	  };
	
	  TraversalContext.prototype.create = function create(node, obj, key) {
	    var path = _path2["default"].get(this.parentPath, node, obj, key);
	    path.unshiftContext(this);
	    return path;
	  };
	
	  TraversalContext.prototype.visitMultiple = function visitMultiple(nodes, node, key) {
	    // nothing to traverse!
	    if (nodes.length === 0) return false;
	
	    var visited = [];
	
	    var queue = this.queue = [];
	    var stop = false;
	
	    // build up initial queue
	    for (var i = 0; i < nodes.length; i++) {
	      var self = nodes[i];
	      if (self && this.shouldVisit(self)) {
	        queue.push(this.create(node, nodes, i));
	      }
	    }
	
	    // visit the queue
	    var _arr = queue;
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var path = _arr[_i];
	      path.update();
	
	      if (visited.indexOf(path.node) >= 0) continue;
	      visited.push(path.node);
	
	      if (path.visit()) {
	        stop = true;
	        break;
	      }
	    }
	
	    var _arr2 = queue;
	    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	      var path = _arr2[_i2];
	      path.shiftContext();
	    }
	
	    this.queue = null;
	
	    return stop;
	  };
	
	  TraversalContext.prototype.visitSingle = function visitSingle(node, key) {
	    if (this.shouldVisit(node[key])) {
	      var path = this.create(node, node, key);
	      path.visit();
	      path.shiftContext();
	    }
	  };
	
	  TraversalContext.prototype.visit = function visit(node, key) {
	    var nodes = node[key];
	    if (!nodes) return;
	
	    if (Array.isArray(nodes)) {
	      return this.visitMultiple(nodes, node, key);
	    } else {
	      return this.visitSingle(node, key);
	    }
	  };
	
	  return TraversalContext;
	})();
	
	exports["default"] = TraversalContext;
	module.exports = exports["default"];

/***/ },
/* 153 */
/*!********************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/path/index.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _hoister = __webpack_require__(/*! ./hoister */ 206);
	
	var _hoister2 = _interopRequireDefault(_hoister);
	
	var _virtualTypes = __webpack_require__(/*! ./virtual-types */ 155);
	
	var virtualTypes = _interopRequireWildcard(_virtualTypes);
	
	var _messages = __webpack_require__(/*! ../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _lodashLangIsBoolean = __webpack_require__(/*! lodash/lang/isBoolean */ 208);
	
	var _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);
	
	var _lodashLangIsNumber = __webpack_require__(/*! lodash/lang/isNumber */ 201);
	
	var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
	
	var _lodashLangIsRegExp = __webpack_require__(/*! lodash/lang/isRegExp */ 202);
	
	var _lodashLangIsRegExp2 = _interopRequireDefault(_lodashLangIsRegExp);
	
	var _lodashLangIsString = __webpack_require__(/*! lodash/lang/isString */ 148);
	
	var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
	
	var _helpersCodeFrame = __webpack_require__(/*! ../../helpers/code-frame */ 209);
	
	var _helpersCodeFrame2 = _interopRequireDefault(_helpersCodeFrame);
	
	var _helpersParse = __webpack_require__(/*! ../../helpers/parse */ 214);
	
	var _helpersParse2 = _interopRequireDefault(_helpersParse);
	
	var _visitors = __webpack_require__(/*! ../visitors */ 154);
	
	var _index = __webpack_require__(/*! ../index */ 151);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _lodashObjectAssign = __webpack_require__(/*! lodash/object/assign */ 139);
	
	var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
	
	var _lodashObjectExtend = __webpack_require__(/*! lodash/object/extend */ 138);
	
	var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
	
	var _scope = __webpack_require__(/*! ../scope */ 236);
	
	var _scope2 = _interopRequireDefault(_scope);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var hoistVariablesVisitor = (0, _visitors.explode)({
	  Function: function Function() {
	    this.skip();
	  },
	
	  VariableDeclaration: function VariableDeclaration(node, parent, scope) {
	    if (node.kind !== "var") return;
	
	    var bindings = this.getBindingIdentifiers();
	    for (var key in bindings) {
	      scope.push({ id: bindings[key] });
	    }
	
	    var exprs = [];
	
	    var _arr = node.declarations;
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var declar = _arr[_i];
	      var declar = node.declarations[i];
	      if (declar.init) {
	        exprs.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
	      }
	    }
	
	    return exprs;
	  }
	});
	
	var TraversalPath = (function () {
	  function TraversalPath(parent, container) {
	    _classCallCheck(this, TraversalPath);
	
	    this.container = container;
	    this.contexts = [];
	    this.parent = parent;
	    this.data = {};
	  }
	
	  /**
	   * Description
	   */
	
	  TraversalPath.get = function get(parentPath, parent, container, key) {
	    var targetNode = container[key];
	    var paths = container._paths = container._paths || [];
	    var path;
	
	    for (var i = 0; i < paths.length; i++) {
	      var pathCheck = paths[i];
	      if (pathCheck.node === targetNode) {
	        path = pathCheck;
	        break;
	      }
	    }
	
	    if (!path) {
	      path = new TraversalPath(parent, container);
	      paths.push(path);
	    }
	
	    path.setup(parentPath, key);
	
	    return path;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.getScope = function getScope(path, scope, file) {
	    var ourScope = scope;
	
	    // we're entering a new scope so let's construct it!
	    if (path.isScope()) {
	      ourScope = new _scope2["default"](path, scope, file);
	    }
	
	    return ourScope;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.getAncestry = function getAncestry() {
	    var ancestry = [];
	
	    var path = this.parentPath;
	    while (path) {
	      ancestry.push(path.node);
	      path = path.parentPath;
	    }
	
	    return ancestry;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.inType = function inType(types) {
	    if (!Array.isArray(types)) types = [types];
	
	    var path = this;
	    while (path) {
	      var _arr3 = types;
	
	      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	        var type = _arr3[_i3];
	        if (path.node.type === type) return true;
	      }
	      path = path.parentPath;
	    }
	
	    return false;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.inShadow = function inShadow() {
	    var path = this;
	    while (path) {
	      if (path.isFunction()) {
	        if (path.node.shadow) {
	          return path;
	        } else {
	          return null;
	        }
	      }
	      path = path.parentPath;
	    }
	    return null;
	  };
	
	  /**
	   * Check whether this node was a part of the original AST.
	   */
	
	  TraversalPath.prototype.isUser = function isUser() {
	    return this.node && !!this.node.loc;
	  };
	
	  /**
	   * Check whether this node was generated by us and not a part of the original AST.
	   */
	
	  TraversalPath.prototype.isGenerated = function isGenerated() {
	    return !this.isUser();
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.findParent = function findParent(callback) {
	    var path = this;
	    while (path) {
	      if (callback(path.node, path)) return path;
	      path = path.parentPath;
	    }
	    return null;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.queueNode = function queueNode(path) {
	    var _arr4 = this.contexts;
	
	    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
	      var context = _arr4[_i4];
	      if (context.queue) {
	        context.queue.push(path);
	      }
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.insertBefore = function insertBefore(nodes) {
	    nodes = this._verifyNodeList(nodes);
	
	    if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
	      return this.parentPath.insertBefore(nodes);
	    } else if (this.isPreviousType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
	      if (this.node) nodes.push(this.node);
	      this.replaceExpressionWithStatements(nodes);
	    } else if (this.isPreviousType("Statement") || !this.type) {
	      this._maybePopFromStatements(nodes);
	      if (Array.isArray(this.container)) {
	        this._containerInsertBefore(nodes);
	      } else if (this.isStatementOrBlock()) {
	        if (this.node) nodes.push(this.node);
	        this.node = this.container[this.key] = t.blockStatement(nodes);
	      } else {
	        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
	      }
	    } else {
	      throw new Error("No clue what to do with this node type.");
	    }
	  };
	
	  TraversalPath.prototype._containerInsert = function _containerInsert(from, nodes) {
	    this.updateSiblingKeys(from, nodes.length);
	
	    var paths = [];
	
	    for (var i = 0; i < nodes.length; i++) {
	      var to = from + i;
	      var node = nodes[i];
	      this.container.splice(to, 0, node);
	
	      if (this.context) {
	        var path = this.context.create(this.parent, this.container, to);
	        paths.push(path);
	        this.queueNode(path);
	      } else {
	        paths.push(TraversalPath.get(this, node, this.container, to));
	      }
	    }
	
	    return paths;
	  };
	
	  TraversalPath.prototype._containerInsertBefore = function _containerInsertBefore(nodes) {
	    return this._containerInsert(this.key, nodes);
	  };
	
	  TraversalPath.prototype._containerInsertAfter = function _containerInsertAfter(nodes) {
	    return this._containerInsert(this.key + 1, nodes);
	  };
	
	  TraversalPath.prototype._maybePopFromStatements = function _maybePopFromStatements(nodes) {
	    var last = nodes[nodes.length - 1];
	    if (t.isExpressionStatement(last) && t.isIdentifier(last.expression) && !this.isCompletionRecord()) {
	      nodes.pop();
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.isCompletionRecord = function isCompletionRecord() {
	    var path = this;
	
	    do {
	      var container = path.container;
	
	      if (path.isFunction()) {
	        return false;
	      }
	
	      if (Array.isArray(container) && path.key !== container.length - 1) {
	        return false;
	      }
	    } while ((path = path.parentPath) && !path.isProgram());
	
	    return true;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.isStatementOrBlock = function isStatementOrBlock() {
	    if (t.isLabeledStatement(this.parent) || t.isBlockStatement(this.container)) {
	      return false;
	    } else {
	      return (0, _lodashCollectionIncludes2["default"])(t.STATEMENT_OR_BLOCK_KEYS, this.key);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.insertAfter = function insertAfter(nodes) {
	    nodes = this._verifyNodeList(nodes);
	
	    if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
	      return this.parentPath.insertAfter(nodes);
	    } else if (this.isPreviousType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
	      if (this.node) {
	        var temp = this.scope.generateDeclaredUidIdentifier();
	        nodes.unshift(t.expressionStatement(t.assignmentExpression("=", temp, this.node)));
	        nodes.push(t.expressionStatement(temp));
	      }
	      this.replaceExpressionWithStatements(nodes);
	    } else if (this.isPreviousType("Statement") || !this.type) {
	      this._maybePopFromStatements(nodes);
	      if (Array.isArray(this.container)) {
	        this._containerInsertAfter(nodes);
	      } else if (this.isStatementOrBlock()) {
	        if (this.node) nodes.unshift(this.node);
	        this.node = this.container[this.key] = t.blockStatement(nodes);
	      } else {
	        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
	      }
	    } else {
	      throw new Error("No clue what to do with this node type.");
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.updateSiblingKeys = function updateSiblingKeys(fromIndex, incrementBy) {
	    var paths = this.container._paths;
	    for (var i = 0; i < paths.length; i++) {
	      var path = paths[i];
	      if (path.key >= fromIndex) {
	        path.key += incrementBy;
	      }
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.setData = function setData(key, val) {
	    return this.data[key] = val;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.getData = function getData(key, def) {
	    var val = this.data[key];
	    if (!val && def) val = this.data[key] = def;
	    return val;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.setScope = function setScope(file) {
	    if (this.opts && this.opts.noScope) return;
	
	    var target = this.context || this.parentPath;
	    this.scope = TraversalPath.getScope(this, target && target.scope, file);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.setContext = function setContext(context, file) {
	    this.shouldSkip = false;
	    this.shouldStop = false;
	    this.removed = false;
	
	    if (context) {
	      this.context = context;
	      this.state = context.state;
	      this.opts = context.opts;
	    }
	
	    var log = file && this.type === "Program";
	    if (log) file.log.debug("Start scope building");
	    this.setScope(file);
	    if (log) file.log.debug("End scope building");
	
	    return this;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.update = function update() {
	    if (this.node === this.container[this.key]) return;
	
	    // grrr, path key is out of sync. this is likely due to a modification to the AST
	    // not through our path APIs
	
	    if (Array.isArray(this.container)) {
	      for (var i = 0; i < this.container.length; i++) {
	        if (this.container[i] === this.node) {
	          return this.setKey(i);
	        }
	      }
	    } else {
	      for (var key in this.container) {
	        if (this.container[key] === this.node) {
	          return this.setKey(key);
	        }
	      }
	    }
	
	    throw new Error(messages.get("lostTrackNodePath"));
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.shiftContext = function shiftContext() {
	    this.contexts.shift();
	    this.setContext(this.contexts[0]);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.unshiftContext = function unshiftContext(context) {
	    this.contexts.unshift(context);
	    this.setContext(context);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.setup = function setup(parentPath, key) {
	    this.parentPath = parentPath || this.parentPath;
	    this.setKey(key);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.setKey = function setKey(key) {
	    this.key = key;
	    this.node = this.container[this.key];
	    this.type = this.node && this.node.type;
	  };
	
	  /**
	   * Share comments amongst siblings.
	   */
	
	  TraversalPath.prototype.shareCommentsWithSiblings = function shareCommentsWithSiblings() {
	    var node = this.node;
	    if (!node) return;
	
	    var trailing = node.trailingComments;
	    var leading = node.leadingComments;
	    if (!trailing && !leading) return;
	
	    var prev = this.getSibling(this.key - 1);
	    var next = this.getSibling(this.key + 1);
	
	    if (!prev.node) prev = next;
	    if (!next.node) next = prev;
	
	    prev.giveComments("trailing", leading);
	    next.giveComments("leading", trailing);
	  };
	
	  /**
	   * Give node `comments` of the specified `type`.
	   */
	
	  TraversalPath.prototype.giveComments = function giveComments(type, comments) {
	    if (!comments) return;
	
	    var node = this.node;
	    if (!node) return;
	
	    var key = "" + type + "Comments";
	
	    if (node[key]) {
	      node[key] = node[key].concat(comments);
	    } else {
	      node[key] = comments;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.remove = function remove() {
	    this.shareCommentsWithSiblings();
	    this._remove();
	    this.removed = true;
	
	    var parentPath = this.parentPath;
	    var parent = this.parent;
	    if (!parentPath) return;
	
	    // we've just removed the last declarator of a variable declaration so there's no point in
	    // keeping it
	    if (parentPath.isVariableDeclaration() && parent.declarations.length === 0) {
	      return parentPath.remove();
	    }
	
	    // we're the child of an expression statement so we should remove the parent
	    if (parentPath.isExpressionStatement()) {
	      return parentPath.remove();
	    }
	
	    // we've just removed the second element of a sequence expression so let's turn that sequence
	    // expression into a regular expression
	    if (parentPath.isSequenceExpression() && parent.expressions.length === 1) {
	      parentPath.replaceWith(parent.expressions[0]);
	    }
	
	    // we're in a binary expression, better remove it and replace it with the last expression
	    if (parentPath.isBinary()) {
	      if (this.key === "left") {
	        parentPath.replaceWith(parent.right);
	      } else {
	        // key === "right"
	        parentPath.replaceWith(parent.left);
	      }
	    }
	  };
	
	  TraversalPath.prototype._remove = function _remove() {
	    if (Array.isArray(this.container)) {
	      this.container.splice(this.key, 1);
	      this.updateSiblingKeys(this.key, -1);
	    } else {
	      this.container[this.key] = null;
	    }
	    this.node = null;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.skip = function skip() {
	    this.shouldSkip = true;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.stop = function stop() {
	    this.shouldStop = true;
	    this.shouldSkip = true;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.errorWithNode = function errorWithNode(msg) {
	    var Error = arguments[1] === undefined ? SyntaxError : arguments[1];
	
	    var loc = this.node.loc.start;
	    var err = new Error("Line " + loc.line + ": " + msg);
	    err.loc = loc;
	    return err;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.replaceInline = function replaceInline(nodes) {
	    if (Array.isArray(nodes)) {
	      if (Array.isArray(this.container)) {
	        nodes = this._verifyNodeList(nodes);
	        this._containerInsertAfter(nodes);
	        return this.remove();
	      } else {
	        return this.replaceWithMultiple(nodes);
	      }
	    } else {
	      return this.replaceWith(nodes);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype._verifyNodeList = function _verifyNodeList(nodes) {
	    if (nodes.constructor !== Array) {
	      nodes = [nodes];
	    }
	
	    for (var i = 0; i < nodes.length; i++) {
	      var node = nodes[i];
	      if (!node) {
	        throw new Error("Node list has falsy node with the index of " + i);
	      } else if (typeof node !== "object") {
	        throw new Error("Node list contains a non-object node with the index of " + i);
	      } else if (!node.type) {
	        throw new Error("Node list contains a node without a type with the index of " + i);
	      }
	    }
	
	    return nodes;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.unshiftContainer = function unshiftContainer(containerKey, nodes) {
	    nodes = this._verifyNodeList(nodes);
	
	    // get the first path and insert our nodes before it, if it doesn't exist then it
	    // doesn't matter, our nodes will be inserted anyway
	
	    var container = this.node[containerKey];
	    var path = TraversalPath.get(this, this.node, container, 0);
	
	    return path.insertBefore(nodes);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.pushContainer = function pushContainer(containerKey, nodes) {
	    nodes = this._verifyNodeList(nodes);
	
	    // get an invisible path that represents the last node + 1 and replace it with our
	    // nodes, effectively inlining it
	
	    var container = this.node[containerKey];
	    var i = container.length;
	    var path = TraversalPath.get(this, this.node, container, i);
	
	    return path.replaceWith(nodes, true);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.replaceWithMultiple = function replaceWithMultiple(nodes) {
	    nodes = this._verifyNodeList(nodes);
	    t.inheritsComments(nodes[0], this.node);
	    this.node = this.container[this.key] = null;
	    this.insertAfter(nodes);
	    if (!this.node) this.remove();
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.replaceWithSourceString = function replaceWithSourceString(replacement) {
	    try {
	      replacement = "(" + replacement + ")";
	      replacement = (0, _helpersParse2["default"])(replacement);
	    } catch (err) {
	      var loc = err.loc;
	      if (loc) {
	        err.message += " - make sure this is an expression.";
	        err.message += "\n" + (0, _helpersCodeFrame2["default"])(replacement, loc.line, loc.column + 1);
	      }
	      throw err;
	    }
	
	    replacement = replacement.program.body[0].expression;
	    _index2["default"].removeProperties(replacement);
	    return this.replaceWith(replacement);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.replaceWith = function replaceWith(replacement, whateverAllowed) {
	    if (this.removed) {
	      throw new Error("You can't replace this node, we've already removed it");
	    }
	
	    if (!replacement) {
	      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
	    }
	
	    if (this.node === replacement) {
	      return;
	    }
	
	    // normalise inserting an entire AST
	    if (t.isProgram(replacement)) {
	      replacement = replacement.body;
	      whateverAllowed = true;
	    }
	
	    if (Array.isArray(replacement)) {
	      if (whateverAllowed) {
	        return this.replaceWithMultiple(replacement);
	      } else {
	        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
	      }
	    }
	
	    if (typeof replacement === "string") {
	      if (whateverAllowed) {
	        return this.replaceWithSourceString(replacement);
	      } else {
	        throw new Error("Don't use `path.replaceWith()` with a string, use `path.replaceWithSourceString()`");
	      }
	    }
	
	    // replacing a statement with an expression so wrap it in an expression statement
	    if (this.isPreviousType("Statement") && t.isExpression(replacement) && !this.canHaveVariableDeclarationOrExpression()) {
	      replacement = t.expressionStatement(replacement);
	    }
	
	    // replacing an expression with a statement so let's explode it
	    if (this.isPreviousType("Expression") && t.isStatement(replacement)) {
	      return this.replaceExpressionWithStatements([replacement]);
	    }
	
	    var oldNode = this.node;
	    if (oldNode) t.inheritsComments(replacement, oldNode);
	
	    // replace the node
	    this.node = this.container[this.key] = replacement;
	    this.type = replacement.type;
	
	    // potentially create new scope
	    this.setScope();
	  };
	
	  /**
	   * This checks whether or now we're in one of the following positions:
	   *
	   *   for (KEY in right);
	   *   for (KEY;;);
	   *
	   * This is because these spots allow VariableDeclarations AND normal expressions so we need to tell the
	   * path replacement that it's ok to replace this with an expression.
	   */
	
	  TraversalPath.prototype.canHaveVariableDeclarationOrExpression = function canHaveVariableDeclarationOrExpression() {
	    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.getStatementParent = function getStatementParent() {
	    var path = this;
	
	    do {
	      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
	        break;
	      } else {
	        path = path.parentPath;
	      }
	    } while (path);
	
	    if (path && (path.isProgram() || path.isFile())) {
	      throw new Error("File/Program node, we can't possibly find a statement parent to this");
	    }
	
	    return path;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.getCompletionRecords = function getCompletionRecords() {
	    var paths = [];
	
	    var add = function add(path) {
	      if (path) paths = paths.concat(path.getCompletionRecords());
	    };
	
	    if (this.isIfStatement()) {
	      add(this.get("consequent"));
	      add(this.get("alternate"));
	    } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
	      add(this.get("body"));
	    } else if (this.isProgram() || this.isBlockStatement()) {
	      add(this.get("body").pop());
	    } else if (this.isFunction()) {
	      return this.get("body").getCompletionRecords();
	    } else {
	      paths.push(this);
	    }
	
	    return paths;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.replaceExpressionWithStatements = function replaceExpressionWithStatements(nodes) {
	    var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);
	
	    if (toSequenceExpression) {
	      return this.replaceWith(toSequenceExpression);
	    } else {
	      var container = t.functionExpression(null, [], t.blockStatement(nodes));
	      container.shadow = true;
	
	      this.replaceWith(t.callExpression(container, []));
	      this.traverse(hoistVariablesVisitor);
	
	      // add implicit returns to all ending expression statements
	      var last = this.get("callee").getCompletionRecords();
	      for (var i = 0; i < last.length; i++) {
	        var lastNode = last[i];
	        if (lastNode.isExpressionStatement()) {
	          var loop = lastNode.findParent(function (node, path) {
	            return path.isLoop();
	          });
	          if (loop) {
	            var uid = this.get("callee").scope.generateDeclaredUidIdentifier("ret");
	            this.get("callee.body").pushContainer("body", t.returnStatement(uid));
	            lastNode.get("expression").replaceWith(t.assignmentExpression("=", uid, lastNode.node.expression));
	          } else {
	            lastNode.replaceWith(t.returnStatement(lastNode.node.expression));
	          }
	        }
	      }
	
	      return this.node;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.call = function call(key) {
	    var node = this.node;
	    if (!node) return;
	
	    var opts = this.opts;
	    if (!opts[key] && !opts[node.type]) return;
	
	    var fns = [].concat(opts[key]);
	    if (opts[node.type]) fns = fns.concat(opts[node.type][key]);
	
	    var _arr5 = fns;
	    for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
	      var fn = _arr5[_i5];
	      if (!fn) continue;
	
	      var node = this.node;
	      if (!node) return;
	
	      var previousType = this.type;
	
	      // call the function with the params (node, parent, scope, state)
	      var replacement = fn.call(this, node, this.parent, this.scope, this.state);
	
	      if (replacement) {
	        this.replaceWith(replacement, true);
	      }
	
	      if (this.shouldStop || this.shouldSkip || this.removed) return;
	
	      if (previousType !== this.type) {
	        this.queueNode(this);
	        return;
	      }
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.isBlacklisted = function isBlacklisted() {
	    var blacklist = this.opts.blacklist;
	    return blacklist && blacklist.indexOf(this.node.type) > -1;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.visit = function visit() {
	    if (this.isBlacklisted()) return false;
	    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) return false;
	
	    this.call("enter");
	
	    if (this.shouldSkip) {
	      return this.shouldStop;
	    }
	
	    var node = this.node;
	    var opts = this.opts;
	
	    if (node) {
	      if (Array.isArray(node)) {
	        // traverse over these replacement nodes we purposely don't call exitNode
	        // as the original node has been destroyed
	        for (var i = 0; i < node.length; i++) {
	          _index2["default"].node(node[i], opts, this.scope, this.state, this);
	        }
	      } else {
	        _index2["default"].node(node, opts, this.scope, this.state, this);
	        this.call("exit");
	      }
	    }
	
	    return this.shouldStop;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.getSibling = function getSibling(key) {
	    return TraversalPath.get(this.parentPath, this.parent, this.container, key, this.file);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.get = function get(key) {
	    var parts = key.split(".");
	    if (parts.length === 1) {
	      // "foo"
	      return this._getKey(key);
	    } else {
	      // "foo.bar"
	      return this._getPattern(parts);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype._getKey = function _getKey(key) {
	    var _this = this;
	
	    var node = this.node;
	    var container = node[key];
	
	    if (Array.isArray(container)) {
	      // requested a container so give them all the paths
	      return container.map(function (_, i) {
	        return TraversalPath.get(_this, node, container, i).setContext();
	      });
	    } else {
	      return TraversalPath.get(this, node, node, key).setContext();
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype._getPattern = function _getPattern(parts) {
	    var path = this;
	    var _arr6 = parts;
	    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
	      var part = _arr6[_i6];
	      if (part === ".") {
	        path = path.parentPath;
	      } else {
	        if (Array.isArray(path)) {
	          path = path[part];
	        } else {
	          path = path.get(part);
	        }
	      }
	    }
	    return path;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.has = function has(key) {
	    var val = this.node[key];
	    if (val && Array.isArray(val)) {
	      return !!val.length;
	    } else {
	      return !!val;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.is = function is(key) {
	    return this.has(key);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.isnt = function isnt(key) {
	    return !this.has(key);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.equals = function equals(key, value) {
	    return this.node[key] === value;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.getTypeAnnotation = function getTypeAnnotation() {
	    if (this.typeInfo) {
	      return this.typeInfo;
	    }
	
	    var info = this.typeInfo = {
	      inferred: false,
	      annotation: null
	    };
	
	    var type = this.node && this.node.typeAnnotation;
	
	    if (!type) {
	      info.inferred = true;
	      type = this.inferType(this);
	    }
	
	    if (type) {
	      if (t.isTypeAnnotation(type)) type = type.typeAnnotation;
	      info.annotation = type;
	    }
	
	    return info;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.resolve = function resolve() {
	    if (this.isVariableDeclarator()) {
	      if (this.get("id").isIdentifier()) {
	        return this.get("init").resolve();
	      } else {}
	    } else if (this.isIdentifier()) {
	      var binding = this.scope.getBinding(this.node.name);
	      if (!binding || !binding.constant) return;
	
	      // todo: take into consideration infinite recursion #1149
	      return;
	
	      if (binding.path === this) {
	        return this;
	      } else {
	        return binding.path.resolve();
	      }
	    } else if (this.isMemberExpression()) {
	      // this is dangerous, as non-direct target assignments will mutate it's state
	      // making this resolution inaccurate
	
	      var targetKey = this.toComputedKey();
	      if (!t.isLiteral(targetKey)) return;
	      var targetName = targetKey.value;
	
	      var target = this.get("object").resolve();
	      if (!target || !target.isObjectExpression()) return;
	
	      var props = target.get("properties");
	      for (var i = 0; i < props.length; i++) {
	        var prop = props[i];
	        if (!prop.isProperty()) continue;
	
	        var key = prop.get("key");
	
	        // { foo: obj }
	        var match = prop.isnt("computed") && key.isIdentifier({ name: targetName });
	
	        // { "foo": "obj" } or { ["foo"]: "obj" }
	        match = match || key.isLiteral({ value: targetName });
	
	        if (match) return prop.get("value");
	      }
	    } else {
	      return this;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.inferType = function inferType(path) {
	    path = path.resolve();
	    if (!path) return;
	
	    if (path.isPreviousType("RestElement") || path.parentPath.isPreviousType("RestElement") || path.isPreviousType("ArrayExpression")) {
	      return t.genericTypeAnnotation(t.identifier("Array"));
	    }
	
	    if (path.parentPath.isPreviousType("TypeCastExpression")) {
	      return path.parentPath.node.typeAnnotation;
	    }
	
	    if (path.isPreviousType("TypeCastExpression")) {
	      return path.node.typeAnnotation;
	    }
	
	    if (path.isPreviousType("ObjectExpression")) {
	      return t.genericTypeAnnotation(t.identifier("Object"));
	    }
	
	    if (path.isPreviousType("Function")) {
	      return t.identifier("Function");
	    }
	
	    if (path.isPreviousType("Literal")) {
	      var value = path.node.value;
	      if ((0, _lodashLangIsString2["default"])(value)) return t.stringTypeAnnotation();
	      if ((0, _lodashLangIsNumber2["default"])(value)) return t.numberTypeAnnotation();
	      if ((0, _lodashLangIsBoolean2["default"])(value)) return t.booleanTypeAnnotation();
	    }
	
	    if (path.isPreviousType("CallExpression")) {
	      var callee = path.get("callee").resolve();
	      if (callee && callee.isPreviousType("Function")) return callee.node.returnType;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.isPreviousType = function isPreviousType(type) {
	    return t.isType(this.type, type);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.isTypeGeneric = function isTypeGeneric(genericName) {
	    var opts = arguments[1] === undefined ? {} : arguments[1];
	
	    var typeInfo = this.getTypeAnnotation();
	    var type = typeInfo.annotation;
	    if (!type) return false;
	
	    if (typeInfo.inferred && opts.inference === false) {
	      return false;
	    }
	
	    if (!t.isGenericTypeAnnotation(type) || !t.isIdentifier(type.id, { name: genericName })) {
	      return false;
	    }
	
	    if (opts.requireTypeParameters && !type.typeParameters) {
	      return false;
	    }
	
	    return true;
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.getBindingIdentifiers = function getBindingIdentifiers() {
	    return t.getBindingIdentifiers(this.node);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.traverse = function traverse(visitor, state) {
	    if (!this.scope) console.log(this.contexts);
	    (0, _index2["default"])(this.node, visitor, this.scope, state, this);
	  };
	
	  /**
	   * Description
	   */
	
	  TraversalPath.prototype.hoist = function hoist() {
	    var scope = arguments[0] === undefined ? this.scope : arguments[0];
	
	    var hoister = new _hoister2["default"](this, scope);
	    return hoister.run();
	  };
	
	  /**
	   * Match the current node if it matches the provided `pattern`.
	   *
	   * For example, given the match `React.createClass` it would match the
	   * parsed nodes of `React.createClass` and `React["createClass"]`.
	   */
	
	  TraversalPath.prototype.matchesPattern = function matchesPattern(pattern, allowPartial) {
	    var parts = pattern.split(".");
	
	    // not a member expression
	    if (!this.isMemberExpression()) return false;
	
	    var search = [this.node];
	    var i = 0;
	
	    function matches(name) {
	      var part = parts[i];
	      return part === "*" || name === part;
	    }
	
	    while (search.length) {
	      var node = search.shift();
	
	      if (allowPartial && i === parts.length) {
	        return true;
	      }
	
	      if (t.isIdentifier(node)) {
	        // this part doesn't match
	        if (!matches(node.name)) return false;
	      } else if (t.isLiteral(node)) {
	        // this part doesn't match
	        if (!matches(node.value)) return false;
	      } else if (t.isMemberExpression(node)) {
	        if (node.computed && !t.isLiteral(node.property)) {
	          // we can't deal with this
	          return false;
	        } else {
	          search.push(node.object);
	          search.push(node.property);
	          continue;
	        }
	      } else {
	        // we can't deal with this
	        return false;
	      }
	
	      // too many parts
	      if (++i > parts.length) {
	        return false;
	      }
	    }
	
	    return true;
	  };
	
	  return TraversalPath;
	})();
	
	exports["default"] = TraversalPath;
	
	(0, _lodashObjectAssign2["default"])(TraversalPath.prototype, __webpack_require__(/*! ./evaluation */ 243));
	(0, _lodashObjectAssign2["default"])(TraversalPath.prototype, __webpack_require__(/*! ./conversion */ 244));
	
	var _loop = function (type) {
	  if (type[0] === "_") return "continue";
	
	  TraversalPath.prototype["is" + type] = function (opts) {
	    return virtualTypes[type].checkPath(this, opts);
	  };
	};
	
	for (var type in virtualTypes) {
	  var _ret = _loop(type);
	
	  if (_ret === "continue") continue;
	}
	
	var _arr2 = t.TYPES;
	
	var _loop2 = function () {
	  var type = _arr2[_i2];
	  var typeKey = "is" + type;
	  TraversalPath.prototype[typeKey] = function (opts) {
	    return t[typeKey](this.node, opts);
	  };
	};
	
	for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	  _loop2();
	}
	module.exports = exports["default"];
	
	// otherwise it's a request for a destructuring declarator and i'm not
	// ready to resolve those just yet

/***/ },
/* 154 */
/*!******************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/visitors.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.explode = explode;
	exports.verify = verify;
	exports.merge = merge;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _pathVirtualTypes = __webpack_require__(/*! ./path/virtual-types */ 155);
	
	var virtualTypes = _interopRequireWildcard(_pathVirtualTypes);
	
	var _messages = __webpack_require__(/*! ../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var _esquery = __webpack_require__(/*! esquery */ 205);
	
	var _esquery2 = _interopRequireDefault(_esquery);
	
	function explode(visitor, mergeConflicts) {
	  if (visitor._exploded) return visitor;
	  visitor._exploded = true;
	
	  // make sure there's no __esModule type since this is because we're using loose mode
	  // and it sets __esModule to be enumerable on all modules :(
	  delete visitor.__esModule;
	
	  if (visitor.queries) {
	    ensureEntranceObjects(visitor.queries);
	    addQueries(visitor);
	    delete visitor.queries;
	  }
	
	  // ensure visitors are objects
	  ensureEntranceObjects(visitor);
	
	  // add type wrappers
	  for (var nodeType in visitor) {
	    if (shouldIgnoreKey(nodeType)) continue;
	
	    var wrapper = virtualTypes[nodeType];
	    if (!wrapper) continue;
	
	    // wrap all the functions
	    var fns = visitor[nodeType];
	    for (var type in fns) {
	      fns[type] = wrapCheck(wrapper, fns[type]);
	    }
	
	    // clear it from the visitor
	    delete visitor[nodeType];
	
	    if (wrapper.types) {
	      var _arr = wrapper.types;
	
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var type = _arr[_i];
	        // merge the visitor if necessary or just put it back in
	        if (visitor[type]) {
	          mergePair(visitor[type], fns);
	        } else {
	          visitor[type] = fns;
	        }
	      }
	    } else {
	      mergePair(visitor, fns);
	    }
	  }
	
	  // add aliases
	  for (var nodeType in visitor) {
	    if (shouldIgnoreKey(nodeType)) continue;
	
	    var fns = visitor[nodeType];
	
	    var aliases = t.FLIPPED_ALIAS_KEYS[nodeType];
	    if (!aliases) continue;
	
	    // clear it form the visitor
	    delete visitor[nodeType];
	
	    var _arr2 = aliases;
	    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	      var alias = _arr2[_i2];
	      var existing = visitor[alias];
	      if (existing) {
	        if (mergeConflicts) {
	          mergePair(existing, fns);
	        }
	      } else {
	        visitor[alias] = fns;
	      }
	    }
	  }
	
	  return visitor;
	}
	
	function verify(visitor) {
	  if (visitor._verified) return;
	
	  if (typeof visitor === "function") {
	    throw new Error(messages.get("traverseVerifyRootFunction"));
	  }
	
	  for (var nodeType in visitor) {
	    if (shouldIgnoreKey(nodeType)) continue;
	
	    if (t.TYPES.indexOf(nodeType) < 0 && !virtualTypes[nodeType]) {
	      throw new Error(messages.get("traverseVerifyNodeType", nodeType));
	    }
	
	    var visitors = visitor[nodeType];
	    if (typeof visitors === "object") {
	      for (var visitorKey in visitors) {
	        if (visitorKey === "enter" || visitorKey === "exit") continue;
	        throw new Error(messages.get("traverseVerifyVisitorProperty", nodeType, visitorKey));
	      }
	    }
	  }
	
	  visitor._verified = true;
	}
	
	function merge(visitors) {
	  var rootVisitor = {};
	
	  var _arr3 = visitors;
	  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	    var visitor = _arr3[_i3];
	    for (var type in visitor) {
	      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
	      mergePair(nodeVisitor, visitor[type]);
	    }
	  }
	
	  return rootVisitor;
	}
	
	function ensureEntranceObjects(obj) {
	  for (var key in obj) {
	    if (shouldIgnoreKey(key)) continue;
	
	    var fns = obj[key];
	    if (typeof fns === "function") {
	      obj[key] = { enter: fns };
	    }
	  }
	}
	
	function addQueries(visitor) {
	  for (var selector in visitor.queries) {
	    var fns = visitor.queries[selector];
	    addSelector(visitor, selector, fns);
	  }
	}
	
	function addSelector(visitor, selector, fns) {
	  selector = _esquery2["default"].parse(selector);
	
	  var _loop = function () {
	    var fn = fns[key];
	    fns[key] = function (node) {
	      if (_esquery2["default"].matches(node, selector, this.getAncestry())) {
	        return fn.apply(this, arguments);
	      }
	    };
	  };
	
	  for (var key in fns) {
	    _loop();
	  }
	
	  mergePair(visitor, fns);
	}
	
	function wrapCheck(wrapper, fn) {
	  return function () {
	    if (wrapper.checkPath(this)) {
	      return fn.apply(this, arguments);
	    }
	  };
	}
	
	function shouldIgnoreKey(key) {
	  // internal/hidden key
	  if (key[0] === "_") return true;
	
	  // ignore function keys
	  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
	
	  // ignore other options
	  if (key === "blacklist" || key === "noScope") return true;
	
	  return false;
	}
	
	function mergePair(dest, src) {
	  for (var key in src) {
	    dest[key] = (dest[key] || []).concat(src[key]);
	  }
	}

/***/ },
/* 155 */
/*!****************************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/path/virtual-types.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var ReferencedIdentifier = {
	  types: ["Identifier", "JSXIdentifier"],
	  checkPath: function checkPath(path, opts) {
	    return t.isReferencedIdentifier(path.node, path.parent, opts);
	  }
	};
	
	exports.ReferencedIdentifier = ReferencedIdentifier;
	var Scope = {
	  types: ["Scopable"],
	  checkPath: function checkPath(path) {
	    return t.isScope(path.node, path.parent);
	  }
	};
	
	exports.Scope = Scope;
	var Referenced = {
	  checkPath: function checkPath(path) {
	    return t.isReferenced(path.node, path.parent);
	  }
	};
	
	exports.Referenced = Referenced;
	var BlockScoped = {
	  checkPath: function checkPath(path) {
	    return t.isBlockScoped(path.node);
	  }
	};
	
	exports.BlockScoped = BlockScoped;
	var Var = {
	  types: ["VariableDeclaration"],
	  checkPath: function checkPath(path) {
	    return t.isVar(path.node);
	  }
	};
	exports.Var = Var;

/***/ },
/* 156 */
/*!***********************************************!*\
  !*** ./~/babel-core/lib/babel/types/index.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	/**
	 * Returns whether `node` is of given `type`.
	 *
	 * For better performance, use this instead of `is[Type]` when `type` is unknown.
	 * Optionally, pass `skipAliasCheck` to directly compare `node.type` with `type`.
	 */
	
	exports.is = is;
	exports.isType = isType;
	
	/*
	 * Description
	 */
	
	exports.shallowEqual = shallowEqual;
	
	/**
	 * Description
	 */
	
	exports.appendToMemberExpression = appendToMemberExpression;
	
	/**
	 * Description
	 */
	
	exports.prependToMemberExpression = prependToMemberExpression;
	
	/**
	 * Description
	 */
	
	exports.ensureBlock = ensureBlock;
	
	/**
	 * Description
	 */
	
	exports.clone = clone;
	
	/**
	 * Description
	 */
	
	exports.cloneDeep = cloneDeep;
	
	/**
	 * Build a function that when called will return whether or not the
	 * input `node` `MemberExpression` matches the input `match`.
	 *
	 * For example, given the match `React.createClass` it would match the
	 * parsed nodes of `React.createClass` and `React["createClass"]`.
	 */
	
	exports.buildMatchMemberExpression = buildMatchMemberExpression;
	
	/**
	 * Description
	 */
	
	exports.removeComments = removeComments;
	
	/**
	 * Description
	 */
	
	exports.inheritsComments = inheritsComments;
	
	/**
	 * Description
	 */
	
	exports.inherits = inherits;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _toFastProperties = __webpack_require__(/*! to-fast-properties */ 157);
	
	var _toFastProperties2 = _interopRequireDefault(_toFastProperties);
	
	var _lodashArrayCompact = __webpack_require__(/*! lodash/array/compact */ 158);
	
	var _lodashArrayCompact2 = _interopRequireDefault(_lodashArrayCompact);
	
	var _lodashObjectAssign = __webpack_require__(/*! lodash/object/assign */ 139);
	
	var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _lodashArrayUniq = __webpack_require__(/*! lodash/array/uniq */ 165);
	
	var _lodashArrayUniq2 = _interopRequireDefault(_lodashArrayUniq);
	
	var t = exports;
	
	/**
	 * Registers `is[Type]` and `assert[Type]` generated functions for a given `type`.
	 * Pass `skipAliasCheck` to force it to directly compare `node.type` with `type`.
	 */
	
	function registerType(type, skipAliasCheck) {
	  var is = t["is" + type] = function (node, opts) {
	    return t.is(type, node, opts, skipAliasCheck);
	  };
	
	  t["assert" + type] = function (node, opts) {
	    opts = opts || {};
	    if (!is(node, opts)) {
	      throw new Error("Expected type " + JSON.stringify(type) + " with option " + JSON.stringify(opts));
	    }
	  };
	}
	
	var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
	exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
	var NATIVE_TYPE_NAMES = ["Array", "ArrayBuffer", "Boolean", "DataView", "Date", "Error", "EvalError", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Number", "Object", "Proxy", "Promise", "RangeError", "ReferenceError", "RegExp", "Set", "String", "Symbol", "SyntaxError", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "URIError", "WeakMap", "WeakSet"];
	exports.NATIVE_TYPE_NAMES = NATIVE_TYPE_NAMES;
	var FLATTENABLE_KEYS = ["body", "expressions"];
	exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
	var FOR_INIT_KEYS = ["left", "init"];
	exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
	var COMMENT_KEYS = ["leadingComments", "trailingComments"];
	
	exports.COMMENT_KEYS = COMMENT_KEYS;
	var VISITOR_KEYS = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./visitor-keys\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	exports.VISITOR_KEYS = VISITOR_KEYS;
	var BUILDER_KEYS = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./builder-keys\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	exports.BUILDER_KEYS = BUILDER_KEYS;
	var ALIAS_KEYS = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./alias-keys\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	exports.ALIAS_KEYS = ALIAS_KEYS;
	t.FLIPPED_ALIAS_KEYS = {};
	
	(0, _lodashCollectionEach2["default"])(t.VISITOR_KEYS, function (keys, type) {
	  registerType(type, true);
	});
	
	(0, _lodashCollectionEach2["default"])(t.ALIAS_KEYS, function (aliases, type) {
	  (0, _lodashCollectionEach2["default"])(aliases, function (alias) {
	    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];
	    types.push(type);
	  });
	});
	
	(0, _lodashCollectionEach2["default"])(t.FLIPPED_ALIAS_KEYS, function (types, type) {
	  t[type.toUpperCase() + "_TYPES"] = types;
	  registerType(type, false);
	});
	
	var TYPES = Object.keys(t.VISITOR_KEYS).concat(Object.keys(t.FLIPPED_ALIAS_KEYS));exports.TYPES = TYPES;
	
	function is(type, node, opts, skipAliasCheck) {
	  if (!node) return false;
	
	  var matches = isType(node.type, type);
	  if (!matches) return false;
	
	  if (typeof opts === "undefined") {
	    return true;
	  } else {
	    return t.shallowEqual(node, opts);
	  }
	}
	
	function isType(nodeType, targetType) {
	  if (nodeType === targetType) return true;
	
	  var aliases = t.FLIPPED_ALIAS_KEYS[targetType];
	  if (aliases) {
	    if (aliases[0] === nodeType) return true;
	
	    var _arr = aliases;
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var alias = _arr[_i];
	      if (nodeType === alias) return true;
	    }
	  }
	
	  return false;
	}
	
	(0, _lodashCollectionEach2["default"])(t.VISITOR_KEYS, function (keys, type) {
	  if (t.BUILDER_KEYS[type]) return;
	
	  var defs = {};
	  (0, _lodashCollectionEach2["default"])(keys, function (key) {
	    defs[key] = null;
	  });
	  t.BUILDER_KEYS[type] = defs;
	});
	
	(0, _lodashCollectionEach2["default"])(t.BUILDER_KEYS, function (keys, type) {
	  t[type[0].toLowerCase() + type.slice(1)] = function () {
	    var node = {};
	    node.start = null;
	    node.type = type;
	
	    var i = 0;
	
	    for (var key in keys) {
	      var arg = arguments[i++];
	      if (arg === undefined) arg = keys[key];
	      node[key] = arg;
	    }
	
	    return node;
	  };
	});
	function shallowEqual(actual, expected) {
	  var keys = Object.keys(expected);
	
	  var _arr2 = keys;
	  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	    var key = _arr2[_i2];
	    if (actual[key] !== expected[key]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	function appendToMemberExpression(member, append, computed) {
	  member.object = t.memberExpression(member.object, member.property, member.computed);
	  member.property = append;
	  member.computed = !!computed;
	  return member;
	}
	
	function prependToMemberExpression(member, append) {
	  member.object = t.memberExpression(append, member.object);
	  return member;
	}
	
	function ensureBlock(node) {
	  var key = arguments[1] === undefined ? "body" : arguments[1];
	
	  return node[key] = t.toBlock(node[key], node);
	}
	
	function clone(node) {
	  var newNode = {};
	  for (var key in node) {
	    if (key[0] === "_") continue;
	    newNode[key] = node[key];
	  }
	  return newNode;
	}
	
	function cloneDeep(node) {
	  var newNode = {};
	
	  for (var key in node) {
	    if (key[0] === "_") continue;
	
	    var val = node[key];
	
	    if (val) {
	      if (val.type) {
	        val = t.cloneDeep(val);
	      } else if (Array.isArray(val)) {
	        val = val.map(t.cloneDeep);
	      }
	    }
	
	    newNode[key] = val;
	  }
	
	  return newNode;
	}
	
	function buildMatchMemberExpression(match, allowPartial) {
	  var parts = match.split(".");
	
	  return function (member) {
	    // not a member expression
	    if (!t.isMemberExpression(member)) return false;
	
	    var search = [member];
	    var i = 0;
	
	    while (search.length) {
	      var node = search.shift();
	
	      if (allowPartial && i === parts.length) {
	        return true;
	      }
	
	      if (t.isIdentifier(node)) {
	        // this part doesn't match
	        if (parts[i] !== node.name) return false;
	      } else if (t.isLiteral(node)) {
	        // this part doesn't match
	        if (parts[i] !== node.value) return false;
	      } else if (t.isMemberExpression(node)) {
	        if (node.computed && !t.isLiteral(node.property)) {
	          // we can't deal with this
	          return false;
	        } else {
	          search.push(node.object);
	          search.push(node.property);
	          continue;
	        }
	      } else {
	        // we can't deal with this
	        return false;
	      }
	
	      // too many parts
	      if (++i > parts.length) {
	        return false;
	      }
	    }
	
	    return true;
	  };
	}
	
	function removeComments(child) {
	  var _arr3 = COMMENT_KEYS;
	
	  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	    var key = _arr3[_i3];
	    delete child[key];
	  }
	  return child;
	}
	
	function inheritsComments(child, parent) {
	  if (child && parent) {
	    var _arr4 = COMMENT_KEYS;
	
	    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
	      var key = _arr4[_i4];
	      child[key] = (0, _lodashArrayUniq2["default"])((0, _lodashArrayCompact2["default"])([].concat(child[key], parent[key])));
	    }
	  }
	  return child;
	}
	
	function inherits(child, parent) {
	  if (!child || !parent) return child;
	
	  child._scopeInfo = parent._scopeInfo;
	  child.range = parent.range;
	  child.start = parent.start;
	  child.loc = parent.loc;
	  child.end = parent.end;
	
	  child.typeAnnotation = parent.typeAnnotation;
	  child.returnType = parent.returnType;
	
	  t.inheritsComments(child, parent);
	  return child;
	}
	
	(0, _toFastProperties2["default"])(t);
	(0, _toFastProperties2["default"])(t.VISITOR_KEYS);
	
	exports.__esModule = true;
	(0, _lodashObjectAssign2["default"])(t, __webpack_require__(/*! ./retrievers */ 196));
	(0, _lodashObjectAssign2["default"])(t, __webpack_require__(/*! ./validators */ 198));
	(0, _lodashObjectAssign2["default"])(t, __webpack_require__(/*! ./converters */ 200));

/***/ },
/* 157 */
/*!*************************************!*\
  !*** external "to-fast-properties" ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("to-fast-properties");

/***/ },
/* 158 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/array/compact.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Creates an array with all falsey values removed. The values `false`, `null`,
	 * `0`, `""`, `undefined`, and `NaN` are falsey.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to compact.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * _.compact([0, 1, false, 2, '', 3]);
	 * // => [1, 2, 3]
	 */
	function compact(array) {
	  var index = -1,
	      length = array ? array.length : 0,
	      resIndex = -1,
	      result = [];
	
	  while (++index < length) {
	    var value = array[index];
	    if (value) {
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = compact;


/***/ },
/* 159 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/each.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./forEach */ 160);


/***/ },
/* 160 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/forEach.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(/*! ../internal/arrayEach */ 106),
	    baseEach = __webpack_require__(/*! ../internal/baseEach */ 161),
	    createForEach = __webpack_require__(/*! ../internal/createForEach */ 164);
	
	/**
	 * Iterates over elements of `collection` invoking `iteratee` for each element.
	 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	 * (value, index|key, collection). Iteratee functions may exit iteration early
	 * by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length" property
	 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	 * may be used for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @alias each
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array|Object|string} Returns `collection`.
	 * @example
	 *
	 * _([1, 2]).forEach(function(n) {
	 *   console.log(n);
	 * }).value();
	 * // => logs each value from left to right and returns the array
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	 *   console.log(n, key);
	 * });
	 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	 */
	var forEach = createForEach(arrayEach, baseEach);
	
	module.exports = forEach;


/***/ },
/* 161 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseEach.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(/*! ./baseForOwn */ 162),
	    createBaseEach = __webpack_require__(/*! ./createBaseEach */ 163);
	
	/**
	 * The base implementation of `_.forEach` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object|string} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);
	
	module.exports = baseEach;


/***/ },
/* 162 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseForOwn.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(/*! ./baseFor */ 123),
	    keys = __webpack_require__(/*! ../object/keys */ 131);
	
	/**
	 * The base implementation of `_.forOwn` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return baseFor(object, iteratee, keys);
	}
	
	module.exports = baseForOwn;


/***/ },
/* 163 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/createBaseEach.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var getLength = __webpack_require__(/*! ./getLength */ 111),
	    isLength = __webpack_require__(/*! ./isLength */ 113),
	    toObject = __webpack_require__(/*! ./toObject */ 125);
	
	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    var length = collection ? getLength(collection) : 0;
	    if (!isLength(length)) {
	      return eachFunc(collection, iteratee);
	    }
	    var index = fromRight ? length : -1,
	        iterable = toObject(collection);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}
	
	module.exports = createBaseEach;


/***/ },
/* 164 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/createForEach.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var bindCallback = __webpack_require__(/*! ./bindCallback */ 134),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115);
	
	/**
	 * Creates a function for `_.forEach` or `_.forEachRight`.
	 *
	 * @private
	 * @param {Function} arrayFunc The function to iterate over an array.
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @returns {Function} Returns the new each function.
	 */
	function createForEach(arrayFunc, eachFunc) {
	  return function(collection, iteratee, thisArg) {
	    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	      ? arrayFunc(collection, iteratee)
	      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	  };
	}
	
	module.exports = createForEach;


/***/ },
/* 165 */
/*!*********************************************!*\
  !*** ./~/babel-core/~/lodash/array/uniq.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseCallback = __webpack_require__(/*! ../internal/baseCallback */ 166),
	    baseUniq = __webpack_require__(/*! ../internal/baseUniq */ 186),
	    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ 136),
	    sortedUniq = __webpack_require__(/*! ../internal/sortedUniq */ 192);
	
	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurence of each element
	 * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	 * for sorted arrays. If an iteratee function is provided it is invoked for
	 * each element in the array to generate the criterion by which uniqueness
	 * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	 * arguments: (value, index, array).
	 *
	 * If a property name is provided for `iteratee` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `iteratee` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias unique
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {boolean} [isSorted] Specify the array is sorted.
	 * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array} Returns the new duplicate-value-free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 *
	 * // using `isSorted`
	 * _.uniq([1, 1, 2], true);
	 * // => [1, 2]
	 *
	 * // using an iteratee function
	 * _.uniq([1, 2.5, 1.5, 2], function(n) {
	 *   return this.floor(n);
	 * }, Math);
	 * // => [1, 2.5]
	 *
	 * // using the `_.property` callback shorthand
	 * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	 * // => [{ 'x': 1 }, { 'x': 2 }]
	 */
	function uniq(array, isSorted, iteratee, thisArg) {
	  var length = array ? array.length : 0;
	  if (!length) {
	    return [];
	  }
	  if (isSorted != null && typeof isSorted != 'boolean') {
	    thisArg = iteratee;
	    iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
	    isSorted = false;
	  }
	  iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
	  return (isSorted)
	    ? sortedUniq(array, iteratee)
	    : baseUniq(array, iteratee);
	}
	
	module.exports = uniq;


/***/ },
/* 166 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseCallback.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(/*! ./baseMatches */ 167),
	    baseMatchesProperty = __webpack_require__(/*! ./baseMatchesProperty */ 178),
	    bindCallback = __webpack_require__(/*! ./bindCallback */ 134),
	    identity = __webpack_require__(/*! ../utility/identity */ 135),
	    property = __webpack_require__(/*! ../utility/property */ 184);
	
	/**
	 * The base implementation of `_.callback` which supports specifying the
	 * number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {*} [func=_.identity] The value to convert to a callback.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function baseCallback(func, thisArg, argCount) {
	  var type = typeof func;
	  if (type == 'function') {
	    return thisArg === undefined
	      ? func
	      : bindCallback(func, thisArg, argCount);
	  }
	  if (func == null) {
	    return identity;
	  }
	  if (type == 'object') {
	    return baseMatches(func);
	  }
	  return thisArg === undefined
	    ? property(func)
	    : baseMatchesProperty(func, thisArg);
	}
	
	module.exports = baseCallback;


/***/ },
/* 167 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseMatches.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(/*! ./baseIsMatch */ 168),
	    getMatchData = __webpack_require__(/*! ./getMatchData */ 175),
	    toObject = __webpack_require__(/*! ./toObject */ 125);
	
	/**
	 * The base implementation of `_.matches` which does not clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    var key = matchData[0][0],
	        value = matchData[0][1];
	
	    return function(object) {
	      if (object == null) {
	        return false;
	      }
	      return object[key] === value && (value !== undefined || (key in toObject(object)));
	    };
	  }
	  return function(object) {
	    return baseIsMatch(object, matchData);
	  };
	}
	
	module.exports = baseMatches;


/***/ },
/* 168 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseIsMatch.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(/*! ./baseIsEqual */ 169),
	    toObject = __webpack_require__(/*! ./toObject */ 125);
	
	/**
	 * The base implementation of `_.isMatch` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Array} matchData The propery names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = toObject(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	module.exports = baseIsMatch;


/***/ },
/* 169 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseIsEqual.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(/*! ./baseIsEqualDeep */ 170),
	    isObject = __webpack_require__(/*! ../lang/isObject */ 105),
	    isObjectLike = __webpack_require__(/*! ./isObjectLike */ 114);
	
	/**
	 * The base implementation of `_.isEqual` without support for `this` binding
	 * `customizer` functions.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	}
	
	module.exports = baseIsEqual;


/***/ },
/* 170 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseIsEqualDeep.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var equalArrays = __webpack_require__(/*! ./equalArrays */ 171),
	    equalByTag = __webpack_require__(/*! ./equalByTag */ 173),
	    equalObjects = __webpack_require__(/*! ./equalObjects */ 174),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isTypedArray = __webpack_require__(/*! ../lang/isTypedArray */ 128);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = objToString.call(object);
	    if (objTag == argsTag) {
	      objTag = objectTag;
	    } else if (objTag != objectTag) {
	      objIsArr = isTypedArray(object);
	    }
	  }
	  if (!othIsArr) {
	    othTag = objToString.call(other);
	    if (othTag == argsTag) {
	      othTag = objectTag;
	    } else if (othTag != objectTag) {
	      othIsArr = isTypedArray(other);
	    }
	  }
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !(objIsArr || objIsObj)) {
	    return equalByTag(object, other, objTag);
	  }
	  if (!isLoose) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  // For more information on detecting circular references see https://es5.github.io/#JO.
	  stackA || (stackA = []);
	  stackB || (stackB = []);
	
	  var length = stackA.length;
	  while (length--) {
	    if (stackA[length] == object) {
	      return stackB[length] == other;
	    }
	  }
	  // Add `object` and `other` to the stack of traversed objects.
	  stackA.push(object);
	  stackB.push(other);
	
	  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
	
	  stackA.pop();
	  stackB.pop();
	
	  return result;
	}
	
	module.exports = baseIsEqualDeep;


/***/ },
/* 171 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/equalArrays.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arraySome = __webpack_require__(/*! ./arraySome */ 172);
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing arrays.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var index = -1,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	    return false;
	  }
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index],
	        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
	
	    if (result !== undefined) {
	      if (result) {
	        continue;
	      }
	      return false;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (isLoose) {
	      if (!arraySome(other, function(othValue) {
	            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	          })) {
	        return false;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	      return false;
	    }
	  }
	  return true;
	}
	
	module.exports = equalArrays;


/***/ },
/* 172 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/arraySome.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `_.some` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	module.exports = arraySome;


/***/ },
/* 173 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/equalByTag.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    stringTag = '[object String]';
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} value The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag) {
	  switch (tag) {
	    case boolTag:
	    case dateTag:
	      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	      return +object == +other;
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case numberTag:
	      // Treat `NaN` vs. `NaN` as equal.
	      return (object != +object)
	        ? other != +other
	        : object == +other;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings primitives and string
	      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	      return object == (other + '');
	  }
	  return false;
	}
	
	module.exports = equalByTag;


/***/ },
/* 174 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/equalObjects.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(/*! ../object/keys */ 131);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isLoose) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  var skipCtor = isLoose;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key],
	        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;
	
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	      return false;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (!skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	module.exports = equalObjects;


/***/ },
/* 175 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/getMatchData.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(/*! ./isStrictComparable */ 176),
	    pairs = __webpack_require__(/*! ../object/pairs */ 177);
	
	/**
	 * Gets the propery names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = pairs(object),
	      length = result.length;
	
	  while (length--) {
	    result[length][2] = isStrictComparable(result[length][1]);
	  }
	  return result;
	}
	
	module.exports = getMatchData;


/***/ },
/* 176 */
/*!**************************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/isStrictComparable.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ../lang/isObject */ 105);
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	module.exports = isStrictComparable;


/***/ },
/* 177 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/lodash/object/pairs.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(/*! ./keys */ 131),
	    toObject = __webpack_require__(/*! ../internal/toObject */ 125);
	
	/**
	 * Creates a two dimensional array of the key-value pairs for `object`,
	 * e.g. `[[key1, value1], [key2, value2]]`.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the new array of key-value pairs.
	 * @example
	 *
	 * _.pairs({ 'barney': 36, 'fred': 40 });
	 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	 */
	function pairs(object) {
	  object = toObject(object);
	
	  var index = -1,
	      props = keys(object),
	      length = props.length,
	      result = Array(length);
	
	  while (++index < length) {
	    var key = props[index];
	    result[index] = [key, object[key]];
	  }
	  return result;
	}
	
	module.exports = pairs;


/***/ },
/* 178 */
/*!***************************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseMatchesProperty.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(/*! ./baseGet */ 179),
	    baseIsEqual = __webpack_require__(/*! ./baseIsEqual */ 169),
	    baseSlice = __webpack_require__(/*! ./baseSlice */ 180),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isKey = __webpack_require__(/*! ./isKey */ 181),
	    isStrictComparable = __webpack_require__(/*! ./isStrictComparable */ 176),
	    last = __webpack_require__(/*! ../array/last */ 182),
	    toObject = __webpack_require__(/*! ./toObject */ 125),
	    toPath = __webpack_require__(/*! ./toPath */ 183);
	
	/**
	 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to compare.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  var isArr = isArray(path),
	      isCommon = isKey(path) && isStrictComparable(srcValue),
	      pathKey = (path + '');
	
	  path = toPath(path);
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    var key = pathKey;
	    object = toObject(object);
	    if ((isArr || !isCommon) && !(key in object)) {
	      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	      if (object == null) {
	        return false;
	      }
	      key = last(path);
	      object = toObject(object);
	    }
	    return object[key] === srcValue
	      ? (srcValue !== undefined || (key in object))
	      : baseIsEqual(srcValue, object[key], undefined, true);
	  };
	}
	
	module.exports = baseMatchesProperty;


/***/ },
/* 179 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseGet.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var toObject = __webpack_require__(/*! ./toObject */ 125);
	
	/**
	 * The base implementation of `get` without support for string paths
	 * and default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path of the property to get.
	 * @param {string} [pathKey] The key representation of path.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path, pathKey) {
	  if (object == null) {
	    return;
	  }
	  if (pathKey !== undefined && pathKey in toObject(object)) {
	    path = [pathKey];
	  }
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	module.exports = baseGet;


/***/ },
/* 180 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseSlice.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;
	
	  start = start == null ? 0 : (+start || 0);
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = (end === undefined || end > length) ? length : (+end || 0);
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;
	
	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}
	
	module.exports = baseSlice;


/***/ },
/* 181 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/isKey.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    toObject = __webpack_require__(/*! ./toObject */ 125);
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  var type = typeof value;
	  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	    return true;
	  }
	  if (isArray(value)) {
	    return false;
	  }
	  var result = !reIsDeepProp.test(value);
	  return result || (object != null && value in toObject(object));
	}
	
	module.exports = isKey;


/***/ },
/* 182 */
/*!*********************************************!*\
  !*** ./~/babel-core/~/lodash/array/last.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array ? array.length : 0;
	  return length ? array[length - 1] : undefined;
	}
	
	module.exports = last;


/***/ },
/* 183 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/toPath.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(/*! ./baseToString */ 119),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115);
	
	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/**
	 * Converts `value` to property path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Array} Returns the property path array.
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return value;
	  }
	  var result = [];
	  baseToString(value).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	}
	
	module.exports = toPath;


/***/ },
/* 184 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/utility/property.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(/*! ../internal/baseProperty */ 112),
	    basePropertyDeep = __webpack_require__(/*! ../internal/basePropertyDeep */ 185),
	    isKey = __webpack_require__(/*! ../internal/isKey */ 181);
	
	/**
	 * Creates a function that returns the property value at `path` on a
	 * given object.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': { 'c': 2 } } },
	 *   { 'a': { 'b': { 'c': 1 } } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b.c'));
	 * // => [2, 1]
	 *
	 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	}
	
	module.exports = property;


/***/ },
/* 185 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/basePropertyDeep.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(/*! ./baseGet */ 179),
	    toPath = __webpack_require__(/*! ./toPath */ 183);
	
	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function basePropertyDeep(path) {
	  var pathKey = (path + '');
	  path = toPath(path);
	  return function(object) {
	    return baseGet(object, path, pathKey);
	  };
	}
	
	module.exports = basePropertyDeep;


/***/ },
/* 186 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseUniq.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(/*! ./baseIndexOf */ 146),
	    cacheIndexOf = __webpack_require__(/*! ./cacheIndexOf */ 187),
	    createCache = __webpack_require__(/*! ./createCache */ 188);
	
	/**
	 * The base implementation of `_.uniq` without support for callback shorthands
	 * and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The function invoked per iteration.
	 * @returns {Array} Returns the new duplicate-value-free array.
	 */
	function baseUniq(array, iteratee) {
	  var index = -1,
	      indexOf = baseIndexOf,
	      length = array.length,
	      isCommon = true,
	      isLarge = isCommon && length >= 200,
	      seen = isLarge ? createCache() : null,
	      result = [];
	
	  if (seen) {
	    indexOf = cacheIndexOf;
	    isCommon = false;
	  } else {
	    isLarge = false;
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value, index, array) : value;
	
	    if (isCommon && value === value) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (indexOf(seen, computed, 0) < 0) {
	      if (iteratee || isLarge) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}
	
	module.exports = baseUniq;


/***/ },
/* 187 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/cacheIndexOf.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ../lang/isObject */ 105);
	
	/**
	 * Checks if `value` is in `cache` mimicking the return signature of
	 * `_.indexOf` by returning `0` if the value is found, else `-1`.
	 *
	 * @private
	 * @param {Object} cache The cache to search.
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `0` if `value` is found, else `-1`.
	 */
	function cacheIndexOf(cache, value) {
	  var data = cache.data,
	      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
	
	  return result ? 0 : -1;
	}
	
	module.exports = cacheIndexOf;


/***/ },
/* 188 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/createCache.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(/*! ./SetCache */ 189),
	    constant = __webpack_require__(/*! ../utility/constant */ 191),
	    getNative = __webpack_require__(/*! ./getNative */ 116);
	
	/** Native method references. */
	var Set = getNative(global, 'Set');
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeCreate = getNative(Object, 'create');
	
	/**
	 * Creates a `Set` cache object to optimize linear searches of large arrays.
	 *
	 * @private
	 * @param {Array} [values] The values to cache.
	 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	 */
	var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
	  return new SetCache(values);
	};
	
	module.exports = createCache;


/***/ },
/* 189 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/SetCache.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var cachePush = __webpack_require__(/*! ./cachePush */ 190),
	    getNative = __webpack_require__(/*! ./getNative */ 116);
	
	/** Native method references. */
	var Set = getNative(global, 'Set');
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeCreate = getNative(Object, 'create');
	
	/**
	 *
	 * Creates a cache object to store unique values.
	 *
	 * @private
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var length = values ? values.length : 0;
	
	  this.data = { 'hash': nativeCreate(null), 'set': new Set };
	  while (length--) {
	    this.push(values[length]);
	  }
	}
	
	// Add functions to the `Set` cache.
	SetCache.prototype.push = cachePush;
	
	module.exports = SetCache;


/***/ },
/* 190 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/cachePush.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ../lang/isObject */ 105);
	
	/**
	 * Adds `value` to the cache.
	 *
	 * @private
	 * @name push
	 * @memberOf SetCache
	 * @param {*} value The value to cache.
	 */
	function cachePush(value) {
	  var data = this.data;
	  if (typeof value == 'string' || isObject(value)) {
	    data.set.add(value);
	  } else {
	    data.hash[value] = true;
	  }
	}
	
	module.exports = cachePush;


/***/ },
/* 191 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/utility/constant.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 * var getter = _.constant(object);
	 *
	 * getter() === object;
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}
	
	module.exports = constant;


/***/ },
/* 192 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/sortedUniq.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * An implementation of `_.uniq` optimized for sorted arrays without support
	 * for callback shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The function invoked per iteration.
	 * @returns {Array} Returns the new duplicate-value-free array.
	 */
	function sortedUniq(array, iteratee) {
	  var seen,
	      index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value, index, array) : value;
	
	    if (!index || seen !== computed) {
	      seen = computed;
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = sortedUniq;


/***/ },
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */
/*!****************************************************!*\
  !*** ./~/babel-core/lib/babel/types/retrievers.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	/**
	 * Return a list of binding identifiers associated with
	 * the input `node`.
	 */
	
	exports.getBindingIdentifiers = getBindingIdentifiers;
	
	/**
	 * Description
	 */
	
	exports.getLastStatements = getLastStatements;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersObject = __webpack_require__(/*! ../helpers/object */ 197);
	
	var _helpersObject2 = _interopRequireDefault(_helpersObject);
	
	var _index = __webpack_require__(/*! ./index */ 156);
	
	var t = _interopRequireWildcard(_index);
	
	function getBindingIdentifiers(node) {
	  var search = [].concat(node);
	  var ids = (0, _helpersObject2["default"])();
	
	  while (search.length) {
	    var id = search.shift();
	    if (!id) continue;
	
	    var keys = t.getBindingIdentifiers.keys[id.type];
	
	    if (t.isIdentifier(id)) {
	      ids[id.name] = id;
	    } else if (t.isExportDeclaration(id)) {
	      if (t.isDeclaration(node.declaration)) {
	        search.push(node.declaration);
	      }
	    } else if (keys) {
	      var _arr = keys;
	
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var key = _arr[_i];
	        search = search.concat(id[key] || []);
	      }
	    }
	  }
	
	  return ids;
	}
	
	getBindingIdentifiers.keys = {
	  UnaryExpression: ["argument"],
	  AssignmentExpression: ["left"],
	  ImportSpecifier: ["local"],
	  ImportNamespaceSpecifier: ["local"],
	  ImportDefaultSpecifier: ["local"],
	  VariableDeclarator: ["id"],
	  FunctionDeclaration: ["id"],
	  FunctionExpression: ["id"],
	  ClassDeclaration: ["id"],
	  ClassExpression: ["id"],
	  SpreadElement: ["argument"],
	  RestElement: ["argument"],
	  UpdateExpression: ["argument"],
	  SpreadProperty: ["argument"],
	  Property: ["value"],
	  ComprehensionBlock: ["left"],
	  AssignmentPattern: ["left"],
	  ComprehensionExpression: ["blocks"],
	  ImportDeclaration: ["specifiers"],
	  VariableDeclaration: ["declarations"],
	  ArrayPattern: ["elements"],
	  ObjectPattern: ["properties"]
	};
	function getLastStatements(node) {
	  var nodes = [];
	
	  var add = function add(node) {
	    nodes = nodes.concat(getLastStatements(node));
	  };
	
	  if (t.isIfStatement(node)) {
	    add(node.consequent);
	    add(node.alternate);
	  } else if (t.isFor(node) || t.isWhile(node)) {
	    add(node.body);
	  } else if (t.isProgram(node) || t.isBlockStatement(node)) {
	    add(node.body[node.body.length - 1]);
	  } else if (t.isLoop()) {} else if (node) {
	    nodes.push(node);
	  }
	
	  return nodes;
	}

/***/ },
/* 197 */
/*!**************************************************!*\
  !*** ./~/babel-core/lib/babel/helpers/object.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	exports["default"] = function () {
	  return Object.create(null);
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 198 */
/*!****************************************************!*\
  !*** ./~/babel-core/lib/babel/types/validators.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	/**
	 * Check if the input `node` is a reference to a bound variable.
	 */
	
	exports.isReferenced = isReferenced;
	
	/**
	 * Check if the input `node` is an `Identifier` and `isReferenced`.
	 */
	
	exports.isReferencedIdentifier = isReferencedIdentifier;
	
	/**
	 * Check if the input `name` is a valid identifier name
	 * and isn't a reserved word.
	 */
	
	exports.isValidIdentifier = isValidIdentifier;
	
	/**
	 * Description
	 */
	
	exports.isLet = isLet;
	
	/**
	 * Description
	 */
	
	exports.isBlockScoped = isBlockScoped;
	
	/**
	 * Description
	 */
	
	exports.isVar = isVar;
	
	/**
	 * Description
	 */
	
	exports.isSpecifierDefault = isSpecifierDefault;
	
	/**
	 * Description
	 */
	
	exports.isScope = isScope;
	
	/**
	 * Description
	 */
	
	exports.isImmutable = isImmutable;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _esutils = __webpack_require__(/*! esutils */ 199);
	
	var _esutils2 = _interopRequireDefault(_esutils);
	
	var _index = __webpack_require__(/*! ./index */ 156);
	
	var t = _interopRequireWildcard(_index);
	
	function isReferenced(node, parent) {
	  switch (parent.type) {
	    // yes: PARENT[NODE]
	    // yes: NODE.child
	    // no: parent.CHILD
	    case "MemberExpression":
	      if (parent.property === node && parent.computed) {
	        return true;
	      } else if (parent.object === node) {
	        return true;
	      } else {
	        return false;
	      }
	
	    // no: new.NODE
	    // no: NODE.target
	    case "MetaProperty":
	      return false;
	
	    // yes: { [NODE]: "" }
	    // yes: { NODE }
	    // no: { NODE: "" }
	    case "Property":
	      if (parent.key === node) {
	        return parent.computed;
	      }
	
	    // no: var NODE = init;
	    // yes: var id = NODE;
	    case "VariableDeclarator":
	      return parent.id !== node;
	
	    // no: function NODE() {}
	    // no: function foo(NODE) {}
	    case "ArrowFunctionExpression":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	      var _arr = parent.params;
	
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var param = _arr[_i];
	        if (param === node) return false;
	      }
	
	      return parent.id !== node;
	
	    // no: export { foo as NODE };
	    // yes: export { NODE as foo };
	    // no: export { NODE as foo } from "foo";
	    case "ExportSpecifier":
	      if (parent.source) {
	        return false;
	      } else {
	        return parent.local === node;
	      }
	
	    // no: import NODE from "foo";
	    case "ImportDefaultSpecifier":
	      return false;
	
	    // no: import * as NODE from "foo";
	    case "ImportNamespaceSpecifier":
	      return false;
	
	    // no: <div NODE="foo" />
	    case "JSXAttribute":
	      return parent.name !== node;
	
	    // no: import { NODE as foo } from "foo";
	    // no: import { foo as NODE } from "foo";
	    case "ImportSpecifier":
	      return false;
	
	    // no: class NODE {}
	    case "ClassDeclaration":
	    case "ClassExpression":
	      return parent.id !== node;
	
	    // yes: class { [NODE](){} }
	    case "MethodDefinition":
	      return parent.key === node && parent.computed;
	
	    // no: NODE: for (;;) {}
	    case "LabeledStatement":
	      return false;
	
	    // no: try {} catch (NODE) {}
	    case "CatchClause":
	      return parent.param !== node;
	
	    // no: function foo(...NODE) {}
	    case "RestElement":
	      return false;
	
	    // no: [NODE = foo] = [];
	    // yes: [foo = NODE] = [];
	    case "AssignmentPattern":
	      return parent.right === node;
	
	    // no: [NODE] = [];
	    // no: ({ NODE }) = [];
	    case "ObjectPattern":
	    case "ArrayPattern":
	      return false;
	
	    // no: import NODE from "bar";
	    case "ImportSpecifier":
	      return false;
	
	    // no: import * as NODE from "foo";
	    case "ImportNamespaceSpecifier":
	      return false;
	  }
	
	  return true;
	}
	
	function isReferencedIdentifier(node, parent, opts) {
	  return (t.isIdentifier(node, opts) || t.isJSXIdentifier(node, opts)) && t.isReferenced(node, parent);
	}
	
	function isValidIdentifier(name) {
	  if (typeof name !== "string" || _esutils2["default"].keyword.isReservedWordES6(name, true)) {
	    return false;
	  } else {
	    return _esutils2["default"].keyword.isIdentifierNameES6(name);
	  }
	}
	
	function isLet(node) {
	  return t.isVariableDeclaration(node) && (node.kind !== "var" || node._let);
	}
	
	function isBlockScoped(node) {
	  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);
	}
	
	function isVar(node) {
	  return t.isVariableDeclaration(node, { kind: "var" }) && !node._let;
	}
	
	function isSpecifierDefault(specifier) {
	  return t.isImportDefaultSpecifier(specifier) || t.isExportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: "default" });
	}
	
	function isScope(node, parent) {
	  if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {
	    return false;
	  }
	
	  return t.isScopable(node);
	}
	
	function isImmutable(node) {
	  if (t.isType(node.type, "Immutable")) return true;
	
	  if (t.isLiteral(node)) {
	    if (node.regex) {
	      // regexes are mutable
	      return false;
	    } else {
	      // immutable!
	      return true;
	    }
	  } else if (t.isIdentifier(node)) {
	    if (node.name === "undefined") {
	      // immutable!
	      return true;
	    } else {
	      // no idea...
	      return false;
	    }
	  }
	
	  return false;
	}

/***/ },
/* 199 */
/*!**************************!*\
  !*** external "esutils" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("esutils");

/***/ },
/* 200 */
/*!****************************************************!*\
  !*** ./~/babel-core/lib/babel/types/converters.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	/**
	 * Description
	 */
	
	exports.toComputedKey = toComputedKey;
	
	/**
	 * Turn an array of statement `nodes` into a `SequenceExpression`.
	 *
	 * Variable declarations are turned into simple assignments and their
	 * declarations hoisted to the top of the current scope.
	 *
	 * Expression statements are just resolved to their expression.
	 */
	
	exports.toSequenceExpression = toSequenceExpression;
	
	/**
	 * Description
	 */
	
	exports.toKeyAlias = toKeyAlias;
	
	/*
	 * Description
	 */
	
	exports.toIdentifier = toIdentifier;
	
	/**
	 * Description
	 *
	 * @returns {Object|Boolean}
	 */
	
	exports.toStatement = toStatement;
	
	/**
	 * Description
	 */
	
	exports.toExpression = toExpression;
	
	/**
	 * Description
	 */
	
	exports.toBlock = toBlock;
	
	/**
	 * Description
	 */
	
	exports.valueToNode = valueToNode;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangIsPlainObject = __webpack_require__(/*! lodash/lang/isPlainObject */ 120);
	
	var _lodashLangIsPlainObject2 = _interopRequireDefault(_lodashLangIsPlainObject);
	
	var _lodashLangIsNumber = __webpack_require__(/*! lodash/lang/isNumber */ 201);
	
	var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
	
	var _lodashLangIsRegExp = __webpack_require__(/*! lodash/lang/isRegExp */ 202);
	
	var _lodashLangIsRegExp2 = _interopRequireDefault(_lodashLangIsRegExp);
	
	var _lodashLangIsString = __webpack_require__(/*! lodash/lang/isString */ 148);
	
	var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
	
	var _traversal = __webpack_require__(/*! ../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _index = __webpack_require__(/*! ./index */ 156);
	
	var t = _interopRequireWildcard(_index);
	
	function toComputedKey(node) {
	  var key = arguments[1] === undefined ? node.key || node.property : arguments[1];
	  return (function () {
	    if (!node.computed) {
	      if (t.isIdentifier(key)) key = t.literal(key.name);
	    }
	    return key;
	  })();
	}
	
	function toSequenceExpression(nodes, scope) {
	  var declars = [];
	  var bailed = false;
	
	  var result = convert(nodes);
	  if (bailed) return;
	
	  for (var i = 0; i < declars.length; i++) {
	    scope.push(declars[i]);
	  }
	
	  return result;
	
	  function convert(nodes) {
	    var ensureLastUndefined = false;
	    var exprs = [];
	
	    var _arr = nodes;
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var node = _arr[_i];
	      if (t.isExpression(node)) {
	        exprs.push(node);
	      } else if (t.isExpressionStatement(node)) {
	        exprs.push(node.expression);
	      } else if (t.isVariableDeclaration(node)) {
	        if (node.kind !== "var") return bailed = true; // bailed
	
	        var _arr2 = node.declarations;
	        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	          var declar = _arr2[_i2];
	          var bindings = t.getBindingIdentifiers(declar);
	          for (var key in bindings) {
	            declars.push({
	              kind: node.kind,
	              id: bindings[key]
	            });
	          }
	
	          if (declar.init) {
	            exprs.push(t.assignmentExpression("=", declar.id, declar.init));
	          }
	        }
	
	        ensureLastUndefined = true;
	        continue;
	      } else if (t.isIfStatement(node)) {
	        var consequent = node.consequent ? convert([node.consequent]) : t.identifier("undefined");
	        var alternate = node.alternate ? convert([node.alternate]) : t.identifier("undefined");
	        if (!consequent || !alternate) return bailed = true;
	
	        exprs.push(t.conditionalExpression(node.test, consequent, alternate));
	      } else if (t.isBlockStatement(node)) {
	        exprs.push(convert(node.body));
	      } else {
	        // bailed, we can't understand this
	        return bailed = true;
	      }
	
	      ensureLastUndefined = false;
	    }
	
	    if (ensureLastUndefined) {
	      exprs.push(t.identifier("undefined"));
	    }
	
	    //
	
	    if (exprs.length === 1) {
	      return exprs[0];
	    } else {
	      return t.sequenceExpression(exprs);
	    }
	  }
	}
	
	function toKeyAlias(node) {
	  var key = arguments[1] === undefined ? node.key : arguments[1];
	  return (function () {
	    var alias;
	    if (t.isIdentifier(key)) {
	      alias = key.name;
	    } else if (t.isLiteral(key)) {
	      alias = JSON.stringify(key.value);
	    } else {
	      alias = JSON.stringify(_traversal2["default"].removeProperties(t.cloneDeep(key)));
	    }
	    if (node.computed) alias = "[" + alias + "]";
	    return alias;
	  })();
	}
	
	function toIdentifier(name) {
	  if (t.isIdentifier(name)) return name.name;
	
	  name = name + "";
	
	  // replace all non-valid identifiers with dashes
	  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
	
	  // remove all dashes and numbers from start of name
	  name = name.replace(/^[-0-9]+/, "");
	
	  // camel case
	  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
	    return c ? c.toUpperCase() : "";
	  });
	
	  if (!t.isValidIdentifier(name)) {
	    name = "_" + name;
	  }
	
	  return name || "_";
	}
	
	function toStatement(node, ignore) {
	  if (t.isStatement(node)) {
	    return node;
	  }
	
	  var mustHaveId = false;
	  var newType;
	
	  if (t.isClass(node)) {
	    mustHaveId = true;
	    newType = "ClassDeclaration";
	  } else if (t.isFunction(node)) {
	    mustHaveId = true;
	    newType = "FunctionDeclaration";
	  } else if (t.isAssignmentExpression(node)) {
	    return t.expressionStatement(node);
	  }
	
	  if (mustHaveId && !node.id) {
	    newType = false;
	  }
	
	  if (!newType) {
	    if (ignore) {
	      return false;
	    } else {
	      throw new Error("cannot turn " + node.type + " to a statement");
	    }
	  }
	
	  node.type = newType;
	
	  return node;
	}
	
	function toExpression(node) {
	  if (t.isExpressionStatement(node)) {
	    node = node.expression;
	  }
	
	  if (t.isClass(node)) {
	    node.type = "ClassExpression";
	  } else if (t.isFunction(node)) {
	    node.type = "FunctionExpression";
	  }
	
	  if (t.isExpression(node)) {
	    return node;
	  } else {
	    throw new Error("cannot turn " + node.type + " to an expression");
	  }
	}
	
	function toBlock(node, parent) {
	  if (t.isBlockStatement(node)) {
	    return node;
	  }
	
	  if (t.isEmptyStatement(node)) {
	    node = [];
	  }
	
	  if (!Array.isArray(node)) {
	    if (!t.isStatement(node)) {
	      if (t.isFunction(parent)) {
	        node = t.returnStatement(node);
	      } else {
	        node = t.expressionStatement(node);
	      }
	    }
	
	    node = [node];
	  }
	
	  return t.blockStatement(node);
	}
	
	function valueToNode(value) {
	  if (value === undefined) {
	    return t.identifier("undefined");
	  }
	
	  if (value === true || value === false || value === null || (0, _lodashLangIsString2["default"])(value) || (0, _lodashLangIsNumber2["default"])(value) || (0, _lodashLangIsRegExp2["default"])(value)) {
	    return t.literal(value);
	  }
	
	  if (Array.isArray(value)) {
	    return t.arrayExpression(value.map(t.valueToNode));
	  }
	
	  if ((0, _lodashLangIsPlainObject2["default"])(value)) {
	    var props = [];
	    for (var key in value) {
	      var nodeKey;
	      if (t.isValidIdentifier(key)) {
	        nodeKey = t.identifier(key);
	      } else {
	        nodeKey = t.literal(key);
	      }
	      props.push(t.property("init", nodeKey, t.valueToNode(value[key])));
	    }
	    return t.objectExpression(props);
	  }
	
	  throw new Error("don't know how to turn this value into a node");
	}

/***/ },
/* 201 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isNumber.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var numberTag = '[object Number]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Number` primitive or object.
	 *
	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	 * as numbers, use the `_.isFinite` method.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isNumber(8.4);
	 * // => true
	 *
	 * _.isNumber(NaN);
	 * // => true
	 *
	 * _.isNumber('8.4');
	 * // => false
	 */
	function isNumber(value) {
	  return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	}
	
	module.exports = isNumber;


/***/ },
/* 202 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isRegExp.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var regexpTag = '[object RegExp]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `RegExp` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isRegExp(/abc/);
	 * // => true
	 *
	 * _.isRegExp('/abc/');
	 * // => false
	 */
	function isRegExp(value) {
	  return isObjectLike(value) && objToString.call(value) == regexpTag;
	}
	
	module.exports = isRegExp;


/***/ },
/* 203 */
/*!********************************************!*\
  !*** ./~/babel-core/lib/babel/messages.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.get = get;
	exports.parseArgs = parseArgs;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _util = __webpack_require__(/*! util */ 204);
	
	var util = _interopRequireWildcard(_util);
	
	var MESSAGES = {
	  tailCallReassignmentDeopt: "Function reference has been reassigned so it's probably be dereferenced so we can't optimise this with confidence",
	  JSXNamespacedTags: "Namespace tags are not supported. ReactJSX is not XML.",
	  classesIllegalBareSuper: "Illegal use of bare super",
	  classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
	  classesIllegalConstructorKind: "Illegal kind for constructor method",
	  scopeDuplicateDeclaration: "Duplicate declaration $1",
	  undeclaredVariable: "Reference to undeclared variable $1",
	  undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",
	  settersInvalidParamLength: "Setters must have exactly one parameter",
	  settersNoRest: "Setters aren't allowed to have a rest",
	  noAssignmentsInForHead: "No assignments allowed in for-in/of head",
	  expectedMemberExpressionOrIdentifier: "Expected type MemeberExpression or Identifier",
	  invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
	  readOnly: "$1 is read-only",
	  modulesIllegalExportName: "Illegal export $1",
	  unknownForHead: "Unknown node type $1 in ForStatement",
	  didYouMean: "Did you mean $1?",
	  codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",
	  missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",
	  unsupportedOutputType: "Unsupported output type $1",
	  illegalMethodName: "Illegal method name $1",
	  lostTrackNodePath: "We lost track of this nodes position, likely because the AST was directly manipulated",
	
	  traverseNeedsParent: "Must pass a scope and parentPath unless traversing a Program/File got a $1 node",
	  traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
	  traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",
	  traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type",
	
	  pluginIllegalKind: "Illegal kind $1 for plugin $2",
	  pluginIllegalPosition: "Illegal position $1 for plugin $2",
	  pluginKeyCollision: "The plugin $1 collides with another of the same name",
	  pluginNotTransformer: "The plugin $1 didn't export a Transformer instance",
	  pluginUnknown: "Unknown plugin $1",
	
	  transformerNotFile: "Transformer $1 is resolving to a different Babel version to what is doing the actual transformation..."
	};
	
	exports.MESSAGES = MESSAGES;
	
	function get(key) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	
	  var msg = MESSAGES[key];
	  if (!msg) throw new ReferenceError("Unknown message " + JSON.stringify(key));
	
	  args = parseArgs(args);
	
	  return msg.replace(/\$(\d+)/g, function (str, i) {
	    return args[--i];
	  });
	}
	
	function parseArgs(args) {
	  return args.map(function (val) {
	    if (val != null && val.inspect) {
	      return val.inspect();
	    } else {
	      try {
	        return JSON.stringify(val) || val + "";
	      } catch (e) {
	        return util.inspect(val);
	      }
	    }
	  });
	}

/***/ },
/* 204 */
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("util");

/***/ },
/* 205 */
/*!**************************!*\
  !*** external "esquery" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("esquery");

/***/ },
/* 206 */
/*!**********************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/path/hoister.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _transformationHelpersReact = __webpack_require__(/*! ../../transformation/helpers/react */ 207);
	
	var react = _interopRequireWildcard(_transformationHelpersReact);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var referenceVisitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
	    if (this.isJSXIdentifier() && react.isCompatTag(node.name)) {
	      return;
	    }
	
	    // direct references that we need to track to hoist this to the highest scope we can
	    var bindingInfo = scope.getBinding(node.name);
	    if (!bindingInfo) return;
	
	    // this binding isn't accessible from the parent scope so we can safely ignore it
	    // eg. it's in a closure etc
	    if (bindingInfo !== state.scope.getBinding(node.name)) return;
	
	    if (bindingInfo.constant) {
	      state.bindings[node.name] = bindingInfo;
	    } else {
	      var _arr = bindingInfo.constantViolations;
	
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var violationPath = _arr[_i];
	        state.breakOnScopePaths.push(violationPath.scope.path);
	      }
	    }
	  }
	};
	
	var PathHoister = (function () {
	  function PathHoister(path, scope) {
	    _classCallCheck(this, PathHoister);
	
	    this.breakOnScopePaths = [];
	    this.bindings = {};
	    this.scopes = [];
	    this.scope = scope;
	    this.path = path;
	  }
	
	  PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {
	    for (var key in this.bindings) {
	      var binding = this.bindings[key];
	      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
	        return false;
	      }
	    }
	
	    return true;
	  };
	
	  PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {
	    var scope = this.path.scope;
	    do {
	      if (this.isCompatibleScope(scope)) {
	        this.scopes.push(scope);
	      } else {
	        break;
	      }
	
	      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
	        break;
	      }
	    } while (scope = scope.parent);
	  };
	
	  PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {
	    var scopes = this.scopes;
	
	    var scope = scopes.pop();
	    if (!scope) return;
	
	    if (scope.path.isFunction()) {
	      if (this.hasOwnParamBindings(scope)) {
	        // should ignore this scope since it's ourselves
	        if (this.scope.is(scope)) return;
	
	        // needs to be attached to the body
	        return scope.path.get("body").get("body")[0];
	      } else {
	        // doesn't need to be be attached to this scope
	        return this.getNextScopeStatementParent();
	      }
	    } else if (scope.path.isProgram()) {
	      return this.getNextScopeStatementParent();
	    }
	  };
	
	  PathHoister.prototype.getNextScopeStatementParent = function getNextScopeStatementParent() {
	    var scope = this.scopes.pop();
	    if (scope) return scope.path.getStatementParent();
	  };
	
	  PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {
	    for (var name in this.bindings) {
	      if (!scope.hasOwnBinding(name)) continue;
	
	      var binding = this.bindings[name];
	      if (binding.kind === "param") return true;
	    }
	    return false;
	  };
	
	  PathHoister.prototype.run = function run() {
	    var node = this.path.node;
	    if (node._hoisted) return;
	    node._hoisted = true;
	
	    this.path.traverse(referenceVisitor, this);
	
	    this.getCompatibleScopes();
	
	    var path = this.getAttachmentPath();
	    if (!path) return;
	
	    var uid = path.scope.generateUidIdentifier("ref");
	
	    path.insertBefore([t.variableDeclaration("var", [t.variableDeclarator(uid, this.path.node)])]);
	
	    var parent = this.path.parentPath;
	
	    if (parent.isJSXElement() && this.path.container === parent.node.children) {
	      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with
	      // an expression container
	      uid = t.jSXExpressionContainer(uid);
	    }
	
	    this.path.replaceWith(uid);
	  };
	
	  return PathHoister;
	})();
	
	exports["default"] = PathHoister;
	module.exports = exports["default"];

/***/ },
/* 207 */
/*!****************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/react.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.isCreateClass = isCreateClass;
	exports.isCompatTag = isCompatTag;
	exports.buildChildren = buildChildren;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangIsString = __webpack_require__(/*! lodash/lang/isString */ 148);
	
	var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var isCreateClassCallExpression = t.buildMatchMemberExpression("React.createClass");
	
	function isCreateClass(node) {
	  if (!node || !t.isCallExpression(node)) return false;
	
	  // not React.createClass call member object
	  if (!isCreateClassCallExpression(node.callee)) return false;
	
	  // no call arguments
	  var args = node.arguments;
	  if (args.length !== 1) return false;
	
	  // first node arg is not an object
	  var first = args[0];
	  if (!t.isObjectExpression(first)) return false;
	
	  return true;
	}
	
	var isReactComponent = t.buildMatchMemberExpression("React.Component");
	
	exports.isReactComponent = isReactComponent;
	
	function isCompatTag(tagName) {
	  return tagName && /^[a-z]|\-/.test(tagName);
	}
	
	function isStringLiteral(node) {
	  return t.isLiteral(node) && (0, _lodashLangIsString2["default"])(node.value);
	}
	
	function cleanJSXElementLiteralChild(child, args) {
	  var lines = child.value.split(/\r\n|\n|\r/);
	
	  var lastNonEmptyLine = 0;
	
	  for (var i = 0; i < lines.length; i++) {
	    if (lines[i].match(/[^ \t]/)) {
	      lastNonEmptyLine = i;
	    }
	  }
	
	  var str = "";
	
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	
	    var isFirstLine = i === 0;
	    var isLastLine = i === lines.length - 1;
	    var isLastNonEmptyLine = i === lastNonEmptyLine;
	
	    // replace rendered whitespace tabs with spaces
	    var trimmedLine = line.replace(/\t/g, " ");
	
	    // trim whitespace touching a newline
	    if (!isFirstLine) {
	      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
	    }
	
	    // trim whitespace touching an endline
	    if (!isLastLine) {
	      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
	    }
	
	    if (trimmedLine) {
	      if (!isLastNonEmptyLine) {
	        trimmedLine += " ";
	      }
	
	      str += trimmedLine;
	    }
	  }
	
	  if (str) args.push(t.literal(str));
	}
	
	function buildChildren(node) {
	  var elems = [];
	
	  for (var i = 0; i < node.children.length; i++) {
	    var child = node.children[i];
	
	    if (t.isLiteral(child) && typeof child.value === "string") {
	      cleanJSXElementLiteralChild(child, elems);
	      continue;
	    }
	
	    if (t.isJSXExpressionContainer(child)) child = child.expression;
	    if (t.isJSXEmptyExpression(child)) continue;
	
	    elems.push(child);
	  }
	
	  return elems;
	}

/***/ },
/* 208 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isBoolean.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114);
	
	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a boolean primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isBoolean(false);
	 * // => true
	 *
	 * _.isBoolean(null);
	 * // => false
	 */
	function isBoolean(value) {
	  return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	}
	
	module.exports = isBoolean;


/***/ },
/* 209 */
/*!******************************************************!*\
  !*** ./~/babel-core/lib/babel/helpers/code-frame.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lineNumbers = __webpack_require__(/*! line-numbers */ 210);
	
	var _lineNumbers2 = _interopRequireDefault(_lineNumbers);
	
	var _repeating = __webpack_require__(/*! repeating */ 211);
	
	var _repeating2 = _interopRequireDefault(_repeating);
	
	var _jsTokens = __webpack_require__(/*! js-tokens */ 212);
	
	var _jsTokens2 = _interopRequireDefault(_jsTokens);
	
	var _esutils = __webpack_require__(/*! esutils */ 199);
	
	var _esutils2 = _interopRequireDefault(_esutils);
	
	var _chalk = __webpack_require__(/*! chalk */ 213);
	
	var _chalk2 = _interopRequireDefault(_chalk);
	
	var defs = {
	  string: _chalk2["default"].red,
	  punctuator: _chalk2["default"].bold,
	  curly: _chalk2["default"].green,
	  parens: _chalk2["default"].blue.bold,
	  square: _chalk2["default"].yellow,
	  keyword: _chalk2["default"].cyan,
	  number: _chalk2["default"].magenta,
	  regex: _chalk2["default"].magenta,
	  comment: _chalk2["default"].grey,
	  invalid: _chalk2["default"].inverse
	};
	
	var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
	
	function getTokenType(match) {
	  var token = _jsTokens2["default"].matchToToken(match);
	  if (token.type === "name" && _esutils2["default"].keyword.isReservedWordES6(token.value)) {
	    return "keyword";
	  }
	
	  if (token.type === "punctuator") {
	    switch (token.value) {
	      case "{":
	      case "}":
	        return "curly";
	      case "(":
	      case ")":
	        return "parens";
	      case "[":
	      case "]":
	        return "square";
	    }
	  }
	
	  return token.type;
	}
	
	function highlight(text) {
	  return text.replace(_jsTokens2["default"], function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var type = getTokenType(args);
	    var colorize = defs[type];
	    if (colorize) {
	      return args[0].split(NEWLINE).map(function (str) {
	        return colorize(str);
	      }).join("\n");
	    } else {
	      return args[0];
	    }
	  });
	}
	
	exports["default"] = function (lines, lineNumber, colNumber) {
	  var opts = arguments[3] === undefined ? {} : arguments[3];
	
	  colNumber = Math.max(colNumber, 0);
	
	  if (opts.highlightCode && _chalk2["default"].supportsColor) {
	    lines = highlight(lines);
	  }
	
	  lines = lines.split(NEWLINE);
	
	  var start = Math.max(lineNumber - 3, 0);
	  var end = Math.min(lines.length, lineNumber + 3);
	
	  if (!lineNumber && !colNumber) {
	    start = 0;
	    end = lines.length;
	  }
	
	  return (0, _lineNumbers2["default"])(lines.slice(start, end), {
	    start: start + 1,
	    before: "  ",
	    after: " | ",
	    transform: function transform(params) {
	      if (params.number !== lineNumber) {
	        return;
	      }
	      if (colNumber) {
	        params.line += "\n" + params.before + "" + (0, _repeating2["default"])(" ", params.width) + "" + params.after + "" + (0, _repeating2["default"])(" ", colNumber - 1) + "^";
	      }
	      params.before = params.before.replace(/^./, ">");
	    }
	  }).join("\n");
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 210 */
/*!*******************************!*\
  !*** external "line-numbers" ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("line-numbers");

/***/ },
/* 211 */
/*!****************************!*\
  !*** external "repeating" ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("repeating");

/***/ },
/* 212 */
/*!****************************!*\
  !*** external "js-tokens" ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("js-tokens");

/***/ },
/* 213 */
/*!************************!*\
  !*** external "chalk" ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("chalk");

/***/ },
/* 214 */
/*!*************************************************!*\
  !*** ./~/babel-core/lib/babel/helpers/parse.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _normalizeAst = __webpack_require__(/*! ./normalize-ast */ 215);
	
	var _normalizeAst2 = _interopRequireDefault(_normalizeAst);
	
	var _estraverse = __webpack_require__(/*! estraverse */ 216);
	
	var _estraverse2 = _interopRequireDefault(_estraverse);
	
	var _acorn = __webpack_require__(/*! ../../acorn */ 217);
	
	var acorn = _interopRequireWildcard(_acorn);
	
	exports["default"] = function (code) {
	  var opts = arguments[1] === undefined ? {} : arguments[1];
	
	  var comments = [];
	  var tokens = [];
	
	  var parseOpts = {
	    allowImportExportEverywhere: opts.looseModules,
	    allowReturnOutsideFunction: opts.looseModules,
	    allowHashBang: true,
	    ecmaVersion: 6,
	    strictMode: opts.strictMode,
	    sourceType: opts.sourceType,
	    locations: true,
	    onComment: comments,
	    features: opts.features || {},
	    plugins: opts.plugins || {},
	    onToken: tokens,
	    ranges: true
	  };
	
	  if (opts.nonStandard) {
	    parseOpts.plugins.jsx = true;
	    parseOpts.plugins.flow = true;
	  }
	
	  var ast = acorn.parse(code, parseOpts);
	  _estraverse2["default"].attachComments(ast, comments, tokens);
	  ast = (0, _normalizeAst2["default"])(ast, comments, tokens);
	  return ast;
	};
	
	module.exports = exports["default"];

/***/ },
/* 215 */
/*!*********************************************************!*\
  !*** ./~/babel-core/lib/babel/helpers/normalize-ast.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	exports["default"] = function (ast, comments, tokens) {
	  if (ast && ast.type === "Program") {
	    return t.file(ast, comments || [], tokens || []);
	  } else {
	    throw new Error("Not a valid ast?");
	  }
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 216 */
/*!*****************************!*\
  !*** external "estraverse" ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("estraverse");

/***/ },
/* 217 */
/*!*****************************************!*\
  !*** ./~/babel-core/lib/acorn/index.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	__webpack_require__(/*! ./plugins/flow */ 218);
	
	var _acornJsxInject = __webpack_require__(/*! acorn-jsx/inject */ 235);
	
	var _acornJsxInject2 = _interopRequireDefault(_acornJsxInject);
	
	var _srcIndex = __webpack_require__(/*! ./src/index */ 219);
	
	var acorn = _interopRequireWildcard(_srcIndex);
	
	_defaults(exports, _interopRequireWildcard(_srcIndex));
	
	(0, _acornJsxInject2["default"])(acorn);

/***/ },
/* 218 */
/*!************************************************!*\
  !*** ./~/babel-core/lib/acorn/plugins/flow.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var acorn = __webpack_require__(/*! ../src/index */ 219);
	
	var pp = acorn.Parser.prototype;
	var tt = acorn.tokTypes;
	
	pp.isRelational = function (op) {
	  return this.type === tt.relational && this.value === op;
	};
	
	pp.expectRelational = function (op) {
	  if (this.isRelational(op)) {
	    this.next();
	  } else {
	    this.unexpected();
	  }
	};
	
	pp.flow_parseDeclareClass = function (node) {
	  this.next();
	  this.flow_parseInterfaceish(node, true);
	  return this.finishNode(node, "DeclareClass");
	};
	
	pp.flow_parseDeclareFunction = function (node) {
	  this.next();
	
	  var id = node.id = this.parseIdent();
	
	  var typeNode = this.startNode();
	  var typeContainer = this.startNode();
	
	  if (this.isRelational("<")) {
	    typeNode.typeParameters = this.flow_parseTypeParameterDeclaration();
	  } else {
	    typeNode.typeParameters = null;
	  }
	
	  this.expect(tt.parenL);
	  var tmp = this.flow_parseFunctionTypeParams();
	  typeNode.params = tmp.params;
	  typeNode.rest = tmp.rest;
	  this.expect(tt.parenR);
	
	  this.expect(tt.colon);
	  typeNode.returnType = this.flow_parseType();
	
	  typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
	  id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
	
	  this.finishNode(id, id.type);
	
	  this.semicolon();
	
	  return this.finishNode(node, "DeclareFunction");
	};
	
	pp.flow_parseDeclare = function (node) {
	  if (this.type === tt._class) {
	    return this.flow_parseDeclareClass(node);
	  } else if (this.type === tt._function) {
	    return this.flow_parseDeclareFunction(node);
	  } else if (this.type === tt._var) {
	    return this.flow_parseDeclareVariable(node);
	  } else if (this.isContextual("module")) {
	    return this.flow_parseDeclareModule(node);
	  } else {
	    this.unexpected();
	  }
	};
	
	pp.flow_parseDeclareVariable = function (node) {
	  this.next();
	  node.id = this.flow_parseTypeAnnotatableIdentifier();
	  this.semicolon();
	  return this.finishNode(node, "DeclareVariable");
	};
	
	pp.flow_parseDeclareModule = function (node) {
	  this.next();
	
	  if (this.type === tt.string) {
	    node.id = this.parseExprAtom();
	  } else {
	    node.id = this.parseIdent();
	  }
	
	  var bodyNode = node.body = this.startNode();
	  var body = bodyNode.body = [];
	  this.expect(tt.braceL);
	  while (this.type !== tt.braceR) {
	    var node2 = this.startNode();
	
	    // todo: declare check
	    this.next();
	
	    body.push(this.flow_parseDeclare(node2));
	  }
	  this.expect(tt.braceR);
	
	  this.finishNode(bodyNode, "BlockStatement");
	  return this.finishNode(node, "DeclareModule");
	};
	
	// Interfaces
	
	pp.flow_parseInterfaceish = function (node, allowStatic) {
	  node.id = this.parseIdent();
	
	  if (this.isRelational("<")) {
	    node.typeParameters = this.flow_parseTypeParameterDeclaration();
	  } else {
	    node.typeParameters = null;
	  }
	
	  node["extends"] = [];
	
	  if (this.eat(tt._extends)) {
	    do {
	      node["extends"].push(this.flow_parseInterfaceExtends());
	    } while (this.eat(tt.comma));
	  }
	
	  node.body = this.flow_parseObjectType(allowStatic);
	};
	
	pp.flow_parseInterfaceExtends = function () {
	  var node = this.startNode();
	
	  node.id = this.parseIdent();
	  if (this.isRelational("<")) {
	    node.typeParameters = this.flow_parseTypeParameterInstantiation();
	  } else {
	    node.typeParameters = null;
	  }
	
	  return this.finishNode(node, "InterfaceExtends");
	};
	
	pp.flow_parseInterface = function (node) {
	  this.flow_parseInterfaceish(node, false);
	  return this.finishNode(node, "InterfaceDeclaration");
	};
	
	// Type aliases
	
	pp.flow_parseTypeAlias = function (node) {
	  node.id = this.parseIdent();
	
	  if (this.isRelational("<")) {
	    node.typeParameters = this.flow_parseTypeParameterDeclaration();
	  } else {
	    node.typeParameters = null;
	  }
	
	  var oldInType = this.inType;
	  this.inType = true;
	
	  this.expect(tt.eq);
	
	  node.right = this.flow_parseType();
	
	  this.inType = oldInType;
	
	  this.semicolon();
	
	  return this.finishNode(node, "TypeAlias");
	};
	
	// Type annotations
	
	pp.flow_parseTypeParameterDeclaration = function () {
	  var node = this.startNode();
	  node.params = [];
	
	  this.expectRelational("<");
	  while (!this.isRelational(">")) {
	    node.params.push(this.flow_parseTypeAnnotatableIdentifier());
	    if (!this.isRelational(">")) {
	      this.expect(tt.comma);
	    }
	  }
	  this.expectRelational(">");
	
	  return this.finishNode(node, "TypeParameterDeclaration");
	};
	
	pp.flow_parseTypeParameterInstantiation = function () {
	  var node = this.startNode(),
	      oldInType = this.inType;
	  node.params = [];
	
	  this.inType = true;
	
	  this.expectRelational("<");
	  while (!this.isRelational(">")) {
	    node.params.push(this.flow_parseType());
	    if (!this.isRelational(">")) {
	      this.expect(tt.comma);
	    }
	  }
	  this.expectRelational(">");
	
	  this.inType = oldInType;
	
	  return this.finishNode(node, "TypeParameterInstantiation");
	};
	
	pp.flow_parseObjectPropertyKey = function () {
	  return this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);
	};
	
	pp.flow_parseObjectTypeIndexer = function (node, isStatic) {
	  node["static"] = isStatic;
	
	  this.expect(tt.bracketL);
	  node.id = this.flow_parseObjectPropertyKey();
	  this.expect(tt.colon);
	  node.key = this.flow_parseType();
	  this.expect(tt.bracketR);
	  this.expect(tt.colon);
	  node.value = this.flow_parseType();
	
	  this.flow_objectTypeSemicolon();
	  return this.finishNode(node, "ObjectTypeIndexer");
	};
	
	pp.flow_parseObjectTypeMethodish = function (node) {
	  node.params = [];
	  node.rest = null;
	  node.typeParameters = null;
	
	  if (this.isRelational("<")) {
	    node.typeParameters = this.flow_parseTypeParameterDeclaration();
	  }
	
	  this.expect(tt.parenL);
	  while (this.type === tt.name) {
	    node.params.push(this.flow_parseFunctionTypeParam());
	    if (this.type !== tt.parenR) {
	      this.expect(tt.comma);
	    }
	  }
	
	  if (this.eat(tt.ellipsis)) {
	    node.rest = this.flow_parseFunctionTypeParam();
	  }
	  this.expect(tt.parenR);
	  this.expect(tt.colon);
	  node.returnType = this.flow_parseType();
	
	  return this.finishNode(node, "FunctionTypeAnnotation");
	};
	
	pp.flow_parseObjectTypeMethod = function (start, isStatic, key) {
	  var node = this.startNodeAt(start);
	  node.value = this.flow_parseObjectTypeMethodish(this.startNodeAt(start));
	  node["static"] = isStatic;
	  node.key = key;
	  node.optional = false;
	  this.flow_objectTypeSemicolon();
	  return this.finishNode(node, "ObjectTypeProperty");
	};
	
	pp.flow_parseObjectTypeCallProperty = function (node, isStatic) {
	  var valueNode = this.startNode();
	  node["static"] = isStatic;
	  node.value = this.flow_parseObjectTypeMethodish(valueNode);
	  this.flow_objectTypeSemicolon();
	  return this.finishNode(node, "ObjectTypeCallProperty");
	};
	
	pp.flow_parseObjectType = function (allowStatic) {
	  var nodeStart = this.startNode();
	  var node;
	  var optional = false;
	  var property;
	  var propertyKey;
	  var propertyTypeAnnotation;
	  var token;
	  var isStatic;
	
	  nodeStart.callProperties = [];
	  nodeStart.properties = [];
	  nodeStart.indexers = [];
	
	  this.expect(tt.braceL);
	
	  while (this.type !== tt.braceR) {
	    var start = this.markPosition();
	    node = this.startNode();
	    if (allowStatic && this.isContextual("static")) {
	      this.next();
	      isStatic = true;
	    }
	
	    if (this.type === tt.bracketL) {
	      nodeStart.indexers.push(this.flow_parseObjectTypeIndexer(node, isStatic));
	    } else if (this.type === tt.parenL || this.isRelational("<")) {
	      nodeStart.callProperties.push(this.flow_parseObjectTypeCallProperty(node, allowStatic));
	    } else {
	      if (isStatic && this.type === tt.colon) {
	        propertyKey = this.parseIdent();
	      } else {
	        propertyKey = this.flow_parseObjectPropertyKey();
	      }
	      if (this.isRelational("<") || this.type === tt.parenL) {
	        // This is a method property
	        nodeStart.properties.push(this.flow_parseObjectTypeMethod(start, isStatic, propertyKey));
	      } else {
	        if (this.eat(tt.question)) {
	          optional = true;
	        }
	        this.expect(tt.colon);
	        node.key = propertyKey;
	        node.value = this.flow_parseType();
	        node.optional = optional;
	        node["static"] = isStatic;
	        this.flow_objectTypeSemicolon();
	        nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
	      }
	    }
	  }
	
	  this.expect(tt.braceR);
	
	  return this.finishNode(nodeStart, "ObjectTypeAnnotation");
	};
	
	pp.flow_objectTypeSemicolon = function () {
	  if (!this.eat(tt.semi) && !this.eat(tt.comma) && this.type !== tt.braceR) {
	    this.unexpected();
	  }
	};
	
	pp.flow_parseGenericType = function (start, id) {
	  var node = this.startNodeAt(start);
	
	  node.typeParameters = null;
	  node.id = id;
	
	  while (this.eat(tt.dot)) {
	    var node2 = this.startNodeAt(start);
	    node2.qualification = node.id;
	    node2.id = this.parseIdent();
	    node.id = this.finishNode(node2, "QualifiedTypeIdentifier");
	  }
	
	  if (this.isRelational("<")) {
	    node.typeParameters = this.flow_parseTypeParameterInstantiation();
	  }
	
	  return this.finishNode(node, "GenericTypeAnnotation");
	};
	
	pp.flow_parseVoidType = function () {
	  var node = this.startNode();
	  this.expect(tt._void);
	  return this.finishNode(node, "VoidTypeAnnotation");
	};
	
	pp.flow_parseTypeofType = function () {
	  var node = this.startNode();
	  this.expect(tt._typeof);
	  node.argument = this.flow_parsePrimaryType();
	  return this.finishNode(node, "TypeofTypeAnnotation");
	};
	
	pp.flow_parseTupleType = function () {
	  var node = this.startNode();
	  node.types = [];
	  this.expect(tt.bracketL);
	  // We allow trailing commas
	  while (this.pos < this.input.length && this.type !== tt.bracketR) {
	    node.types.push(this.flow_parseType());
	    if (this.type === tt.bracketR) break;
	    this.expect(tt.comma);
	  }
	  this.expect(tt.bracketR);
	  return this.finishNode(node, "TupleTypeAnnotation");
	};
	
	pp.flow_parseFunctionTypeParam = function () {
	  var optional = false;
	  var node = this.startNode();
	  node.name = this.parseIdent();
	  if (this.eat(tt.question)) {
	    optional = true;
	  }
	  this.expect(tt.colon);
	  node.optional = optional;
	  node.typeAnnotation = this.flow_parseType();
	  return this.finishNode(node, "FunctionTypeParam");
	};
	
	pp.flow_parseFunctionTypeParams = function () {
	  var ret = { params: [], rest: null };
	  while (this.type === tt.name) {
	    ret.params.push(this.flow_parseFunctionTypeParam());
	    if (this.type !== tt.parenR) {
	      this.expect(tt.comma);
	    }
	  }
	  if (this.eat(tt.ellipsis)) {
	    ret.rest = this.flow_parseFunctionTypeParam();
	  }
	  return ret;
	};
	
	pp.flow_identToTypeAnnotation = function (start, node, id) {
	  switch (id.name) {
	    case "any":
	      return this.finishNode(node, "AnyTypeAnnotation");
	
	    case "bool":
	    case "boolean":
	      return this.finishNode(node, "BooleanTypeAnnotation");
	
	    case "number":
	      return this.finishNode(node, "NumberTypeAnnotation");
	
	    case "string":
	      return this.finishNode(node, "StringTypeAnnotation");
	
	    default:
	      return this.flow_parseGenericType(start, id);
	  }
	};
	
	// The parsing of types roughly parallels the parsing of expressions, and
	// primary types are kind of like primary expressions...they're the
	// primitives with which other types are constructed.
	pp.flow_parsePrimaryType = function () {
	  var typeIdentifier = null;
	  var params = null;
	  var returnType = null;
	  var start = this.markPosition();
	  var node = this.startNode();
	  var rest = null;
	  var tmp;
	  var typeParameters;
	  var token;
	  var type;
	  var isGroupedType = false;
	
	  switch (this.type) {
	    case tt.name:
	      return this.flow_identToTypeAnnotation(start, node, this.parseIdent());
	
	    case tt.braceL:
	      return this.flow_parseObjectType();
	
	    case tt.bracketL:
	      return this.flow_parseTupleType();
	
	    case tt.relational:
	      if (this.value === "<") {
	        node.typeParameters = this.flow_parseTypeParameterDeclaration();
	        this.expect(tt.parenL);
	        tmp = this.flow_parseFunctionTypeParams();
	        node.params = tmp.params;
	        node.rest = tmp.rest;
	        this.expect(tt.parenR);
	
	        this.expect(tt.arrow);
	
	        node.returnType = this.flow_parseType();
	
	        return this.finishNode(node, "FunctionTypeAnnotation");
	      }
	
	    case tt.parenL:
	      this.next();
	
	      // Check to see if this is actually a grouped type
	      if (this.type !== tt.parenR && this.type !== tt.ellipsis) {
	        if (this.type === tt.name) {
	          var token = this.lookahead().type;
	          isGroupedType = token !== tt.question && token !== tt.colon;
	        } else {
	          isGroupedType = true;
	        }
	      }
	
	      if (isGroupedType) {
	        type = this.flow_parseType();
	        this.expect(tt.parenR);
	
	        // If we see a => next then someone was probably confused about
	        // function types, so we can provide a better error message
	        if (this.eat(tt.arrow)) {
	          this.raise(node, "Unexpected token =>. It looks like " + "you are trying to write a function type, but you ended up " + "writing a grouped type followed by an =>, which is a syntax " + "error. Remember, function type parameters are named so function " + "types look like (name1: type1, name2: type2) => returnType. You " + "probably wrote (type1) => returnType");
	        }
	
	        return type;
	      }
	
	      tmp = this.flow_parseFunctionTypeParams();
	      node.params = tmp.params;
	      node.rest = tmp.rest;
	
	      this.expect(tt.parenR);
	
	      this.expect(tt.arrow);
	
	      node.returnType = this.flow_parseType();
	      node.typeParameters = null;
	
	      return this.finishNode(node, "FunctionTypeAnnotation");
	
	    case tt.string:
	      node.value = this.value;
	      node.raw = this.input.slice(this.start, this.end);
	      this.next();
	      return this.finishNode(node, "StringLiteralTypeAnnotation");
	
	    default:
	      if (this.type.keyword) {
	        switch (this.type.keyword) {
	          case "void":
	            return this.flow_parseVoidType();
	
	          case "typeof":
	            return this.flow_parseTypeofType();
	        }
	      }
	  }
	
	  this.unexpected();
	};
	
	pp.flow_parsePostfixType = function () {
	  var node = this.startNode();
	  var type = node.elementType = this.flow_parsePrimaryType();
	  if (this.type === tt.bracketL) {
	    this.expect(tt.bracketL);
	    this.expect(tt.bracketR);
	    return this.finishNode(node, "ArrayTypeAnnotation");
	  }
	  return type;
	};
	
	pp.flow_parsePrefixType = function () {
	  var node = this.startNode();
	  if (this.eat(tt.question)) {
	    node.typeAnnotation = this.flow_parsePrefixType();
	    return this.finishNode(node, "NullableTypeAnnotation");
	  }
	  return this.flow_parsePostfixType();
	};
	
	pp.flow_parseIntersectionType = function () {
	  var node = this.startNode();
	  var type = this.flow_parsePrefixType();
	  node.types = [type];
	  while (this.eat(tt.bitwiseAND)) {
	    node.types.push(this.flow_parsePrefixType());
	  }
	  return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
	};
	
	pp.flow_parseUnionType = function () {
	  var node = this.startNode();
	  var type = this.flow_parseIntersectionType();
	  node.types = [type];
	  while (this.eat(tt.bitwiseOR)) {
	    node.types.push(this.flow_parseIntersectionType());
	  }
	  return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
	};
	
	pp.flow_parseType = function () {
	  var oldInType = this.inType;
	  this.inType = true;
	  var type = this.flow_parseUnionType();
	  this.inType = oldInType;
	  return type;
	};
	
	pp.flow_parseTypeAnnotation = function () {
	  var node = this.startNode();
	
	  var oldInType = this.inType;
	  this.inType = true;
	  this.expect(tt.colon);
	  node.typeAnnotation = this.flow_parseType();
	  this.inType = oldInType;
	
	  return this.finishNode(node, "TypeAnnotation");
	};
	
	pp.flow_parseTypeAnnotatableIdentifier = function (requireTypeAnnotation, canBeOptionalParam) {
	  var node = this.startNode();
	  var ident = this.parseIdent();
	  var isOptionalParam = false;
	
	  if (canBeOptionalParam && this.eat(tt.question)) {
	    this.expect(tt.question);
	    isOptionalParam = true;
	  }
	
	  if (requireTypeAnnotation || this.type === tt.colon) {
	    ident.typeAnnotation = this.flow_parseTypeAnnotation();
	    this.finishNode(ident, ident.type);
	  }
	
	  if (isOptionalParam) {
	    ident.optional = true;
	    this.finishNode(ident, ident.type);
	  }
	
	  return ident;
	};
	
	acorn.plugins.flow = function (instance) {
	  // function name(): string {}
	  instance.extend("parseFunctionBody", function (inner) {
	    return function (node, allowExpression) {
	      if (this.type === tt.colon) {
	        node.returnType = this.flow_parseTypeAnnotation();
	      }
	
	      return inner.call(this, node, allowExpression);
	    };
	  });
	
	  instance.extend("parseStatement", function (inner) {
	    return function (declaration, topLevel) {
	      // strict mode handling of `interface` since it's a reserved word
	      if (this.strict && this.type === tt.name && this.value === "interface") {
	        var node = this.startNode();
	        this.next();
	        return this.flow_parseInterface(node);
	      } else {
	        return inner.call(this, declaration, topLevel);
	      }
	    };
	  });
	
	  instance.extend("parseExpressionStatement", function (inner) {
	    return function (node, expr) {
	      if (expr.type === "Identifier") {
	        if (expr.name === "declare") {
	          if (this.type === tt._class || this.type === tt.name || this.type === tt._function || this.type === tt._var) {
	            return this.flow_parseDeclare(node);
	          }
	        } else if (this.type === tt.name) {
	          if (expr.name === "interface") {
	            return this.flow_parseInterface(node);
	          } else if (expr.name === "type") {
	            return this.flow_parseTypeAlias(node);
	          }
	        }
	      }
	
	      return inner.call(this, node, expr);
	    };
	  });
	
	  instance.extend("shouldParseExportDeclaration", function (inner) {
	    return function () {
	      return this.isContextual("type") || inner.call(this);
	    };
	  });
	
	  instance.extend("parseParenItem", function (inner) {
	    return function (node, start) {
	      if (this.type === tt.colon) {
	        var typeCastNode = this.startNodeAt(start);
	        typeCastNode.expression = node;
	        typeCastNode.typeAnnotation = this.flow_parseTypeAnnotation();
	        return this.finishNode(typeCastNode, "TypeCastExpression");
	      } else {
	        return node;
	      }
	    };
	  });
	
	  instance.extend("parseClassId", function (inner) {
	    return function (node, isStatement) {
	      inner.call(this, node, isStatement);
	      if (this.isRelational("<")) {
	        node.typeParameters = this.flow_parseTypeParameterDeclaration();
	      }
	    };
	  });
	
	  instance.extend("readToken", function (inner) {
	    return function (code) {
	      if (this.inType && (code === 62 || code === 60)) {
	        return this.finishOp(tt.relational, 1);
	      } else {
	        return inner.call(this, code);
	      }
	    };
	  });
	
	  instance.extend("jsx_readToken", function (inner) {
	    return function () {
	      if (!this.inType) return inner.call(this);
	    };
	  });
	
	  instance.extend("parseParenArrowList", function (inner) {
	    return function (start, exprList, isAsync) {
	      for (var i = 0; i < exprList.length; i++) {
	        var listItem = exprList[i];
	        if (listItem.type === "TypeCastExpression") {
	          var expr = listItem.expression;
	          expr.typeAnnotation = listItem.typeAnnotation;
	          exprList[i] = expr;
	        }
	      }
	      return inner.call(this, start, exprList, isAsync);
	    };
	  });
	
	  instance.extend("parseClassProperty", function (inner) {
	    return function (node) {
	      if (this.type === tt.colon) {
	        node.typeAnnotation = this.flow_parseTypeAnnotation();
	      }
	      return inner.call(this, node);
	    };
	  });
	  instance.extend("isClassProperty", function (inner) {
	    return function () {
	      return this.type === tt.colon || inner.call(this);
	    };
	  });
	
	  instance.extend("parseClassMethod", function (inner) {
	    return function (classBody, method, isGenerator, isAsync) {
	      var typeParameters;
	      if (this.isRelational("<")) {
	        typeParameters = this.flow_parseTypeParameterDeclaration();
	      }
	      method.value = this.parseMethod(isGenerator, isAsync);
	      method.value.typeParameters = typeParameters;
	      classBody.body.push(this.finishNode(method, "MethodDefinition"));
	    };
	  });
	
	  instance.extend("parseClassSuper", function (inner) {
	    return function (node, isStatement) {
	      inner.call(this, node, isStatement);
	      if (node.superClass && this.isRelational("<")) {
	        node.superTypeParameters = this.flow_parseTypeParameterInstantiation();
	      }
	      if (this.isContextual("implements")) {
	        this.next();
	        var implemented = node["implements"] = [];
	        do {
	          var node = this.startNode();
	          node.id = this.parseIdent();
	          if (this.isRelational("<")) {
	            node.typeParameters = this.flow_parseTypeParameterInstantiation();
	          } else {
	            node.typeParameters = null;
	          }
	          implemented.push(this.finishNode(node, "ClassImplements"));
	        } while (this.eat(tt.comma));
	      }
	    };
	  });
	
	  instance.extend("parseObjPropValue", function (inner) {
	    return function (prop) {
	      var typeParameters;
	      if (this.isRelational("<")) {
	        typeParameters = this.flow_parseTypeParameterDeclaration();
	        if (this.type !== tt.parenL) this.unexpected();
	      }
	      inner.apply(this, arguments);
	      prop.value.typeParameters = typeParameters;
	    };
	  });
	
	  instance.extend("parseAssignableListItemTypes", function (inner) {
	    return function (param) {
	      if (this.eat(tt.question)) {
	        param.optional = true;
	      }
	      if (this.type === tt.colon) {
	        param.typeAnnotation = this.flow_parseTypeAnnotation();
	      }
	      this.finishNode(param, param.type);
	      return param;
	    };
	  });
	
	  instance.extend("parseImportSpecifiers", function (inner) {
	    return function (node) {
	      node.isType = false;
	      if (this.isContextual("type")) {
	        var start = this.markPosition();
	        var typeId = this.parseIdent();
	        if (this.type === tt.name && this.value !== "from" || this.type === tt.braceL || this.type === tt.star) {
	          node.isType = true;
	        } else {
	          node.specifiers.push(this.parseImportSpecifierDefault(typeId, start));
	          if (this.isContextual("from")) return;
	          this.eat(tt.comma);
	        }
	      }
	      inner.call(this, node);
	    };
	  });
	
	  // function foo<T>() {}
	  instance.extend("parseFunctionParams", function (inner) {
	    return function (node) {
	      if (this.isRelational("<")) {
	        node.typeParameters = this.flow_parseTypeParameterDeclaration();
	      }
	      inner.call(this, node);
	    };
	  });
	
	  // var foo: string = bar
	  instance.extend("parseVarHead", function (inner) {
	    return function (decl) {
	      inner.call(this, decl);
	      if (this.type === tt.colon) {
	        decl.id.typeAnnotation = this.flow_parseTypeAnnotation();
	        this.finishNode(decl.id, decl.id.type);
	      }
	    };
	  });
	};

/***/ },
/* 219 */
/*!*********************************************!*\
  !*** ./~/babel-core/lib/acorn/src/index.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// Acorn is a tiny, fast JavaScript parser written in JavaScript.
	//
	// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
	// various contributors and released under an MIT license.
	//
	// Git repositories for Acorn are available at
	//
	//     http://marijnhaverbeke.nl/git/acorn
	//     https://github.com/marijnh/acorn.git
	//
	// Please use the [github bug tracker][ghbt] to report issues.
	//
	// [ghbt]: https://github.com/marijnh/acorn/issues
	//
	// This file defines the main parser interface. The library also comes
	// with a [error-tolerant parser][dammit] and an
	// [abstract syntax tree walker][walk], defined in other files.
	//
	// [dammit]: acorn_loose.js
	// [walk]: util/walk.js
	
	"use strict";
	
	exports.__esModule = true;
	
	// The main exported interface (under `self.acorn` when in the
	// browser) is a `parse` function that takes a code string and
	// returns an abstract syntax tree as specified by [Mozilla parser
	// API][api].
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	
	exports.parse = parse;
	
	// This function tries to parse a single expression at a given
	// offset in a string. Useful for parsing mixed-language formats
	// that embed JavaScript expressions.
	
	exports.parseExpressionAt = parseExpressionAt;
	
	// Acorn is organized as a tokenizer and a recursive-descent parser.
	// The `tokenize` export provides an interface to the tokenizer.
	// Because the tokenizer is optimized for being efficiently used by
	// the Acorn parser itself, this interface is somewhat crude and not
	// very modular.
	
	exports.tokenizer = tokenizer;
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _options = __webpack_require__(/*! ./options */ 225);
	
	__webpack_require__(/*! ./parseutil */ 227);
	
	__webpack_require__(/*! ./statement */ 228);
	
	__webpack_require__(/*! ./lval */ 229);
	
	__webpack_require__(/*! ./expression */ 230);
	
	__webpack_require__(/*! ./lookahead */ 231);
	
	exports.Parser = _state.Parser;
	exports.plugins = _state.plugins;
	exports.defaultOptions = _options.defaultOptions;
	
	var _location = __webpack_require__(/*! ./location */ 220);
	
	exports.SourceLocation = _location.SourceLocation;
	exports.getLineInfo = _location.getLineInfo;
	
	var _node = __webpack_require__(/*! ./node */ 232);
	
	exports.Node = _node.Node;
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	exports.TokenType = _tokentype.TokenType;
	exports.tokTypes = _tokentype.types;
	
	var _tokencontext = __webpack_require__(/*! ./tokencontext */ 233);
	
	exports.TokContext = _tokencontext.TokContext;
	exports.tokContexts = _tokencontext.types;
	
	var _identifier = __webpack_require__(/*! ./identifier */ 222);
	
	exports.isIdentifierChar = _identifier.isIdentifierChar;
	exports.isIdentifierStart = _identifier.isIdentifierStart;
	
	var _tokenize = __webpack_require__(/*! ./tokenize */ 234);
	
	exports.Token = _tokenize.Token;
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 224);
	
	exports.isNewLine = _whitespace.isNewLine;
	exports.lineBreak = _whitespace.lineBreak;
	exports.lineBreakG = _whitespace.lineBreakG;
	var version = "1.0.0";exports.version = version;
	
	function parse(input, options) {
	  var p = parser(options, input);
	  var startPos = p.options.locations ? [p.pos, p.curPosition()] : p.pos;
	  p.nextToken();
	  return p.parseTopLevel(p.options.program || p.startNodeAt(startPos));
	}
	
	function parseExpressionAt(input, pos, options) {
	  var p = parser(options, input, pos);
	  p.nextToken();
	  return p.parseExpression();
	}
	
	function tokenizer(input, options) {
	  return parser(options, input);
	}
	
	function parser(options, input) {
	  return new _state.Parser((0, _options.getOptions)(options), String(input));
	}

/***/ },
/* 220 */
/*!************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/location.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	// The `getLineInfo` function is mostly useful when the
	// `locations` option is off (for performance reasons) and you
	// want to find the line/column position for a given character
	// offset. `input` should be the code string that the offset refers
	// into.
	
	exports.getLineInfo = getLineInfo;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 224);
	
	// These are used when `options.locations` is on, for the
	// `startLoc` and `endLoc` properties.
	
	var Position = (function () {
	  function Position(line, col) {
	    _classCallCheck(this, Position);
	
	    this.line = line;
	    this.column = col;
	  }
	
	  Position.prototype.offset = function offset(n) {
	    return new Position(this.line, this.column + n);
	  };
	
	  return Position;
	})();
	
	exports.Position = Position;
	
	var SourceLocation = function SourceLocation(p, start, end) {
	  _classCallCheck(this, SourceLocation);
	
	  this.start = start;
	  this.end = end;
	  if (p.sourceFile !== null) this.source = p.sourceFile;
	};
	
	exports.SourceLocation = SourceLocation;
	
	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    _whitespace.lineBreakG.lastIndex = cur;
	    var match = _whitespace.lineBreakG.exec(input);
	    if (match && match.index < offset) {
	      ++line;
	      cur = match.index + match[0].length;
	    } else {
	      return new Position(line, offset - cur);
	    }
	  }
	}
	
	var pp = _state.Parser.prototype;
	
	// This function is used to raise exceptions on parse errors. It
	// takes an offset integer (into the current `input`) to indicate
	// the location of the error, attaches the position to the end
	// of the error message, and then raises a `SyntaxError` with that
	// message.
	
	pp.raise = function (pos, message) {
	  var loc = getLineInfo(this.input, pos);
	  message += " (" + loc.line + ":" + loc.column + ")";
	  var err = new SyntaxError(message);
	  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
	  throw err;
	};
	
	pp.curPosition = function () {
	  return new Position(this.curLine, this.pos - this.lineStart);
	};
	
	pp.markPosition = function () {
	  return this.options.locations ? [this.start, this.startLoc] : this.start;
	};

/***/ },
/* 221 */
/*!*********************************************!*\
  !*** ./~/babel-core/lib/acorn/src/state.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Parser = Parser;
	
	var _identifier = __webpack_require__(/*! ./identifier */ 222);
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	function Parser(options, input, startPos) {
	  this.options = options;
	  this.loadPlugins(this.options.plugins);
	  this.sourceFile = this.options.sourceFile || null;
	  this.isKeyword = _identifier.keywords[this.options.ecmaVersion >= 6 ? 6 : 5];
	  this.isReservedWord = _identifier.reservedWords[this.options.ecmaVersion];
	  this.input = input;
	
	  // Set up token state
	
	  // The current position of the tokenizer in the input.
	  if (startPos) {
	    this.pos = startPos;
	    this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
	    this.curLine = this.input.slice(0, this.lineStart).split(_tokentype.lineBreak).length;
	  } else {
	    this.pos = this.lineStart = 0;
	    this.curLine = 1;
	  }
	
	  // Properties of the current token:
	  // Its type
	  this.type = _tokentype.types.eof;
	  // For tokens that include more information than their type, the value
	  this.value = null;
	  // Its start and end offset
	  this.start = this.end = this.pos;
	  // And, if locations are used, the {line, column} object
	  // corresponding to those offsets
	  this.startLoc = this.endLoc = null;
	
	  // Position information for the previous token
	  this.lastTokEndLoc = this.lastTokStartLoc = null;
	  this.lastTokStart = this.lastTokEnd = this.pos;
	
	  // The context stack is used to superficially track syntactic
	  // context to predict whether a regular expression is allowed in a
	  // given position.
	  this.context = this.initialContext();
	  this.exprAllowed = true;
	
	  // Figure out if it's a module code.
	  this.inModule = this.options.sourceType === "module";
	  this.strict = this.options.strictMode === false ? false : this.inModule;
	
	  // Used to signify the start of a potential arrow function
	  this.potentialArrowAt = -1;
	
	  // Flags to track whether we are in a function, a generator.
	  this.inFunction = this.inGenerator = false;
	  // Labels in scope.
	  this.labels = [];
	
	  this.decorators = [];
	
	  // If enabled, skip leading hashbang line.
	  if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
	}
	
	Parser.prototype.extend = function (name, f) {
	  this[name] = f(this[name]);
	};
	
	// Registered plugins
	
	var plugins = {};
	
	exports.plugins = plugins;
	Parser.prototype.loadPlugins = function (plugins) {
	  for (var _name in plugins) {
	    var plugin = exports.plugins[_name];
	    if (!plugin) throw new Error("Plugin '" + _name + "' not found");
	    plugin(this, plugins[_name]);
	  }
	};

/***/ },
/* 222 */
/*!**************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/identifier.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	// Test whether a given character code starts an identifier.
	
	exports.isIdentifierStart = isIdentifierStart;
	
	// Test whether a given character is part of an identifier.
	
	exports.isIdentifierChar = isIdentifierChar;
	// This is a trick taken from Esprima. It turns out that, on
	// non-Chrome browsers, to check whether a string is in a set, a
	// predicate containing a big ugly `switch` statement is faster than
	// a regular expression, and on Chrome the two are about on par.
	// This function uses `eval` (non-lexical) to produce such a
	// predicate from a space-separated string of words.
	//
	// It starts by sorting the words by length.
	
	function makePredicate(words) {
	  words = words.split(" ");
	  return function (str) {
	    return words.indexOf(str) >= 0;
	  };
	}
	
	// Reserved word lists for various dialects of the language
	
	var reservedWords = {
	  3: makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
	  5: makePredicate("class enum extends super const export import"),
	  6: makePredicate("enum await"),
	  strict: makePredicate("implements interface let package private protected public static yield"),
	  strictBind: makePredicate("eval arguments")
	};
	
	exports.reservedWords = reservedWords;
	// And the keywords
	
	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
	
	var keywords = {
	  5: makePredicate(ecma5AndLessKeywords),
	  6: makePredicate(ecma5AndLessKeywords + " let const class extends export import yield super")
	};
	
	exports.keywords = keywords;
	// ## Character categories
	
	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `tools/generate-identifier-regex.js`.
	
	var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
	var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿";
	
	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	
	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by tools/generate-identifier-regex.js
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];
	
	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function isInAstralSet(code, set) {
	  var pos = 65536;
	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }
	}
	function isIdentifierStart(code, astral) {
	  if (code < 65) return code === 36;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes);
	}
	
	function isIdentifierChar(code, astral) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}

/***/ },
/* 223 */
/*!*************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/tokentype.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// ## Token types
	
	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.
	
	// All token type variables start with an underscore, to make them
	// easy to recognize.
	
	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.
	
	var TokenType = function TokenType(label) {
	  var conf = arguments[1] === undefined ? {} : arguments[1];
	
	  _classCallCheck(this, TokenType);
	
	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.rightAssociative = !!conf.rightAssociative;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop || null;
	  this.updateContext = null;
	};
	
	exports.TokenType = TokenType;
	
	function binop(name, prec) {
	  return new TokenType(name, { beforeExpr: true, binop: prec });
	}
	var beforeExpr = { beforeExpr: true },
	    startsExpr = { startsExpr: true };
	
	var types = {
	  num: new TokenType("num", startsExpr),
	  regexp: new TokenType("regexp", startsExpr),
	  string: new TokenType("string", startsExpr),
	  name: new TokenType("name", startsExpr),
	  eof: new TokenType("eof"),
	
	  // Punctuation token types.
	  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
	  braceR: new TokenType("}"),
	  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", beforeExpr),
	  semi: new TokenType(";", beforeExpr),
	  colon: new TokenType(":", beforeExpr),
	  doubleColon: new TokenType("::", beforeExpr),
	  dot: new TokenType("."),
	  question: new TokenType("?", beforeExpr),
	  arrow: new TokenType("=>", beforeExpr),
	  template: new TokenType("template"),
	  ellipsis: new TokenType("...", beforeExpr),
	  backQuote: new TokenType("`", startsExpr),
	  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
	  at: new TokenType("@"),
	
	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator.
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.
	
	  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
	  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
	  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
	  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
	  logicalOR: binop("||", 1),
	  logicalAND: binop("&&", 2),
	  bitwiseOR: binop("|", 3),
	  bitwiseXOR: binop("^", 4),
	  bitwiseAND: binop("&", 5),
	  equality: binop("==/!=", 6),
	  relational: binop("</>", 7),
	  bitShift: binop("<</>>", 8),
	  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
	  modulo: binop("%", 10),
	  star: binop("*", 10),
	  slash: binop("/", 10),
	  exponent: new TokenType("**", { beforeExpr: true, binop: 11, rightAssociative: true })
	};
	
	exports.types = types;
	// Map keyword names to token types.
	
	var keywords = {};
	
	exports.keywords = keywords;
	// Succinct definitions of keyword token types
	function kw(name) {
	  var options = arguments[1] === undefined ? {} : arguments[1];
	
	  options.keyword = name;
	  keywords[name] = types["_" + name] = new TokenType(name, options);
	}
	
	kw("break");
	kw("case", beforeExpr);
	kw("catch");
	kw("continue");
	kw("debugger");
	kw("default");
	kw("do", { isLoop: true });
	kw("else", beforeExpr);
	kw("finally");
	kw("for", { isLoop: true });
	kw("function", startsExpr);
	kw("if");
	kw("return", beforeExpr);
	kw("switch");
	kw("throw", beforeExpr);
	kw("try");
	kw("var");
	kw("let");
	kw("const");
	kw("while", { isLoop: true });
	kw("with");
	kw("new", { beforeExpr: true, startsExpr: true });
	kw("this", startsExpr);
	kw("super", startsExpr);
	kw("class");
	kw("extends", beforeExpr);
	kw("export");
	kw("import");
	kw("yield", { beforeExpr: true, startsExpr: true });
	kw("null", startsExpr);
	kw("true", startsExpr);
	kw("false", startsExpr);
	kw("in", { beforeExpr: true, binop: 7 });
	kw("instanceof", { beforeExpr: true, binop: 7 });
	kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

/***/ },
/* 224 */
/*!**************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/whitespace.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.isNewLine = isNewLine;
	// Matches a whole line break (where CRLF is considered a single
	// line break). Used to count lines.
	
	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	exports.lineBreak = lineBreak;
	var lineBreakG = new RegExp(lineBreak.source, "g");
	
	exports.lineBreakG = lineBreakG;
	
	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 8232 || code == 8233;
	}
	
	var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	exports.nonASCIIwhitespace = nonASCIIwhitespace;

/***/ },
/* 225 */
/*!***********************************************!*\
  !*** ./~/babel-core/lib/acorn/src/options.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	// Interpret and default an options object
	
	exports.getOptions = getOptions;
	
	var _util = __webpack_require__(/*! ./util */ 226);
	
	var _location = __webpack_require__(/*! ./location */ 220);
	
	// A second optional argument can be given to further configure
	// the parser process. These options are recognized:
	
	var defaultOptions = {
	  // `ecmaVersion` indicates the ECMAScript version to parse. Must
	  // be either 3, or 5, or 6. This influences support for strict
	  // mode, the set of reserved words, support for getters and
	  // setters and other features.
	  ecmaVersion: 5,
	  // Source type ("script" or "module") for different semantics
	  sourceType: "script",
	  // `onInsertedSemicolon` can be a callback that will be called
	  // when a semicolon is automatically inserted. It will be passed
	  // th position of the comma as an offset, and if `locations` is
	  // enabled, it is given the location as a `{line, column}` object
	  // as second argument.
	  onInsertedSemicolon: null,
	  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	  // trailing commas.
	  onTrailingComma: null,
	  // By default, reserved words are not enforced. Disable
	  // `allowReserved` to enforce them. When this option has the
	  // value "never", reserved words and keywords can also not be
	  // used as property names.
	  allowReserved: true,
	  // When enabled, a return at the top level is not considered an
	  // error.
	  allowReturnOutsideFunction: false,
	  // When enabled, import/export statements are not constrained to
	  // appearing at the top of the program.
	  allowImportExportEverywhere: false,
	  // When enabled, hashbang directive in the beginning of file
	  // is allowed and treated as a line comment.
	  allowHashBang: false,
	  // When `locations` is on, `loc` properties holding objects with
	  // `start` and `end` properties in `{line, column}` form (with
	  // line being 1-based and column 0-based) will be attached to the
	  // nodes.
	  locations: false,
	  // A function can be passed as `onToken` option, which will
	  // cause Acorn to call that function with object in the same
	  // format as tokenize() returns. Note that you are not
	  // allowed to call the parser from the callback—that will
	  // corrupt its internal state.
	  onToken: null,
	  // A function can be passed as `onComment` option, which will
	  // cause Acorn to call that function with `(block, text, start,
	  // end)` parameters whenever a comment is skipped. `block` is a
	  // boolean indicating whether this is a block (`/* */`) comment,
	  // `text` is the content of the comment, and `start` and `end` are
	  // character offsets that denote the start and end of the comment.
	  // When the `locations` option is on, two more parameters are
	  // passed, the full `{line, column}` locations of the start and
	  // end of the comments. Note that you are not allowed to call the
	  // parser from the callback—that will corrupt its internal state.
	  onComment: null,
	  // Nodes have their start and end characters offsets recorded in
	  // `start` and `end` properties (directly on the node, rather than
	  // the `loc` object, which holds line/column data. To also add a
	  // [semi-standardized][range] `range` property holding a `[start,
	  // end]` array with the same numbers, set the `ranges` option to
	  // `true`.
	  //
	  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	  ranges: false,
	  // It is possible to parse multiple files into a single AST by
	  // passing the tree produced by parsing the first file as
	  // `program` option in subsequent parses. This will add the
	  // toplevel forms of the parsed file to the `Program` (top) node
	  // of an existing parse tree.
	  program: null,
	  // When `locations` is on, you can pass this to record the source
	  // file in every node's `loc` object.
	  sourceFile: null,
	  // This value, if given, is stored in every node, whether
	  // `locations` is on or off.
	  directSourceFile: null,
	  // When enabled, parenthesized expressions are represented by
	  // (non-standard) ParenthesizedExpression nodes
	  preserveParens: false,
	  plugins: {},
	  // Babel-specific options
	  features: {},
	  strictMode: null
	};exports.defaultOptions = defaultOptions;
	
	function getOptions(opts) {
	  var options = {};
	  for (var opt in defaultOptions) {
	    options[opt] = opts && (0, _util.has)(opts, opt) ? opts[opt] : defaultOptions[opt];
	  }if ((0, _util.isArray)(options.onToken)) {
	    (function () {
	      var tokens = options.onToken;
	      options.onToken = function (token) {
	        return tokens.push(token);
	      };
	    })();
	  }
	  if ((0, _util.isArray)(options.onComment)) options.onComment = pushComment(options, options.onComment);
	
	  return options;
	}
	
	function pushComment(options, array) {
	  return function (block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? "Block" : "Line",
	      value: text,
	      start: start,
	      end: end
	    };
	    if (options.locations) comment.loc = new _location.SourceLocation(this, startLoc, endLoc);
	    if (options.ranges) comment.range = [start, end];
	    array.push(comment);
	  };
	}

/***/ },
/* 226 */
/*!********************************************!*\
  !*** ./~/babel-core/lib/acorn/src/util.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.isArray = isArray;
	
	// Checks if an object has a property.
	
	exports.has = has;
	
	function isArray(obj) {
	  return Object.prototype.toString.call(obj) === "[object Array]";
	}
	
	function has(obj, propName) {
	  return Object.prototype.hasOwnProperty.call(obj, propName);
	}

/***/ },
/* 227 */
/*!*************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/parseutil.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 224);
	
	var pp = _state.Parser.prototype;
	
	// ## Parser utilities
	
	// Test whether a statement node is the string literal `"use strict"`.
	
	pp.isUseStrict = function (stmt) {
	  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
	};
	
	// Predicate that tests whether the next token is of the given
	// type, and if yes, consumes it as a side effect.
	
	pp.eat = function (type) {
	  if (this.type === type) {
	    this.next();
	    return true;
	  } else {
	    return false;
	  }
	};
	
	// Tests whether parsed token is a contextual keyword.
	
	pp.isContextual = function (name) {
	  return this.type === _tokentype.types.name && this.value === name;
	};
	
	// Consumes contextual keyword if possible.
	
	pp.eatContextual = function (name) {
	  return this.value === name && this.eat(_tokentype.types.name);
	};
	
	// Asserts that following token is given contextual keyword.
	
	pp.expectContextual = function (name) {
	  if (!this.eatContextual(name)) this.unexpected();
	};
	
	// Test whether a semicolon can be inserted at the current position.
	
	pp.canInsertSemicolon = function () {
	  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	};
	
	pp.insertSemicolon = function () {
	  if (this.canInsertSemicolon()) {
	    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
	    return true;
	  }
	};
	
	// Consume a semicolon, or, failing that, see if we are allowed to
	// pretend that there is a semicolon at this position.
	
	pp.semicolon = function () {
	  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
	};
	
	pp.afterTrailingComma = function (tokType) {
	  if (this.type == tokType) {
	    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
	    this.next();
	    return true;
	  }
	};
	
	// Expect a token of a given type. If found, consume it, otherwise,
	// raise an unexpected token error.
	
	pp.expect = function (type) {
	  this.eat(type) || this.unexpected();
	};
	
	// Raise an unexpected token error.
	
	pp.unexpected = function (pos) {
	  this.raise(pos != null ? pos : this.start, "Unexpected token");
	};

/***/ },
/* 228 */
/*!*************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/statement.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 224);
	
	var pp = _state.Parser.prototype;
	
	// ### Statement parsing
	
	// Parse a program. Initializes the parser, reads any number of
	// statements, and wraps them in a Program node.  Optionally takes a
	// `program` argument.  If present, the statements will be appended
	// to its body instead of creating a new node.
	
	pp.parseTopLevel = function (node) {
	  var first = true;
	  if (!node.body) node.body = [];
	  while (this.type !== _tokentype.types.eof) {
	    var stmt = this.parseStatement(true, true);
	    node.body.push(stmt);
	    if (first && this.isUseStrict(stmt)) this.setStrict(true);
	    first = false;
	  }
	  this.next();
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program");
	};
	
	var loopLabel = { kind: "loop" },
	    switchLabel = { kind: "switch" };
	
	// Parse a single statement.
	//
	// If expecting a statement and finding a slash operator, parse a
	// regular expression literal. This is to handle cases like
	// `if (foo) /blah/.exec(foo)`, where looking at the previous token
	// does not help.
	
	pp.parseStatement = function (declaration, topLevel) {
	  if (this.type === _tokentype.types.at) {
	    this.parseDecorators(true);
	  }
	
	  var starttype = this.type,
	      node = this.startNode();
	
	  // Most types of statements are recognized by the keyword they
	  // start with. Many are trivial to parse, some require a bit of
	  // complexity.
	
	  switch (starttype) {
	    case _tokentype.types._break:case _tokentype.types._continue:
	      return this.parseBreakContinueStatement(node, starttype.keyword);
	    case _tokentype.types._debugger:
	      return this.parseDebuggerStatement(node);
	    case _tokentype.types._do:
	      return this.parseDoStatement(node);
	    case _tokentype.types._for:
	      return this.parseForStatement(node);
	    case _tokentype.types._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
	      return this.parseFunctionStatement(node);
	
	    case _tokentype.types._class:
	      if (!declaration) this.unexpected();
	      this.takeDecorators(node);
	      return this.parseClass(node, true);
	
	    case _tokentype.types._if:
	      return this.parseIfStatement(node);
	    case _tokentype.types._return:
	      return this.parseReturnStatement(node);
	    case _tokentype.types._switch:
	      return this.parseSwitchStatement(node);
	    case _tokentype.types._throw:
	      return this.parseThrowStatement(node);
	    case _tokentype.types._try:
	      return this.parseTryStatement(node);
	    case _tokentype.types._let:case _tokentype.types._const:
	      if (!declaration) this.unexpected(); // NOTE: falls through to _var
	    case _tokentype.types._var:
	      return this.parseVarStatement(node, starttype);
	    case _tokentype.types._while:
	      return this.parseWhileStatement(node);
	    case _tokentype.types._with:
	      return this.parseWithStatement(node);
	    case _tokentype.types.braceL:
	      return this.parseBlock();
	    case _tokentype.types.semi:
	      return this.parseEmptyStatement(node);
	    case _tokentype.types._export:
	    case _tokentype.types._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
	        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
	      }
	      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);
	
	    case _tokentype.types.name:
	      if (this.options.features["es7.asyncFunctions"] && this.value === "async" && this.lookahead().type === _tokentype.types._function) {
	        this.next();
	        this.expect(_tokentype.types._function);
	        return this.parseFunction(node, true, false, true);
	      }
	
	    // If the statement does not start with a statement keyword or a
	    // brace, it's an ExpressionStatement or LabeledStatement. We
	    // simply start parsing an expression, and afterwards, if the
	    // next token is a colon and the expression was a simple
	    // Identifier node, we switch to interpreting it as a label.
	    default:
	      var maybeName = this.value,
	          expr = this.parseExpression();
	      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
	  }
	};
	
	pp.takeDecorators = function (node) {
	  if (this.decorators.length) {
	    node.decorators = this.decorators;
	    this.decorators = [];
	  }
	};
	
	pp.parseDecorators = function (allowExport) {
	  while (this.type === _tokentype.types.at) {
	    this.decorators.push(this.parseDecorator());
	  }
	
	  if (allowExport && this.type === _tokentype.types._export) {
	    return;
	  }
	
	  if (this.type !== _tokentype.types._class) {
	    this.raise(this.start, "Leading decorators must be attached to a class declaration");
	  }
	};
	
	pp.parseDecorator = function (allowExport) {
	  if (!this.options.features["es7.decorators"]) {
	    this.unexpected();
	  }
	  var node = this.startNode();
	  this.next();
	  node.expression = this.parseMaybeAssign();
	  return this.finishNode(node, "Decorator");
	};
	
	pp.parseBreakContinueStatement = function (node, keyword) {
	  var isBreak = keyword == "break";
	  this.next();
	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
	    node.label = this.parseIdent();
	    this.semicolon();
	  }
	
	  // Verify that there is an actual destination to break or
	  // continue to.
	  for (var i = 0; i < this.labels.length; ++i) {
	    var lab = this.labels[i];
	    if (node.label == null || lab.name === node.label.name) {
	      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	      if (node.label && isBreak) break;
	    }
	  }
	  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	};
	
	pp.parseDebuggerStatement = function (node) {
	  this.next();
	  this.semicolon();
	  return this.finishNode(node, "DebuggerStatement");
	};
	
	pp.parseDoStatement = function (node) {
	  var start = this.markPosition();
	  this.next();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  if (this.options.features["es7.doExpressions"] && this.type !== _tokentype.types._while) {
	    var container = this.startNodeAt(start);
	    container.expression = this.finishNode(node, "DoExpression");
	    this.semicolon();
	    return this.finishNode(container, "ExpressionStatement");
	  }
	  this.expect(_tokentype.types._while);
	  node.test = this.parseParenExpression();
	  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
	  return this.finishNode(node, "DoWhileStatement");
	};
	
	// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	// loop is non-trivial. Basically, we have to parse the init `var`
	// statement or expression, disallowing the `in` operator (see
	// the second parameter to `parseExpression`), and then check
	// whether the next token is `in` or `of`. When there is no init
	// part (semicolon immediately after the opening parenthesis), it
	// is a regular `for` loop.
	
	pp.parseForStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  this.expect(_tokentype.types.parenL);
	  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
	  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {
	    var _init = this.startNode(),
	        varKind = this.type;
	    this.next();
	    this.parseVar(_init, true, varKind);
	    this.finishNode(_init, "VariableDeclaration");
	    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
	    return this.parseFor(node, _init);
	  }
	  var refShorthandDefaultPos = { start: 0 };
	  var init = this.parseExpression(true, refShorthandDefaultPos);
	  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
	    this.toAssignable(init);
	    this.checkLVal(init);
	    return this.parseForIn(node, init);
	  } else if (refShorthandDefaultPos.start) {
	    this.unexpected(refShorthandDefaultPos.start);
	  }
	  return this.parseFor(node, init);
	};
	
	pp.parseFunctionStatement = function (node) {
	  this.next();
	  return this.parseFunction(node, true);
	};
	
	pp.parseIfStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  node.consequent = this.parseStatement(false);
	  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
	  return this.finishNode(node, "IfStatement");
	};
	
	pp.parseReturnStatement = function (node) {
	  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	  this.next();
	
	  // In `return` (and `break`/`continue`), the keywords with
	  // optional arguments, we eagerly look for a semicolon or the
	  // possibility to insert one.
	
	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
	    node.argument = this.parseExpression();this.semicolon();
	  }
	  return this.finishNode(node, "ReturnStatement");
	};
	
	pp.parseSwitchStatement = function (node) {
	  this.next();
	  node.discriminant = this.parseParenExpression();
	  node.cases = [];
	  this.expect(_tokentype.types.braceL);
	  this.labels.push(switchLabel);
	
	  // Statements under must be grouped (by label) in SwitchCase
	  // nodes. `cur` is used to keep the node that we are currently
	  // adding statements to.
	
	  for (var cur, sawDefault; this.type != _tokentype.types.braceR;) {
	    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
	      var isCase = this.type === _tokentype.types._case;
	      if (cur) this.finishNode(cur, "SwitchCase");
	      node.cases.push(cur = this.startNode());
	      cur.consequent = [];
	      this.next();
	      if (isCase) {
	        cur.test = this.parseExpression();
	      } else {
	        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
	        sawDefault = true;
	        cur.test = null;
	      }
	      this.expect(_tokentype.types.colon);
	    } else {
	      if (!cur) this.unexpected();
	      cur.consequent.push(this.parseStatement(true));
	    }
	  }
	  if (cur) this.finishNode(cur, "SwitchCase");
	  this.next(); // Closing brace
	  this.labels.pop();
	  return this.finishNode(node, "SwitchStatement");
	};
	
	pp.parseThrowStatement = function (node) {
	  this.next();
	  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	  node.argument = this.parseExpression();
	  this.semicolon();
	  return this.finishNode(node, "ThrowStatement");
	};
	
	// Reused empty array added for node fields that are always empty.
	
	var empty = [];
	
	pp.parseTryStatement = function (node) {
	  this.next();
	  node.block = this.parseBlock();
	  node.handler = null;
	  if (this.type === _tokentype.types._catch) {
	    var clause = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    clause.param = this.parseBindingAtom();
	    this.checkLVal(clause.param, true);
	    this.expect(_tokentype.types.parenR);
	    clause.guard = null;
	    clause.body = this.parseBlock();
	    node.handler = this.finishNode(clause, "CatchClause");
	  }
	  node.guardedHandlers = empty;
	  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
	  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	  return this.finishNode(node, "TryStatement");
	};
	
	pp.parseVarStatement = function (node, kind) {
	  this.next();
	  this.parseVar(node, false, kind);
	  this.semicolon();
	  return this.finishNode(node, "VariableDeclaration");
	};
	
	pp.parseWhileStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "WhileStatement");
	};
	
	pp.parseWithStatement = function (node) {
	  if (this.strict) this.raise(this.start, "'with' in strict mode");
	  this.next();
	  node.object = this.parseParenExpression();
	  node.body = this.parseStatement(false);
	  return this.finishNode(node, "WithStatement");
	};
	
	pp.parseEmptyStatement = function (node) {
	  this.next();
	  return this.finishNode(node, "EmptyStatement");
	};
	
	pp.parseLabeledStatement = function (node, maybeName, expr) {
	  for (var i = 0; i < this.labels.length; ++i) {
	    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
	  this.labels.push({ name: maybeName, kind: kind });
	  node.body = this.parseStatement(true);
	  this.labels.pop();
	  node.label = expr;
	  return this.finishNode(node, "LabeledStatement");
	};
	
	pp.parseExpressionStatement = function (node, expr) {
	  node.expression = expr;
	  this.semicolon();
	  return this.finishNode(node, "ExpressionStatement");
	};
	
	// Parse a semicolon-enclosed block of statements, handling `"use
	// strict"` declarations when `allowStrict` is true (used for
	// function bodies).
	
	pp.parseBlock = function (allowStrict) {
	  var node = this.startNode(),
	      first = true,
	      oldStrict = undefined;
	  node.body = [];
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    var stmt = this.parseStatement(true);
	    node.body.push(stmt);
	    if (first && allowStrict && this.isUseStrict(stmt)) {
	      oldStrict = this.strict;
	      this.setStrict(this.strict = true);
	    }
	    first = false;
	  }
	  if (oldStrict === false) this.setStrict(false);
	  return this.finishNode(node, "BlockStatement");
	};
	
	// Parse a regular `for` loop. The disambiguation code in
	// `parseStatement` will already have parsed the init statement or
	// expression.
	
	pp.parseFor = function (node, init) {
	  node.init = init;
	  this.expect(_tokentype.types.semi);
	  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
	  this.expect(_tokentype.types.semi);
	  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "ForStatement");
	};
	
	// Parse a `for`/`in` and `for`/`of` loop, which are almost
	// same from parser's perspective.
	
	pp.parseForIn = function (node, init) {
	  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  node.left = init;
	  node.right = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, type);
	};
	
	// Parse a list of variable declarations.
	
	pp.parseVar = function (node, isFor, kind) {
	  node.declarations = [];
	  node.kind = kind.keyword;
	  for (;;) {
	    var decl = this.startNode();
	    this.parseVarHead(decl);
	    if (this.eat(_tokentype.types.eq)) {
	      decl.init = this.parseMaybeAssign(isFor);
	    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.unexpected();
	    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
	      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
	    } else {
	      decl.init = null;
	    }
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	    if (!this.eat(_tokentype.types.comma)) break;
	  }
	  return node;
	};
	
	pp.parseVarHead = function (decl) {
	  decl.id = this.parseBindingAtom();
	  this.checkLVal(decl.id, true);
	};
	
	// Parse a function declaration or literal (depending on the
	// `isStatement` parameter).
	
	pp.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {
	  this.initFunction(node, isAsync);
	  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
	  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
	  this.parseFunctionParams(node);
	  this.parseFunctionBody(node, allowExpressionBody);
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	};
	
	pp.parseFunctionParams = function (node) {
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, this.options.features["es7.trailingFunctionCommas"]);
	};
	
	// Parse a class declaration or literal (depending on the
	// `isStatement` parameter).
	
	pp.parseClass = function (node, isStatement) {
	  this.next();
	  this.parseClassId(node, isStatement);
	  this.parseClassSuper(node);
	  var classBody = this.startNode();
	  classBody.body = [];
	  this.expect(_tokentype.types.braceL);
	  var decorators = [];
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (this.eat(_tokentype.types.semi)) continue;
	    if (this.type === _tokentype.types.at) {
	      decorators.push(this.parseDecorator());
	      continue;
	    }
	    var method = this.startNode();
	    if (decorators.length) {
	      method.decorators = decorators;
	      decorators = [];
	    }
	    var isGenerator = this.eat(_tokentype.types.star),
	        isAsync = false;
	    this.parsePropertyName(method);
	    if (this.type !== _tokentype.types.parenL && !method.computed && method.key.type === "Identifier" && method.key.name === "static") {
	      if (isGenerator) this.unexpected();
	      method["static"] = true;
	      isGenerator = this.eat(_tokentype.types.star);
	      this.parsePropertyName(method);
	    } else {
	      method["static"] = false;
	    }
	    if (!isGenerator && method.key.type === "Identifier" && !method.computed && this.isClassProperty()) {
	      classBody.body.push(this.parseClassProperty(method));
	      continue;
	    }
	    if (this.options.features["es7.asyncFunctions"] && this.type !== _tokentype.types.parenL && !method.computed && method.key.type === "Identifier" && method.key.name === "async") {
	      isAsync = true;
	      this.parsePropertyName(method);
	    }
	    method.kind = "method";
	    if (!method.computed && !isGenerator && !isAsync) {
	      if (method.key.type === "Identifier") {
	        if (this.type !== _tokentype.types.parenL && (method.key.name === "get" || method.key.name === "set")) {
	          method.kind = method.key.name;
	          this.parsePropertyName(method);
	        } else if (!method["static"] && method.key.name === "constructor") {
	          method.kind = "constructor";
	        }
	      } else if (!method["static"] && method.key.type === "Literal" && method.key.value === "constructor") {
	        method.kind = "constructor";
	      }
	    }
	    if (method.kind === "constructor" && method.decorators) {
	      this.raise(method.start, "You can't attach decorators to a class constructor");
	    }
	    this.parseClassMethod(classBody, method, isGenerator, isAsync);
	  }
	  if (decorators.length) {
	    this.raise(this.start, "You have trailing decorators with no method");
	  }
	  node.body = this.finishNode(classBody, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};
	
	pp.isClassProperty = function () {
	  return this.type === _tokentype.types.eq || (this.type === _tokentype.types.semi || this.canInsertSemicolon());
	};
	
	pp.parseClassProperty = function (node) {
	  if (this.type === _tokentype.types.eq) {
	    if (!this.options.features["es7.classProperties"]) this.unexpected();
	    this.next();
	    node.value = this.parseMaybeAssign();
	  } else {
	    node.value = null;
	  }
	  this.semicolon();
	  return this.finishNode(node, "ClassProperty");
	};
	
	pp.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
	  method.value = this.parseMethod(isGenerator, isAsync);
	  classBody.body.push(this.finishNode(method, "MethodDefinition"));
	};
	
	pp.parseClassId = function (node, isStatement) {
	  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
	};
	
	pp.parseClassSuper = function (node) {
	  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
	};
	
	// Parses module export declaration.
	
	pp.parseExport = function (node) {
	  this.next();
	  // export * from '...'
	  if (this.type === _tokentype.types.star) {
	    var specifier = this.startNode();
	    this.next();
	    if (this.options.features["es7.exportExtensions"] && this.eatContextual("as")) {
	      specifier.exported = this.parseIdent();
	      node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
	      this.parseExportSpecifiersMaybe(node);
	      this.parseExportFrom(node);
	    } else {
	      this.parseExportFrom(node);
	      return this.finishNode(node, "ExportAllDeclaration");
	    }
	  } else if (this.isExportDefaultSpecifier()) {
	    var specifier = this.startNode();
	    specifier.exported = this.parseIdent(true);
	    node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	    if (this.type === _tokentype.types.comma && this.lookahead().type === _tokentype.types.star) {
	      this.expect(_tokentype.types.comma);
	      var _specifier = this.startNode();
	      this.expect(_tokentype.types.star);
	      this.expectContextual("as");
	      _specifier.exported = this.parseIdent();
	      node.specifiers.push(this.finishNode(_specifier, "ExportNamespaceSpecifier"));
	    } else {
	      this.parseExportSpecifiersMaybe(node);
	    }
	    this.parseExportFrom(node);
	  } else if (this.eat(_tokentype.types._default)) {
	    // export default ...
	    var _expr = this.parseMaybeAssign();
	    var needsSemi = true;
	    if (_expr.type == "FunctionExpression" || _expr.type == "ClassExpression") {
	      needsSemi = false;
	      if (_expr.id) {
	        _expr.type = _expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
	      }
	    }
	    node.declaration = _expr;
	    if (needsSemi) this.semicolon();
	    this.checkExport(node);
	    return this.finishNode(node, "ExportDefaultDeclaration");
	  } else if (this.type.keyword || this.shouldParseExportDeclaration()) {
	    node.declaration = this.parseStatement(true);
	    node.specifiers = [];
	    node.source = null;
	  } else {
	    // export { x, y as z } [from '...']
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifiers();
	    if (this.eatContextual("from")) {
	      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	    } else {
	      node.source = null;
	    }
	    this.semicolon();
	  }
	  this.checkExport(node);
	  return this.finishNode(node, "ExportNamedDeclaration");
	};
	
	pp.isExportDefaultSpecifier = function () {
	  if (this.type === _tokentype.types.name) {
	    return this.value !== "type" && this.value !== "async";
	  }
	
	  if (this.type !== _tokentype.types._default) {
	    return false;
	  }
	
	  var lookahead = this.lookahead();
	  return lookahead.type === _tokentype.types.comma || lookahead.type === _tokentype.types.name && lookahead.value === "from";
	};
	
	pp.parseExportSpecifiersMaybe = function (node) {
	  if (this.eat(_tokentype.types.comma)) {
	    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
	  }
	};
	
	pp.parseExportFrom = function (node) {
	  this.expectContextual("from");
	  node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	  this.semicolon();
	  this.checkExport(node);
	};
	
	pp.shouldParseExportDeclaration = function () {
	  return this.options.features["es7.asyncFunctions"] && this.isContextual("async");
	};
	
	pp.checkExport = function (node) {
	  if (this.decorators.length) {
	    var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
	    if (!node.declaration || !isClass) {
	      this.raise(node.start, "You can only use decorators on an export when exporting a class");
	    }
	    this.takeDecorators(node.declaration);
	  }
	};
	
	// Parses a comma-separated list of module exports.
	
	pp.parseExportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  // export { x, y as z } [from '...']
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;
	
	    var node = this.startNode();
	    node.local = this.parseIdent(this.type === _tokentype.types._default);
	    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
	    nodes.push(this.finishNode(node, "ExportSpecifier"));
	  }
	  return nodes;
	};
	
	// Parses import declaration.
	
	pp.parseImport = function (node) {
	  this.next();
	  // import '...'
	  if (this.type === _tokentype.types.string) {
	    node.specifiers = empty;
	    node.source = this.parseExprAtom();
	  } else {
	    node.specifiers = [];
	    this.parseImportSpecifiers(node);
	    this.expectContextual("from");
	    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration");
	};
	
	// Parses a comma-separated list of module imports.
	
	pp.parseImportSpecifiers = function (node) {
	  var first = true;
	  if (this.type === _tokentype.types.name) {
	    // import defaultObj, { x, y as z } from '...'
	    var start = this.markPosition();
	    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdent(), start));
	    if (!this.eat(_tokentype.types.comma)) return;
	  }
	  if (this.type === _tokentype.types.star) {
	    var specifier = this.startNode();
	    this.next();
	    this.expectContextual("as");
	    specifier.local = this.parseIdent();
	    this.checkLVal(specifier.local, true);
	    node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
	    return;
	  }
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;
	
	    var specifier = this.startNode();
	    specifier.imported = this.parseIdent(true);
	    specifier.local = this.eatContextual("as") ? this.parseIdent() : specifier.imported;
	    this.checkLVal(specifier.local, true);
	    node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
	  }
	};
	
	pp.parseImportSpecifierDefault = function (id, start) {
	  var node = this.startNodeAt(start);
	  node.local = id;
	  this.checkLVal(node.local, true);
	  return this.finishNode(node, "ImportDefaultSpecifier");
	};

/***/ },
/* 229 */
/*!********************************************!*\
  !*** ./~/babel-core/lib/acorn/src/lval.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _identifier = __webpack_require__(/*! ./identifier */ 222);
	
	var _util = __webpack_require__(/*! ./util */ 226);
	
	var pp = _state.Parser.prototype;
	
	// Convert existing expression atom to assignable pattern
	// if possible.
	
	pp.toAssignable = function (node, isBinding) {
	  if (this.options.ecmaVersion >= 6 && node) {
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	        break;
	
	      case "ObjectExpression":
	        node.type = "ObjectPattern";
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i];
	          if (prop.type === "SpreadProperty") continue;
	          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
	          this.toAssignable(prop.value, isBinding);
	        }
	        break;
	
	      case "ArrayExpression":
	        node.type = "ArrayPattern";
	        this.toAssignableList(node.elements, isBinding);
	        break;
	
	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern";
	        } else {
	          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
	        }
	        break;
	
	      case "MemberExpression":
	        if (!isBinding) break;
	
	      default:
	        this.raise(node.start, "Assigning to rvalue");
	    }
	  }
	  return node;
	};
	
	// Convert list of expression atoms to binding list.
	
	pp.toAssignableList = function (exprList, isBinding) {
	  var end = exprList.length;
	  if (end) {
	    var last = exprList[end - 1];
	    if (last && last.type == "RestElement") {
	      --end;
	    } else if (last && last.type == "SpreadElement") {
	      last.type = "RestElement";
	      var arg = last.argument;
	      this.toAssignable(arg, isBinding);
	      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
	      --end;
	    }
	  }
	  for (var i = 0; i < end; i++) {
	    var elt = exprList[i];
	    if (elt) this.toAssignable(elt, isBinding);
	  }
	  return exprList;
	};
	
	// Parses spread element.
	
	pp.parseSpread = function (refShorthandDefaultPos) {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
	  return this.finishNode(node, "SpreadElement");
	};
	
	pp.parseRest = function () {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();
	  return this.finishNode(node, "RestElement");
	};
	
	// Parses lvalue (assignable) atom.
	
	pp.parseBindingAtom = function () {
	  if (this.options.ecmaVersion < 6) return this.parseIdent();
	  switch (this.type) {
	    case _tokentype.types.name:
	      return this.parseIdent();
	
	    case _tokentype.types.bracketL:
	      var node = this.startNode();
	      this.next();
	      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
	      return this.finishNode(node, "ArrayPattern");
	
	    case _tokentype.types.braceL:
	      return this.parseObj(true);
	
	    default:
	      this.unexpected();
	  }
	};
	
	pp.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (first) first = false;else this.expect(_tokentype.types.comma);
	    if (allowEmpty && this.type === _tokentype.types.comma) {
	      elts.push(null);
	    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
	      break;
	    } else if (this.type === _tokentype.types.ellipsis) {
	      elts.push(this.parseAssignableListItemTypes(this.parseRest()));
	      this.expect(close);
	      break;
	    } else {
	      var left = this.parseMaybeDefault();
	      this.parseAssignableListItemTypes(left);
	      elts.push(this.parseMaybeDefault(null, left));
	    }
	  }
	  return elts;
	};
	
	pp.parseAssignableListItemTypes = function (param) {
	  return param;
	};
	
	// Parses assignment pattern around given atom if possible.
	
	pp.parseMaybeDefault = function (startPos, left) {
	  startPos = startPos || this.markPosition();
	  left = left || this.parseBindingAtom();
	  if (!this.eat(_tokentype.types.eq)) return left;
	  var node = this.startNodeAt(startPos);
	  node.operator = "=";
	  node.left = left;
	  node.right = this.parseMaybeAssign();
	  return this.finishNode(node, "AssignmentPattern");
	};
	
	// Verify that a node is an lval — something that can be assigned
	// to.
	
	pp.checkLVal = function (expr, isBinding, checkClashes) {
	  switch (expr.type) {
	    case "Identifier":
	      if (this.strict && (_identifier.reservedWords.strictBind(expr.name) || _identifier.reservedWords.strict(expr.name))) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
	      if (checkClashes) {
	        if ((0, _util.has)(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash in strict mode");
	        checkClashes[expr.name] = true;
	      }
	      break;
	
	    case "MemberExpression":
	      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
	      break;
	
	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++) {
	        var prop = expr.properties[i];
	        if (prop.type === "Property") prop = prop.value;
	        this.checkLVal(prop, isBinding, checkClashes);
	      }
	      break;
	
	    case "ArrayPattern":
	      for (var i = 0; i < expr.elements.length; i++) {
	        var elem = expr.elements[i];
	        if (elem) this.checkLVal(elem, isBinding, checkClashes);
	      }
	      break;
	
	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes);
	      break;
	
	    case "SpreadProperty":
	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes);
	      break;
	
	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
	  }
	};

/***/ },
/* 230 */
/*!**************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/expression.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	// A recursive descent parser operates by defining functions for all
	// syntactic elements, and recursively calling those, each function
	// advancing the input stream and returning an AST node. Precedence
	// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
	// instead of `(!x)[1]` is handled by the fact that the parser
	// function that parses unary prefix operators is called first, and
	// in turn calls the function that parses `[]` subscripts — that
	// way, it'll receive the node for `x[1]` already parsed, and wraps
	// *that* in the unary operator node.
	//
	// Acorn uses an [operator precedence parser][opp] to handle binary
	// operator precedence, because it is much more compact than using
	// the technique outlined above, which uses different, nesting
	// functions to specify precedence, for all of the ten binary
	// precedence levels that JavaScript defines.
	//
	// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
	
	"use strict";
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _identifier = __webpack_require__(/*! ./identifier */ 222);
	
	var _util = __webpack_require__(/*! ./util */ 226);
	
	var pp = _state.Parser.prototype;
	
	// Check if property name clashes with already added.
	// Object/class getters and setters are not allowed to clash —
	// either with each other or with an init property — and in
	// strict mode, init properties are also not allowed to be repeated.
	
	pp.checkPropClash = function (prop, propHash) {
	  if (this.options.ecmaVersion >= 6) return;
	  var key = prop.key,
	      name = undefined;
	  switch (key.type) {
	    case "Identifier":
	      name = key.name;break;
	    case "Literal":
	      name = String(key.value);break;
	    default:
	      return;
	  }
	  var kind = prop.kind || "init",
	      other = undefined;
	  if ((0, _util.has)(propHash, name)) {
	    other = propHash[name];
	    var isGetSet = kind !== "init";
	    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
	  } else {
	    other = propHash[name] = {
	      init: false,
	      get: false,
	      set: false
	    };
	  }
	  other[kind] = true;
	};
	
	// ### Expression parsing
	
	// These nest, from the most general expression type at the top to
	// 'atomic', nondivisible expression types at the bottom. Most of
	// the functions will simply let the function(s) below them parse,
	// and, *if* the syntactic construct they handle is present, wrap
	// the AST node that the inner parser gave them in another node.
	
	// Parse a full expression. The optional arguments are used to
	// forbid the `in` operator (in for loops initalization expressions)
	// and provide reference for storing '=' operator inside shorthand
	// property assignment in contexts where both object expression
	// and object pattern might appear (so it's possible to raise
	// delayed syntax error at correct position).
	
	pp.parseExpression = function (noIn, refShorthandDefaultPos) {
	  var start = this.markPosition();
	  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
	  if (this.type === _tokentype.types.comma) {
	    var node = this.startNodeAt(start);
	    node.expressions = [expr];
	    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
	    return this.finishNode(node, "SequenceExpression");
	  }
	  return expr;
	};
	
	// Parse an assignment expression. This includes applications of
	// operators like `+=`.
	
	pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse) {
	  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();
	
	  var failOnShorthandAssign = undefined;
	  if (!refShorthandDefaultPos) {
	    refShorthandDefaultPos = { start: 0 };
	    failOnShorthandAssign = true;
	  } else {
	    failOnShorthandAssign = false;
	  }
	  var start = this.markPosition();
	  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
	  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
	  if (afterLeftParse) left = afterLeftParse.call(this, left, start);
	  if (this.type.isAssign) {
	    var node = this.startNodeAt(start);
	    node.operator = this.value;
	    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
	    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
	    this.checkLVal(left);
	    if (left.parenthesizedExpression) {
	      var errorMsg = undefined;
	      if (left.type === "ObjectPattern") {
	        errorMsg = "`({a}) = 0` use `({a} = 0)`";
	      } else if (left.type === "ArrayPattern") {
	        errorMsg = "`([a]) = 0` use `([a] = 0)`";
	      }
	      if (errorMsg) {
	        this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
	      }
	    }
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression");
	  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
	    this.unexpected(refShorthandDefaultPos.start);
	  }
	  return left;
	};
	
	// Parse a ternary conditional (`?:`) operator.
	
	pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {
	  var start = this.markPosition();
	  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  if (this.eat(_tokentype.types.question)) {
	    var node = this.startNodeAt(start);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    this.expect(_tokentype.types.colon);
	    node.alternate = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  return expr;
	};
	
	// Start the precedence parser.
	
	pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
	  var start = this.markPosition();
	  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  return this.parseExprOp(expr, start, -1, noIn);
	};
	
	// Parse binary operators with the operator precedence parsing
	// algorithm. `left` is the left-hand side of the operator.
	// `minPrec` provides context that allows the function to stop and
	// defer further parser to one of its callers when it encounters an
	// operator that has a lower precedence than the set it is parsing.
	
	pp.parseExprOp = function (left, leftStart, minPrec, noIn) {
	  var prec = this.type.binop;
	  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
	    if (prec > minPrec) {
	      var node = this.startNodeAt(leftStart);
	      node.left = left;
	      node.operator = this.value;
	      var op = this.type;
	      this.next();
	      var _start = this.markPosition();
	      node.right = this.parseExprOp(this.parseMaybeUnary(), _start, op.rightAssociative ? prec - 1 : prec, noIn);
	      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
	      return this.parseExprOp(node, leftStart, minPrec, noIn);
	    }
	  }
	  return left;
	};
	
	// Parse unary operators, both prefix and postfix.
	
	pp.parseMaybeUnary = function (refShorthandDefaultPos) {
	  if (this.type.prefix) {
	    var node = this.startNode(),
	        update = this.type === _tokentype.types.incDec;
	    node.operator = this.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary();
	    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
	    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
	    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  }
	  var start = this.markPosition();
	  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  while (this.type.postfix && !this.canInsertSemicolon()) {
	    var node = this.startNodeAt(start);
	    node.operator = this.value;
	    node.prefix = false;
	    node.argument = expr;
	    this.checkLVal(expr);
	    this.next();
	    expr = this.finishNode(node, "UpdateExpression");
	  }
	  return expr;
	};
	
	// Parse call, dot, and `[]`-subscript expressions.
	
	pp.parseExprSubscripts = function (refShorthandDefaultPos) {
	  var start = this.markPosition();
	  var expr = this.parseExprAtom(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  return this.parseSubscripts(expr, start);
	};
	
	pp.parseSubscripts = function (base, start, noCalls) {
	  if (!noCalls && this.eat(_tokentype.types.doubleColon)) {
	    var node = this.startNodeAt(start);
	    node.object = base;
	    node.callee = this.parseNoCallExpr();
	    return this.parseSubscripts(this.finishNode(node, "BindExpression"), start, noCalls);
	  } else if (this.eat(_tokentype.types.dot)) {
	    var node = this.startNodeAt(start);
	    node.object = base;
	    node.property = this.parseIdent(true);
	    node.computed = false;
	    return this.parseSubscripts(this.finishNode(node, "MemberExpression"), start, noCalls);
	  } else if (this.eat(_tokentype.types.bracketL)) {
	    var node = this.startNodeAt(start);
	    node.object = base;
	    node.property = this.parseExpression();
	    node.computed = true;
	    this.expect(_tokentype.types.bracketR);
	    return this.parseSubscripts(this.finishNode(node, "MemberExpression"), start, noCalls);
	  } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
	    var node = this.startNodeAt(start);
	    node.callee = base;
	    node.arguments = this.parseExprList(_tokentype.types.parenR, this.options.features["es7.trailingFunctionCommas"]);
	    return this.parseSubscripts(this.finishNode(node, "CallExpression"), start, noCalls);
	  } else if (this.type === _tokentype.types.backQuote) {
	    var node = this.startNodeAt(start);
	    node.tag = base;
	    node.quasi = this.parseTemplate();
	    return this.parseSubscripts(this.finishNode(node, "TaggedTemplateExpression"), start, noCalls);
	  }return base;
	};
	
	// Parse a no-call expression (like argument of `new` or `::` operators).
	
	pp.parseNoCallExpr = function () {
	  var start = this.markPosition();
	  return this.parseSubscripts(this.parseExprAtom(), start, true);
	};
	
	// Parse an atomic expression — either a single token that is an
	// expression, an expression started by a keyword like `function` or
	// `new`, or an expression wrapped in punctuation like `()`, `[]`,
	// or `{}`.
	
	pp.parseExprAtom = function (refShorthandDefaultPos) {
	  var node = undefined,
	      canBeArrow = this.potentialArrowAt == this.start;
	  switch (this.type) {
	    case _tokentype.types._this:
	    case _tokentype.types._super:
	      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
	      node = this.startNode();
	      this.next();
	      return this.finishNode(node, type);
	
	    case _tokentype.types._yield:
	      if (this.inGenerator) this.unexpected();
	
	    case _tokentype.types._do:
	      if (this.options.features["es7.doExpressions"]) {
	        var _node = this.startNode();
	        this.next();
	        _node.body = this.parseBlock();
	        return this.finishNode(_node, "DoExpression");
	      }
	
	    case _tokentype.types.name:
	      var start = this.markPosition();
	      node = this.startNode();
	      var id = this.parseIdent(this.type !== _tokentype.types.name);
	
	      //
	      if (this.options.features["es7.asyncFunctions"]) {
	        // async functions!
	        if (id.name === "async") {
	          // arrow functions
	          if (this.type === _tokentype.types.parenL) {
	            var expr = this.parseParenAndDistinguishExpression(start, true, true);
	            if (expr && expr.type === "ArrowFunctionExpression") {
	              return expr;
	            } else {
	              node.callee = id;
	              if (!expr) {
	                node.arguments = [];
	              } else if (expr.type === "SequenceExpression") {
	                node.arguments = expr.expressions;
	              } else {
	                node.arguments = [expr];
	              }
	              return this.parseSubscripts(this.finishNode(node, "CallExpression"), start);
	            }
	          } else if (this.type === _tokentype.types.name) {
	            id = this.parseIdent();
	            this.expect(_tokentype.types.arrow);
	            return this.parseArrowExpression(node, [id], true);
	          }
	
	          // normal functions
	          if (this.type === _tokentype.types._function && !this.canInsertSemicolon()) {
	            this.next();
	            return this.parseFunction(node, false, false, true);
	          }
	        } else if (id.name === "await") {
	          if (this.inAsync) return this.parseAwait(node);
	        }
	      }
	      //
	
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(start), [id]);
	      return id;
	
	    case _tokentype.types.regexp:
	      var value = this.value;
	      node = this.parseLiteral(value.value);
	      node.regex = { pattern: value.pattern, flags: value.flags };
	      return node;
	
	    case _tokentype.types.num:case _tokentype.types.string:
	      return this.parseLiteral(this.value);
	
	    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
	      node = this.startNode();
	      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
	      node.raw = this.type.keyword;
	      this.next();
	      return this.finishNode(node, "Literal");
	
	    case _tokentype.types.parenL:
	      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);
	
	    case _tokentype.types.bracketL:
	      node = this.startNode();
	      this.next();
	      // check whether this is array comprehension or regular array
	      if ((this.options.ecmaVersion >= 7 || this.options.features["es7.comprehensions"]) && this.type === _tokentype.types._for) {
	        return this.parseComprehension(node, false);
	      }
	      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refShorthandDefaultPos);
	      return this.finishNode(node, "ArrayExpression");
	
	    case _tokentype.types.braceL:
	      return this.parseObj(false, refShorthandDefaultPos);
	
	    case _tokentype.types._function:
	      node = this.startNode();
	      this.next();
	      return this.parseFunction(node, false);
	
	    case _tokentype.types.at:
	      this.parseDecorators();
	
	    case _tokentype.types._class:
	      node = this.startNode();
	      this.takeDecorators(node);
	      return this.parseClass(node, false);
	
	    case _tokentype.types._new:
	      return this.parseNew();
	
	    case _tokentype.types.backQuote:
	      return this.parseTemplate();
	
	    case _tokentype.types.doubleColon:
	      node = this.startNode();
	      this.next();
	      node.object = null;
	      var callee = node.callee = this.parseNoCallExpr();
	      if (callee.type !== "MemberExpression") this.raise(callee.start, "Binding should be performed on object property.");
	      return this.finishNode(node, "BindExpression");
	
	    default:
	      this.unexpected();
	  }
	};
	
	pp.parseLiteral = function (value) {
	  var node = this.startNode();
	  node.value = value;
	  node.raw = this.input.slice(this.start, this.end);
	  this.next();
	  return this.finishNode(node, "Literal");
	};
	
	pp.parseParenExpression = function () {
	  this.expect(_tokentype.types.parenL);
	  var val = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  return val;
	};
	
	pp.parseParenAndDistinguishExpression = function (start, isAsync, canBeArrow) {
	  start = start || this.markPosition();
	  var val = undefined;
	  if (this.options.ecmaVersion >= 6) {
	    this.next();
	
	    if ((this.options.features["es7.comprehensions"] || this.options.ecmaVersion >= 7) && this.type === _tokentype.types._for) {
	      return this.parseComprehension(this.startNodeAt(start), true);
	    }
	
	    var innerStart = this.markPosition(),
	        exprList = [],
	        first = true;
	    var refShorthandDefaultPos = { start: 0 },
	        spreadStart = undefined,
	        innerParenStart = undefined;
	    while (this.type !== _tokentype.types.parenR) {
	      first ? first = false : this.expect(_tokentype.types.comma);
	      if (this.type === _tokentype.types.ellipsis) {
	        var spreadNodeStart = this.markPosition();
	        spreadStart = this.start;
	        exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStart));
	        break;
	      } else {
	        if (this.type === _tokentype.types.parenL && !innerParenStart) {
	          innerParenStart = this.start;
	        }
	        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem));
	      }
	    }
	    var innerEnd = this.markPosition();
	    this.expect(_tokentype.types.parenR);
	
	    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
	      if (innerParenStart) this.unexpected(innerParenStart);
	      return this.parseParenArrowList(start, exprList, isAsync);
	    }
	
	    if (!exprList.length) {
	      if (isAsync) {
	        return;
	      } else {
	        this.unexpected(this.lastTokStart);
	      }
	    }
	    if (spreadStart) this.unexpected(spreadStart);
	    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
	
	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStart);
	      val.expressions = exprList;
	      this.finishNodeAt(val, "SequenceExpression", innerEnd);
	    } else {
	      val = exprList[0];
	    }
	  } else {
	    val = this.parseParenExpression();
	  }
	
	  if (this.options.preserveParens) {
	    var par = this.startNodeAt(start);
	    par.expression = val;
	    return this.finishNode(par, "ParenthesizedExpression");
	  } else {
	    val.parenthesizedExpression = true;
	    return val;
	  }
	};
	
	pp.parseParenArrowList = function (start, exprList, isAsync) {
	  return this.parseArrowExpression(this.startNodeAt(start), exprList, isAsync);
	};
	
	pp.parseParenItem = function (node, start) {
	  return node;
	};
	
	// New's precedence is slightly tricky. It must allow its argument
	// to be a `[]` or dot subscript expression, but not a call — at
	// least, not without wrapping it in parentheses. Thus, it uses the
	
	var empty = [];
	
	pp.parseNew = function () {
	  var node = this.startNode();
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
	    node.meta = meta;
	    node.property = this.parseIdent(true);
	    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
	    return this.finishNode(node, "MetaProperty");
	  }
	  node.callee = this.parseNoCallExpr();
	  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, this.options.features["es7.trailingFunctionCommas"]);else node.arguments = empty;
	  return this.finishNode(node, "NewExpression");
	};
	
	// Parse template expression.
	
	pp.parseTemplateElement = function () {
	  var elem = this.startNode();
	  elem.value = {
	    raw: this.input.slice(this.start, this.end),
	    cooked: this.value
	  };
	  this.next();
	  elem.tail = this.type === _tokentype.types.backQuote;
	  return this.finishNode(elem, "TemplateElement");
	};
	
	pp.parseTemplate = function () {
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement();
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this.expect(_tokentype.types.dollarBraceL);
	    node.expressions.push(this.parseExpression());
	    this.expect(_tokentype.types.braceR);
	    node.quasis.push(curElt = this.parseTemplateElement());
	  }
	  this.next();
	  return this.finishNode(node, "TemplateLiteral");
	};
	
	// Parse an object literal or binding pattern.
	
	pp.parseObj = function (isPattern, refShorthandDefaultPos) {
	  var node = this.startNode(),
	      first = true,
	      propHash = {};
	  node.properties = [];
	  var decorators = [];
	  this.next();
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;
	    while (this.type === _tokentype.types.at) {
	      decorators.push(this.parseDecorator());
	    }
	    var prop = this.startNode(),
	        isGenerator = false,
	        isAsync = false,
	        _start2 = undefined;
	    if (decorators.length) {
	      prop.decorators = decorators;
	      decorators = [];
	    }
	    if (this.options.features["es7.objectRestSpread"] && this.type === _tokentype.types.ellipsis) {
	      prop = this.parseSpread();
	      prop.type = "SpreadProperty";
	      node.properties.push(prop);
	      continue;
	    }
	    if (this.options.ecmaVersion >= 6) {
	      prop.method = false;
	      prop.shorthand = false;
	      if (isPattern || refShorthandDefaultPos) _start2 = this.markPosition();
	      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
	    }
	    if (this.options.features["es7.asyncFunctions"] && this.isContextual("async")) {
	      if (isGenerator || isPattern) this.unexpected();
	      var asyncId = this.parseIdent();
	      if (this.type === _tokentype.types.colon || this.type === _tokentype.types.parenL) {
	        prop.key = asyncId;
	      } else {
	        isAsync = true;
	        this.parsePropertyName(prop);
	      }
	    } else {
	      this.parsePropertyName(prop);
	    }
	    this.parseObjPropValue(prop, _start2, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
	    this.checkPropClash(prop, propHash);
	    node.properties.push(this.finishNode(prop, "Property"));
	  }
	  if (decorators.length) {
	    this.raise(this.start, "You have trailing decorators with no property");
	  }
	  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	};
	
	pp.parseObjPropValue = function (prop, start, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
	  if (this.eat(_tokentype.types.colon)) {
	    prop.value = isPattern ? this.parseMaybeDefault() : this.parseMaybeAssign(false, refShorthandDefaultPos);
	    prop.kind = "init";
	  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
	    if (isPattern) this.unexpected();
	    prop.kind = "init";
	    prop.method = true;
	    prop.value = this.parseMethod(isGenerator, isAsync);
	  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
	    if (isGenerator || isAsync || isPattern) this.unexpected();
	    prop.kind = prop.key.name;
	    this.parsePropertyName(prop);
	    prop.value = this.parseMethod(false);
	  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	    prop.kind = "init";
	    if (isPattern) {
	      if (this.isKeyword(prop.key.name) || this.strict && (_identifier.reservedWords.strictBind(prop.key.name) || _identifier.reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
	      prop.value = this.parseMaybeDefault(start, prop.key);
	    } else if (this.type === _tokentype.types.eq && refShorthandDefaultPos) {
	      if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;
	      prop.value = this.parseMaybeDefault(start, prop.key);
	    } else {
	      prop.value = prop.key;
	    }
	    prop.shorthand = true;
	  } else this.unexpected();
	};
	
	pp.parsePropertyName = function (prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(_tokentype.types.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(_tokentype.types.bracketR);
	      return;
	    } else {
	      prop.computed = false;
	    }
	  }
	  prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
	};
	
	// Initialize empty function node.
	
	pp.initFunction = function (node, isAsync) {
	  node.id = null;
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	  if (this.options.features["es7.asyncFunctions"]) {
	    node.async = !!isAsync;
	  }
	};
	
	// Parse object or class method.
	
	pp.parseMethod = function (isGenerator, isAsync) {
	  var node = this.startNode();
	  this.initFunction(node, isAsync);
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, this.options.features["es7.trailingFunctionCommas"]);
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = isGenerator;
	  }
	  this.parseFunctionBody(node);
	  return this.finishNode(node, "FunctionExpression");
	};
	
	// Parse arrow function expression with given parameters.
	
	pp.parseArrowExpression = function (node, params, isAsync) {
	  this.initFunction(node, isAsync);
	  node.params = this.toAssignableList(params, true);
	  this.parseFunctionBody(node, true);
	  return this.finishNode(node, "ArrowFunctionExpression");
	};
	
	// Parse function body and check parameters.
	
	pp.parseFunctionBody = function (node, allowExpression) {
	  var isExpression = allowExpression && this.type !== _tokentype.types.braceL;
	
	  var oldInAsync = this.inAsync;
	  this.inAsync = node.async;
	  if (isExpression) {
	    node.body = this.parseMaybeAssign();
	    node.expression = true;
	  } else {
	    // Start a new scope with regard to labels and the `inFunction`
	    // flag (restore them to their old value afterwards).
	    var oldInFunc = this.inFunction,
	        oldInGen = this.inGenerator,
	        oldLabels = this.labels;
	    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
	    node.body = this.parseBlock(true);
	    node.expression = false;
	    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
	  }
	  this.inAsync = oldInAsync;
	
	  // If this is a strict mode function, verify that argument names
	  // are not repeated, and it does not try to bind the words `eval`
	  // or `arguments`.
	  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
	    var nameHash = {},
	        oldStrict = this.strict;
	    this.strict = true;
	    if (node.id) this.checkLVal(node.id, true);
	    for (var i = 0; i < node.params.length; i++) {
	      this.checkLVal(node.params[i], true, nameHash);
	    }this.strict = oldStrict;
	  }
	};
	
	// Parses a comma-separated list of expressions, and returns them as
	// an array. `close` is the token type that ends the list, and
	// `allowEmpty` can be turned on to allow subsequent commas with
	// nothing in between them to be parsed as `null` (which is needed
	// for array literals).
	
	pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (allowTrailingComma && this.afterTrailingComma(close)) break;
	    } else first = false;
	
	    if (allowEmpty && this.type === _tokentype.types.comma) {
	      elts.push(null);
	    } else {
	      if (this.type === _tokentype.types.ellipsis) elts.push(this.parseSpread(refShorthandDefaultPos));else elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos));
	    }
	  }
	  return elts;
	};
	
	// Parse the next token as an identifier. If `liberal` is true (used
	// when parsing properties), it will also convert keywords into
	// identifiers.
	
	pp.parseIdent = function (liberal) {
	  var node = this.startNode();
	  if (liberal && this.options.allowReserved == "never") liberal = false;
	  if (this.type === _tokentype.types.name) {
	    if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.value) || this.strict && _identifier.reservedWords.strict(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1))) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
	    node.name = this.value;
	  } else if (liberal && this.type.keyword) {
	    node.name = this.type.keyword;
	  } else {
	    this.unexpected();
	  }
	  this.next();
	  return this.finishNode(node, "Identifier");
	};
	
	// Parses await expression inside async function.
	
	pp.parseAwait = function (node) {
	  if (this.eat(_tokentype.types.semi) || this.canInsertSemicolon()) {
	    this.unexpected();
	  }
	  node.all = this.eat(_tokentype.types.star);
	  node.argument = this.parseMaybeUnary();
	  return this.finishNode(node, "AwaitExpression");
	};
	
	// Parses yield expression inside generator.
	
	pp.parseYield = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
	    node.delegate = false;
	    node.argument = null;
	  } else {
	    node.delegate = this.eat(_tokentype.types.star);
	    node.argument = this.parseMaybeAssign();
	  }
	  return this.finishNode(node, "YieldExpression");
	};
	
	// Parses array and generator comprehensions.
	
	pp.parseComprehension = function (node, isGenerator) {
	  node.blocks = [];
	  while (this.type === _tokentype.types._for) {
	    var block = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    block.left = this.parseBindingAtom();
	    this.checkLVal(block.left, true);
	    this.expectContextual("of");
	    block.right = this.parseExpression();
	    this.expect(_tokentype.types.parenR);
	    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
	  }
	  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;
	  node.body = this.parseExpression();
	  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);
	  node.generator = isGenerator;
	  return this.finishNode(node, "ComprehensionExpression");
	};

/***/ },
/* 231 */
/*!*************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/lookahead.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var pp = _state.Parser.prototype;
	
	var STATE_KEYS = ["lastTokStartLoc", "lastTokEndLoc", "lastTokStart", "lastTokEnd", "lineStart", "startLoc", "endLoc", "start", "pos", "end", "type", "value", "exprAllowed", "potentialArrowAt", "currLine", "input"];
	
	pp.getState = function () {
	  var state = {};
	  for (var i = 0; i < STATE_KEYS.length; i++) {
	    var key = STATE_KEYS[i];
	    state[key] = this[key];
	  }
	  state.context = this.context.slice();
	  return state;
	};
	
	pp.lookahead = function () {
	  var old = this.getState();
	  this.isLookahead = true;
	  this.next();
	  this.isLookahead = false;
	  var curr = this.getState();
	  for (var key in old) this[key] = old[key];
	  return curr;
	};

/***/ },
/* 232 */
/*!********************************************!*\
  !*** ./~/babel-core/lib/acorn/src/node.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _location = __webpack_require__(/*! ./location */ 220);
	
	// Start an AST node, attaching a start offset.
	
	var pp = _state.Parser.prototype;
	
	var Node = function Node() {
	  _classCallCheck(this, Node);
	};
	
	exports.Node = Node;
	
	pp.startNode = function () {
	  var node = new Node();
	  node.start = this.start;
	  if (this.options.locations) node.loc = new _location.SourceLocation(this, this.startLoc);
	  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
	  if (this.options.ranges) node.range = [this.start, 0];
	  return node;
	};
	
	pp.startNodeAt = function (pos) {
	  var node = new Node(),
	      start = pos;
	  if (this.options.locations) {
	    node.loc = new _location.SourceLocation(this, start[1]);
	    start = pos[0];
	  }
	  node.start = start;
	  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
	  if (this.options.ranges) node.range = [start, 0];
	  return node;
	};
	
	// Finish an AST node, adding `type` and `end` properties.
	
	pp.finishNode = function (node, type) {
	  node.type = type;
	  node.end = this.lastTokEnd;
	  if (this.options.locations) node.loc.end = this.lastTokEndLoc;
	  if (this.options.ranges) node.range[1] = this.lastTokEnd;
	  return node;
	};
	
	// Finish node at given position
	
	pp.finishNodeAt = function (node, type, pos) {
	  if (this.options.locations) {
	    node.loc.end = pos[1];pos = pos[0];
	  }
	  node.type = type;
	  node.end = pos;
	  if (this.options.ranges) node.range[1] = pos;
	  return node;
	};

/***/ },
/* 233 */
/*!****************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/tokencontext.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// The algorithm used to determine whether a regexp can appear at a
	// given point in the program is loosely based on sweet.js' approach.
	// See https://github.com/mozilla/sweet.js/wiki/design
	
	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 224);
	
	var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	  _classCallCheck(this, TokContext);
	
	  this.token = token;
	  this.isExpr = isExpr;
	  this.preserveSpace = preserveSpace;
	  this.override = override;
	};
	
	exports.TokContext = TokContext;
	var types = {
	  b_stat: new TokContext("{", false),
	  b_expr: new TokContext("{", true),
	  b_tmpl: new TokContext("${", true),
	  p_stat: new TokContext("(", false),
	  p_expr: new TokContext("(", true),
	  q_tmpl: new TokContext("`", true, true, function (p) {
	    return p.readTmplToken();
	  }),
	  f_expr: new TokContext("function", true)
	};
	
	exports.types = types;
	var pp = _state.Parser.prototype;
	
	pp.initialContext = function () {
	  return [types.b_stat];
	};
	
	pp.braceIsBlock = function (prevType) {
	  var parent = undefined;
	  if (prevType === _tokentype.types.colon && (parent = this.curContext()).token == "{") return !parent.isExpr;
	  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof) return true;
	  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
	  return !this.exprAllowed;
	};
	
	pp.updateContext = function (prevType) {
	  var update = undefined,
	      type = this.type;
	  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
	};
	
	// Token-specific context update code
	
	_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
	  if (this.context.length == 1) {
	    this.exprAllowed = true;
	    return;
	  }
	  var out = this.context.pop();
	  if (out === types.b_stat && this.curContext() === types.f_expr) {
	    this.context.pop();
	    this.exprAllowed = false;
	  } else if (out === types.b_tmpl) {
	    this.exprAllowed = true;
	  } else {
	    this.exprAllowed = !out.isExpr;
	  }
	};
	
	_tokentype.types.braceL.updateContext = function (prevType) {
	  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	  this.exprAllowed = true;
	};
	
	_tokentype.types.dollarBraceL.updateContext = function () {
	  this.context.push(types.b_tmpl);
	  this.exprAllowed = true;
	};
	
	_tokentype.types.parenL.updateContext = function (prevType) {
	  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
	  this.context.push(statementParens ? types.p_stat : types.p_expr);
	  this.exprAllowed = true;
	};
	
	_tokentype.types.incDec.updateContext = function () {};
	
	_tokentype.types._function.updateContext = function () {
	  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
	  this.exprAllowed = false;
	};
	
	_tokentype.types.backQuote.updateContext = function () {
	  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
	  this.exprAllowed = false;
	};
	
	// tokExprAllowed stays unchanged

/***/ },
/* 234 */
/*!************************************************!*\
  !*** ./~/babel-core/lib/acorn/src/tokenize.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _identifier = __webpack_require__(/*! ./identifier */ 222);
	
	var _tokentype = __webpack_require__(/*! ./tokentype */ 223);
	
	var _state = __webpack_require__(/*! ./state */ 221);
	
	var _location = __webpack_require__(/*! ./location */ 220);
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 224);
	
	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.
	
	var Token = function Token(p) {
	  _classCallCheck(this, Token);
	
	  this.type = p.type;
	  this.value = p.value;
	  this.start = p.start;
	  this.end = p.end;
	  if (p.options.locations) this.loc = new _location.SourceLocation(p, p.startLoc, p.endLoc);
	  if (p.options.ranges) this.range = [p.start, p.end];
	};
	
	exports.Token = Token;
	
	// ## Tokenizer
	
	var pp = _state.Parser.prototype;
	
	// Move to the next token
	
	pp.next = function () {
	  if (this.options.onToken && !this.isLookahead) this.options.onToken(new Token(this));
	
	  this.lastTokEnd = this.end;
	  this.lastTokStart = this.start;
	  this.lastTokEndLoc = this.endLoc;
	  this.lastTokStartLoc = this.startLoc;
	  this.nextToken();
	};
	
	pp.getToken = function () {
	  this.next();
	  return new Token(this);
	};
	
	// If we're in an ES6 environment, make parsers iterable
	if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
	  var self = this;
	  return { next: function next() {
	      var token = self.getToken();
	      return {
	        done: token.type === _tokentype.types.eof,
	        value: token
	      };
	    } };
	};
	
	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).
	
	pp.setStrict = function (strict) {
	  this.strict = strict;
	  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
	  this.pos = this.start;
	  if (this.options.locations) {
	    while (this.pos < this.lineStart) {
	      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
	      --this.curLine;
	    }
	  }
	  this.nextToken();
	};
	
	pp.curContext = function () {
	  return this.context[this.context.length - 1];
	};
	
	// Read a single token, updating the parser object's token-related
	// properties.
	
	pp.nextToken = function () {
	  var curContext = this.curContext();
	  if (!curContext || !curContext.preserveSpace) this.skipSpace();
	
	  this.start = this.pos;
	  if (this.options.locations) this.startLoc = this.curPosition();
	  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);
	
	  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
	};
	
	pp.readToken = function (code) {
	  // Identifier or keyword. '\uXXXX' sequences are allowed in
	  // identifiers, so '\' also dispatches to that.
	  if ((0, _identifier.isIdentifierStart)(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();
	
	  return this.getTokenFromCode(code);
	};
	
	pp.fullCharCodeAtPos = function () {
	  var code = this.input.charCodeAt(this.pos);
	  if (code <= 55295 || code >= 57344) return code;
	  var next = this.input.charCodeAt(this.pos + 1);
	  return (code << 10) + next - 56613888;
	};
	
	pp.skipBlockComment = function () {
	  var startLoc = this.options.onComment && this.options.locations && this.curPosition();
	  var start = this.pos,
	      end = this.input.indexOf("*/", this.pos += 2);
	  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	  this.pos = end + 2;
	  if (this.options.locations) {
	    _whitespace.lineBreakG.lastIndex = start;
	    var match = undefined;
	    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
	      ++this.curLine;
	      this.lineStart = match.index + match[0].length;
	    }
	  }
	  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.options.locations && this.curPosition());
	};
	
	pp.skipLineComment = function (startSkip) {
	  var start = this.pos;
	  var startLoc = this.options.onComment && this.options.locations && this.curPosition();
	  var ch = this.input.charCodeAt(this.pos += startSkip);
	  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	    ++this.pos;
	    ch = this.input.charCodeAt(this.pos);
	  }
	  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.options.locations && this.curPosition());
	};
	
	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.
	
	pp.skipSpace = function () {
	  while (this.pos < this.input.length) {
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 32) {
	      // ' '
	      ++this.pos;
	    } else if (ch === 13) {
	      ++this.pos;
	      var _next = this.input.charCodeAt(this.pos);
	      if (_next === 10) {
	        ++this.pos;
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	    } else if (ch === 10 || ch === 8232 || ch === 8233) {
	      ++this.pos;
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	    } else if (ch > 8 && ch < 14) {
	      ++this.pos;
	    } else if (ch === 47) {
	      // '/'
	      var _next2 = this.input.charCodeAt(this.pos + 1);
	      if (_next2 === 42) {
	        // '*'
	        this.skipBlockComment();
	      } else if (_next2 === 47) {
	        // '/'
	        this.skipLineComment(2);
	      } else break;
	    } else if (ch === 160) {
	      // '\xa0'
	      ++this.pos;
	    } else if (ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	      ++this.pos;
	    } else {
	      break;
	    }
	  }
	};
	
	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.
	
	pp.finishToken = function (type, val) {
	  this.end = this.pos;
	  if (this.options.locations) this.endLoc = this.curPosition();
	  var prevType = this.type;
	  this.type = type;
	  this.value = val;
	
	  this.updateContext(prevType);
	};
	
	// ### Token reading
	
	// This is the function that is called to fetch the next token. It
	// is somewhat obscure, because it works in character codes rather
	// than characters, and because operator parsing has been inlined
	// into it.
	//
	// All in the name of speed.
	//
	pp.readToken_dot = function () {
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next >= 48 && next <= 57) return this.readNumber(true);
	  var next2 = this.input.charCodeAt(this.pos + 2);
	  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	    // 46 = dot '.'
	    this.pos += 3;
	    return this.finishToken(_tokentype.types.ellipsis);
	  } else {
	    ++this.pos;
	    return this.finishToken(_tokentype.types.dot);
	  }
	};
	
	pp.readToken_slash = function () {
	  // '/'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (this.exprAllowed) {
	    ++this.pos;return this.readRegexp();
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.slash, 1);
	};
	
	pp.readToken_mult_modulo = function (code) {
	  // '%*'
	  var type = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;
	  var width = 1;
	  var next = this.input.charCodeAt(this.pos + 1);
	
	  if (next === 42) {
	    // '*'
	    width++;
	    next = this.input.charCodeAt(this.pos + 2);
	    type = _tokentype.types.exponent;
	  }
	
	  if (next === 61) {
	    width++;
	    type = _tokentype.types.assign;
	  }
	
	  return this.finishOp(type, width);
	};
	
	pp.readToken_pipe_amp = function (code) {
	  // '|&'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
	};
	
	pp.readToken_caret = function () {
	  // '^'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
	};
	
	pp.readToken_plus_min = function (code) {
	  // '+-'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	      // A `-->` line comment
	      this.skipLineComment(3);
	      this.skipSpace();
	      return this.nextToken();
	    }
	    return this.finishOp(_tokentype.types.incDec, 2);
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.plusMin, 1);
	};
	
	pp.readToken_lt_gt = function (code) {
	  // '<>'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  if (next === code) {
	    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
	    return this.finishOp(_tokentype.types.bitShift, size);
	  }
	  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
	    if (this.inModule) this.unexpected();
	    // `<!--`, an XML-style comment that should be interpreted as a line comment
	    this.skipLineComment(4);
	    this.skipSpace();
	    return this.nextToken();
	  }
	  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
	  return this.finishOp(_tokentype.types.relational, size);
	};
	
	pp.readToken_eq_excl = function (code) {
	  // '=!'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
	    // '=>'
	    this.pos += 2;
	    return this.finishToken(_tokentype.types.arrow);
	  }
	  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
	};
	
	pp.getTokenFromCode = function (code) {
	  switch (code) {
	    // The interpretation of a dot depends on whether it is followed
	    // by a digit or another two dots.
	    case 46:
	      // '.'
	      return this.readToken_dot();
	
	    // Punctuation tokens.
	    case 40:
	      ++this.pos;return this.finishToken(_tokentype.types.parenL);
	    case 41:
	      ++this.pos;return this.finishToken(_tokentype.types.parenR);
	    case 59:
	      ++this.pos;return this.finishToken(_tokentype.types.semi);
	    case 44:
	      ++this.pos;return this.finishToken(_tokentype.types.comma);
	    case 91:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
	    case 93:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
	    case 123:
	      ++this.pos;return this.finishToken(_tokentype.types.braceL);
	    case 125:
	      ++this.pos;return this.finishToken(_tokentype.types.braceR);
	
	    case 58:
	      if (this.options.features["es7.functionBind"] && this.input.charCodeAt(this.pos + 1) === 58) return this.finishOp(_tokentype.types.doubleColon, 2);
	      ++this.pos;
	      return this.finishToken(_tokentype.types.colon);
	
	    case 63:
	      ++this.pos;return this.finishToken(_tokentype.types.question);
	    case 64:
	      ++this.pos;return this.finishToken(_tokentype.types.at);
	
	    case 96:
	      // '`'
	      if (this.options.ecmaVersion < 6) break;
	      ++this.pos;
	      return this.finishToken(_tokentype.types.backQuote);
	
	    case 48:
	      // '0'
	      var next = this.input.charCodeAt(this.pos + 1);
	      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
	      }
	    // Anything else beginning with a digit is an integer, octal
	    // number, or float.
	    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
	      // 1-9
	      return this.readNumber(false);
	
	    // Quotes produce strings.
	    case 34:case 39:
	      // '"', "'"
	      return this.readString(code);
	
	    // Operators are parsed inline in tiny state machines. '=' (61) is
	    // often referred to. `finishOp` simply skips the amount of
	    // characters it is given as second argument, and returns a token
	    // of the type given by its first argument.
	
	    case 47:
	      // '/'
	      return this.readToken_slash();
	
	    case 37:case 42:
	      // '%*'
	      return this.readToken_mult_modulo(code);
	
	    case 124:case 38:
	      // '|&'
	      return this.readToken_pipe_amp(code);
	
	    case 94:
	      // '^'
	      return this.readToken_caret();
	
	    case 43:case 45:
	      // '+-'
	      return this.readToken_plus_min(code);
	
	    case 60:case 62:
	      // '<>'
	      return this.readToken_lt_gt(code);
	
	    case 61:case 33:
	      // '=!'
	      return this.readToken_eq_excl(code);
	
	    case 126:
	      // '~'
	      return this.finishOp(_tokentype.types.prefix, 1);
	  }
	
	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};
	
	pp.finishOp = function (type, size) {
	  var str = this.input.slice(this.pos, this.pos + size);
	  this.pos += size;
	  return this.finishToken(type, str);
	};
	
	var regexpUnicodeSupport = false;
	try {
	  new RegExp("￿", "u");regexpUnicodeSupport = true;
	} catch (e) {}
	
	// Parse a regular expression. Some context-awareness is necessary,
	// since a '/' inside a '[]' set does not end the expression.
	
	pp.readRegexp = function () {
	  var escaped = undefined,
	      inClass = undefined,
	      start = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
	    var ch = this.input.charAt(this.pos);
	    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
	    if (!escaped) {
	      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
	      escaped = ch === "\\";
	    } else escaped = false;
	    ++this.pos;
	  }
	  var content = this.input.slice(start, this.pos);
	  ++this.pos;
	  // Need to use `readWord1` because '\uXXXX' sequences are allowed
	  // here (don't ask).
	  var mods = this.readWord1();
	  var tmp = content;
	  if (mods) {
	    var validFlags = /^[gmsiy]*$/;
	    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
	    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
	    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
	      // Replace each astral symbol and every Unicode escape sequence that
	      // possibly represents an astral symbol or a paired surrogate with a
	      // single ASCII symbol to avoid throwing on regular expressions that
	      // are only valid in combination with the `/u` flag.
	      // Note: replacing with the ASCII symbol `x` might cause false
	      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	      // be replaced by `[x-b]` which throws an error.
	      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|\\u\{([0-9a-fA-F]+)\}|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
	    }
	  }
	  // Detect invalid regular expressions.
	  try {
	    new RegExp(tmp);
	  } catch (e) {
	    if (e instanceof SyntaxError) this.raise(start, "Error parsing regular expression: " + e.message);
	    this.raise(e);
	  }
	  // Get a regular expression object for this pattern-flag pair, or `null` in
	  // case the current environment doesn't support the flags it uses.
	  var value = undefined;
	  try {
	    value = new RegExp(content, mods);
	  } catch (err) {
	    value = null;
	  }
	  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
	};
	
	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.
	
	pp.readInt = function (radix, len) {
	  var start = this.pos,
	      total = 0;
	  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    var code = this.input.charCodeAt(this.pos),
	        val = undefined;
	    if (code >= 97) val = code - 97 + 10; // a
	    else if (code >= 65) val = code - 65 + 10; // A
	    else if (code >= 48 && code <= 57) val = code - 48; // 0-9
	    else val = Infinity;
	    if (val >= radix) break;
	    ++this.pos;
	    total = total * radix + val;
	  }
	  if (this.pos === start || len != null && this.pos - start !== len) return null;
	
	  return total;
	};
	
	pp.readRadixNumber = function (radix) {
	  this.pos += 2; // 0x
	  var val = this.readInt(radix);
	  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	  if ((0, _identifier.isIdentifierStart)(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	  return this.finishToken(_tokentype.types.num, val);
	};
	
	// Read an integer, octal integer, or floating-point number.
	
	pp.readNumber = function (startsWithDot) {
	  var start = this.pos,
	      isFloat = false,
	      octal = this.input.charCodeAt(this.pos) === 48;
	  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
	  if (this.input.charCodeAt(this.pos) === 46) {
	    ++this.pos;
	    this.readInt(10);
	    isFloat = true;
	  }
	  var next = this.input.charCodeAt(this.pos);
	  if (next === 69 || next === 101) {
	    // 'eE'
	    next = this.input.charCodeAt(++this.pos);
	    if (next === 43 || next === 45) ++this.pos; // '+-'
	    if (this.readInt(10) === null) this.raise(start, "Invalid number");
	    isFloat = true;
	  }
	  if ((0, _identifier.isIdentifierStart)(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	
	  var str = this.input.slice(start, this.pos),
	      val = undefined;
	  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
	  return this.finishToken(_tokentype.types.num, val);
	};
	
	// Read a string value, interpreting backslash-escapes.
	
	pp.readCodePoint = function () {
	  var ch = this.input.charCodeAt(this.pos),
	      code = undefined;
	
	  if (ch === 123) {
	    if (this.options.ecmaVersion < 6) this.unexpected();
	    ++this.pos;
	    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
	    ++this.pos;
	    if (code > 1114111) this.unexpected();
	  } else {
	    code = this.readHexChar(4);
	  }
	  return code;
	};
	
	function codePointToString(code) {
	  // UTF-16 Decoding
	  if (code <= 65535) return String.fromCharCode(code);
	  return String.fromCharCode((code - 65536 >> 10) + 55296, (code - 65536 & 1023) + 56320);
	}
	
	pp.readString = function (quote) {
	  var out = "",
	      chunkStart = ++this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === quote) break;
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar();
	      chunkStart = this.pos;
	    } else {
	      if ((0, _whitespace.isNewLine)(ch)) this.raise(this.start, "Unterminated string constant");
	      ++this.pos;
	    }
	  }
	  out += this.input.slice(chunkStart, this.pos++);
	  return this.finishToken(_tokentype.types.string, out);
	};
	
	// Reads template string tokens.
	
	pp.readTmplToken = function () {
	  var out = "",
	      chunkStart = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
	      // '`', '${'
	      if (this.pos === this.start && this.type === _tokentype.types.template) {
	        if (ch === 36) {
	          this.pos += 2;
	          return this.finishToken(_tokentype.types.dollarBraceL);
	        } else {
	          ++this.pos;
	          return this.finishToken(_tokentype.types.backQuote);
	        }
	      }
	      out += this.input.slice(chunkStart, this.pos);
	      return this.finishToken(_tokentype.types.template, out);
	    }
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar();
	      chunkStart = this.pos;
	    } else if ((0, _whitespace.isNewLine)(ch)) {
	      out += this.input.slice(chunkStart, this.pos);
	      ++this.pos;
	      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
	        ++this.pos;
	        out += "\n";
	      } else {
	        out += String.fromCharCode(ch);
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	      chunkStart = this.pos;
	    } else {
	      ++this.pos;
	    }
	  }
	};
	
	// Used to read escaped characters
	
	pp.readEscapedChar = function () {
	  var ch = this.input.charCodeAt(++this.pos);
	  var octal = /^[0-7]+/.exec(this.input.slice(this.pos, this.pos + 3));
	  if (octal) octal = octal[0];
	  while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
	  if (octal === "0") octal = null;
	  ++this.pos;
	  if (octal) {
	    if (this.strict) this.raise(this.pos - 2, "Octal literal in strict mode");
	    this.pos += octal.length - 1;
	    return String.fromCharCode(parseInt(octal, 8));
	  } else {
	    switch (ch) {
	      case 110:
	        return "\n"; // 'n' -> '\n'
	      case 114:
	        return "\r"; // 'r' -> '\r'
	      case 120:
	        return String.fromCharCode(this.readHexChar(2)); // 'x'
	      case 117:
	        return codePointToString(this.readCodePoint()); // 'u'
	      case 116:
	        return "\t"; // 't' -> '\t'
	      case 98:
	        return "\b"; // 'b' -> '\b'
	      case 118:
	        return "\u000b"; // 'v' -> '\u000b'
	      case 102:
	        return "\f"; // 'f' -> '\f'
	      case 48:
	        return "\u0000"; // 0 -> '\0'
	      case 13:
	        if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
	      case 10:
	        // ' \n'
	        if (this.options.locations) {
	          this.lineStart = this.pos;++this.curLine;
	        }
	        return "";
	      default:
	        return String.fromCharCode(ch);
	    }
	  }
	};
	
	// Used to read character escape sequences ('\x', '\u', '\U').
	
	pp.readHexChar = function (len) {
	  var n = this.readInt(16, len);
	  if (n === null) this.raise(this.start, "Bad character escape sequence");
	  return n;
	};
	
	// Used to signal to callers of `readWord1` whether the word
	// contained any escape sequences. This is needed because words with
	// escape sequences must not be interpreted as keywords.
	
	var containsEsc;
	
	// Read an identifier, and return it as a string. Sets `containsEsc`
	// to whether the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.
	
	pp.readWord1 = function () {
	  containsEsc = false;
	  var word = "",
	      first = true,
	      chunkStart = this.pos;
	  var astral = this.options.ecmaVersion >= 6;
	  while (this.pos < this.input.length) {
	    var ch = this.fullCharCodeAtPos();
	    if ((0, _identifier.isIdentifierChar)(ch, astral)) {
	      this.pos += ch <= 65535 ? 1 : 2;
	    } else if (ch === 92) {
	      // "\"
	      containsEsc = true;
	      word += this.input.slice(chunkStart, this.pos);
	      var escStart = this.pos;
	      if (this.input.charCodeAt(++this.pos) != 117) // "u"
	        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
	      ++this.pos;
	      var esc = this.readCodePoint();
	      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
	      word += codePointToString(esc);
	      chunkStart = this.pos;
	    } else {
	      break;
	    }
	    first = false;
	  }
	  return word + this.input.slice(chunkStart, this.pos);
	};
	
	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.
	
	pp.readWord = function () {
	  var word = this.readWord1();
	  var type = _tokentype.types.name;
	  if ((this.options.ecmaVersion >= 6 || !containsEsc) && this.isKeyword(word)) type = _tokentype.keywords[word];
	  return this.finishToken(type, word);
	};

/***/ },
/* 235 */
/*!********************************************!*\
  !*** ./~/babel-core/~/acorn-jsx/inject.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = function(acorn) {
	  var tt = acorn.tokTypes;
	  var tc = acorn.tokContexts;
	
	  tc.j_oTag = new acorn.TokContext('<tag', false);
	  tc.j_cTag = new acorn.TokContext('</tag', false);
	  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);
	
	  tt.jsxName = new acorn.TokenType('jsxName');
	  tt.jsxText = new acorn.TokenType('jsxText', {beforeExpr: true});
	  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');
	  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');
	
	  tt.jsxTagStart.updateContext = function() {
	    this.context.push(tc.j_expr); // treat as beginning of JSX expression
	    this.context.push(tc.j_oTag); // start opening tag context
	    this.exprAllowed = false;
	  };
	  tt.jsxTagEnd.updateContext = function(prevType) {
	    var out = this.context.pop();
	    if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
	      this.context.pop();
	      this.exprAllowed = this.curContext() === tc.j_expr;
	    } else {
	      this.exprAllowed = true;
	    }
	  };
	
	  var pp = acorn.Parser.prototype;
	
	  // Reads inline JSX contents token.
	
	  pp.jsx_readToken = function() {
	    var out = '', chunkStart = this.pos;
	    for (;;) {
	      if (this.pos >= this.input.length)
	        this.raise(this.start, 'Unterminated JSX contents');
	      var ch = this.input.charCodeAt(this.pos);
	
	      switch (ch) {
	      case 60: // '<'
	      case 123: // '{'
	        if (this.pos === this.start) {
	          if (ch === 60 && this.exprAllowed) {
	            ++this.pos;
	            return this.finishToken(tt.jsxTagStart);
	          }
	          return this.getTokenFromCode(ch);
	        }
	        out += this.input.slice(chunkStart, this.pos);
	        return this.finishToken(tt.jsxText, out);
	
	      case 38: // '&'
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readEntity();
	        chunkStart = this.pos;
	        break;
	
	      default:
	        if (acorn.isNewLine(ch)) {
	          out += this.input.slice(chunkStart, this.pos);
	          out += this.jsx_readNewLine(true);
	          chunkStart = this.pos;
	        } else {
	          ++this.pos;
	        }
	      }
	    }
	  };
	
	  pp.jsx_readNewLine = function(normalizeCRLF) {
	    var ch = this.input.charCodeAt(this.pos);
	    var out;
	    ++this.pos;
	    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
	      ++this.pos;
	      out = normalizeCRLF ? '\n' : '\r\n';
	    } else {
	      out = String.fromCharCode(ch);
	    }
	    if (this.options.locations) {
	      ++this.curLine;
	      this.lineStart = this.pos;
	    }
	
	    return out;
	  };
	
	  pp.jsx_readString = function(quote) {
	    var out = '', chunkStart = ++this.pos;
	    for (;;) {
	      if (this.pos >= this.input.length)
	        this.raise(this.start, 'Unterminated string constant');
	      var ch = this.input.charCodeAt(this.pos);
	      if (ch === quote) break;
	      if (ch === 38) { // '&'
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readEntity();
	        chunkStart = this.pos;
	      } else if (acorn.isNewLine(ch)) {
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readNewLine(false);
	        chunkStart = this.pos;
	      } else {
	        ++this.pos;
	      }
	    }
	    out += this.input.slice(chunkStart, this.pos++);
	    return this.finishToken(tt.string, out);
	  };
	
	  var XHTMLEntities = {
	    quot: '\u0022',
	    amp: '&',
	    apos: '\u0027',
	    lt: '<',
	    gt: '>',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    'int': '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    lang: '\u2329',
	    rang: '\u232A',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666'
	  };
	
	  var hexNumber = /^[\da-fA-F]+$/;
	  var decimalNumber = /^\d+$/;
	
	  pp.jsx_readEntity = function() {
	    var str = '', count = 0, entity;
	    var ch = this.input[this.pos];
	    if (ch !== '&')
	      this.raise(this.pos, 'Entity must start with an ampersand');
	    var startPos = ++this.pos;
	    while (this.pos < this.input.length && count++ < 10) {
	      ch = this.input[this.pos++];
	      if (ch === ';') {
	        if (str[0] === '#') {
	          if (str[1] === 'x') {
	            str = str.substr(2);
	            if (hexNumber.test(str))
	              entity = String.fromCharCode(parseInt(str, 16));
	          } else {
	            str = str.substr(1);
	            if (decimalNumber.test(str))
	              entity = String.fromCharCode(parseInt(str, 10));
	          }
	        } else {
	          entity = XHTMLEntities[str];
	        }
	        break;
	      }
	      str += ch;
	    }
	    if (!entity) {
	      this.pos = startPos;
	      return '&';
	    }
	    return entity;
	  };
	
	
	  // Read a JSX identifier (valid tag or attribute name).
	  //
	  // Optimized version since JSX identifiers can't contain
	  // escape characters and so can be read as single slice.
	  // Also assumes that first character was already checked
	  // by isIdentifierStart in readToken.
	
	  pp.jsx_readWord = function() {
	    var ch, start = this.pos;
	    do {
	      ch = this.input.charCodeAt(++this.pos);
	    } while (acorn.isIdentifierChar(ch) || ch === 45); // '-'
	    return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
	  };
	
	  // Transforms JSX element name to string.
	
	  function getQualifiedJSXName(object) {
	    if (object.type === 'JSXIdentifier')
	      return object.name;
	
	    if (object.type === 'JSXNamespacedName')
	      return object.namespace.name + ':' + object.name.name;
	
	    if (object.type === 'JSXMemberExpression')
	      return getQualifiedJSXName(object.object) + '.' +
	      getQualifiedJSXName(object.property);
	  }
	
	  // Parse next token as JSX identifier
	
	  pp.jsx_parseIdentifier = function() {
	    var node = this.startNode();
	    if (this.type === tt.jsxName)
	      node.name = this.value;
	    else if (this.type.keyword)
	      node.name = this.type.keyword;
	    else
	      this.unexpected();
	    this.next();
	    return this.finishNode(node, 'JSXIdentifier');
	  };
	
	  // Parse namespaced identifier.
	
	  pp.jsx_parseNamespacedName = function() {
	    var start = this.markPosition();
	    var name = this.jsx_parseIdentifier();
	    if (!this.eat(tt.colon)) return name;
	    var node = this.startNodeAt(start);
	    node.namespace = name;
	    node.name = this.jsx_parseIdentifier();
	    return this.finishNode(node, 'JSXNamespacedName');
	  };
	
	  // Parses element name in any form - namespaced, member
	  // or single identifier.
	
	  pp.jsx_parseElementName = function() {
	    var start = this.markPosition();
	    var node = this.jsx_parseNamespacedName();
	    while (this.eat(tt.dot)) {
	      var newNode = this.startNodeAt(start);
	      newNode.object = node;
	      newNode.property = this.jsx_parseIdentifier();
	      node = this.finishNode(newNode, 'JSXMemberExpression');
	    }
	    return node;
	  };
	
	  // Parses any type of JSX attribute value.
	
	  pp.jsx_parseAttributeValue = function() {
	    switch (this.type) {
	    case tt.braceL:
	      var node = this.jsx_parseExpressionContainer();
	      if (node.expression.type === 'JSXEmptyExpression')
	        this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
	      return node;
	
	    case tt.jsxTagStart:
	    case tt.string:
	      return this.parseExprAtom();
	
	    default:
	      this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
	    }
	  };
	
	  // JSXEmptyExpression is unique type since it doesn't actually parse anything,
	  // and so it should start at the end of last read token (left brace) and finish
	  // at the beginning of the next one (right brace).
	
	  pp.jsx_parseEmptyExpression = function() {
	    var tmp = this.start;
	    this.start = this.lastTokEnd;
	    this.lastTokEnd = tmp;
	
	    tmp = this.startLoc;
	    this.startLoc = this.lastTokEndLoc;
	    this.lastTokEndLoc = tmp;
	
	    return this.finishNode(this.startNode(), 'JSXEmptyExpression');
	  };
	
	  // Parses JSX expression enclosed into curly brackets.
	
	
	  pp.jsx_parseExpressionContainer = function() {
	    var node = this.startNode();
	    this.next();
	    node.expression = this.type === tt.braceR
	      ? this.jsx_parseEmptyExpression()
	      : this.parseExpression();
	    this.expect(tt.braceR);
	    return this.finishNode(node, 'JSXExpressionContainer');
	  };
	
	  // Parses following JSX attribute name-value pair.
	
	  pp.jsx_parseAttribute = function() {
	    var node = this.startNode();
	    if (this.eat(tt.braceL)) {
	      this.expect(tt.ellipsis);
	      node.argument = this.parseMaybeAssign();
	      this.expect(tt.braceR);
	      return this.finishNode(node, 'JSXSpreadAttribute');
	    }
	    node.name = this.jsx_parseNamespacedName();
	    node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
	    return this.finishNode(node, 'JSXAttribute');
	  };
	
	  // Parses JSX opening tag starting after '<'.
	
	  pp.jsx_parseOpeningElementAt = function(start) {
	    var node = this.startNodeAt(start);
	    node.attributes = [];
	    node.name = this.jsx_parseElementName();
	    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)
	      node.attributes.push(this.jsx_parseAttribute());
	    node.selfClosing = this.eat(tt.slash);
	    this.expect(tt.jsxTagEnd);
	    return this.finishNode(node, 'JSXOpeningElement');
	  };
	
	  // Parses JSX closing tag starting after '</'.
	
	  pp.jsx_parseClosingElementAt = function(start) {
	    var node = this.startNodeAt(start);
	    node.name = this.jsx_parseElementName();
	    this.expect(tt.jsxTagEnd);
	    return this.finishNode(node, 'JSXClosingElement');
	  };
	
	  // Parses entire JSX element, including it's opening tag
	  // (starting after '<'), attributes, contents and closing tag.
	
	  pp.jsx_parseElementAt = function(start) {
	    var node = this.startNodeAt(start);
	    var children = [];
	    var openingElement = this.jsx_parseOpeningElementAt(start);
	    var closingElement = null;
	
	    if (!openingElement.selfClosing) {
	      contents: for (;;) {
	        switch (this.type) {
	        case tt.jsxTagStart:
	          start = this.markPosition();
	          this.next();
	          if (this.eat(tt.slash)) {
	            closingElement = this.jsx_parseClosingElementAt(start);
	            break contents;
	          }
	          children.push(this.jsx_parseElementAt(start));
	          break;
	
	        case tt.jsxText:
	          children.push(this.parseExprAtom());
	          break;
	
	        case tt.braceL:
	          children.push(this.jsx_parseExpressionContainer());
	          break;
	
	        default:
	          this.unexpected();
	        }
	      }
	      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name))
	        this.raise(
	          closingElement.start,
	          'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
	    }
	
	    node.openingElement = openingElement;
	    node.closingElement = closingElement;
	    node.children = children;
	    return this.finishNode(node, 'JSXElement');
	  };
	
	  // Parses entire JSX element from current position.
	
	  pp.jsx_parseElement = function() {
	    var start = this.markPosition();
	    this.next();
	    return this.jsx_parseElementAt(start);
	  };
	
	  acorn.plugins.jsx = function(instance) {
	    instance.extend('parseExprAtom', function(inner) {
	      return function(refShortHandDefaultPos) {
	        if (this.type === tt.jsxText)
	          return this.parseLiteral(this.value);
	        else if (this.type === tt.jsxTagStart)
	          return this.jsx_parseElement();
	        else
	          return inner.call(this, refShortHandDefaultPos);
	      };
	    });
	
	    instance.extend('readToken', function(inner) {
	      return function(code) {
	        var context = this.curContext();
	
	        if (context === tc.j_expr) return this.jsx_readToken();
	
	        if (context === tc.j_oTag || context === tc.j_cTag) {
	          if (acorn.isIdentifierStart(code)) return this.jsx_readWord();
	
	          if (code == 62) {
	            ++this.pos;
	            return this.finishToken(tt.jsxTagEnd);
	          }
	
	          if ((code === 34 || code === 39) && context == tc.j_oTag)
	            return this.jsx_readString(code);
	        }
	
	        if (code === 60 && this.exprAllowed) {
	          ++this.pos;
	          return this.finishToken(tt.jsxTagStart);
	        }
	        return inner.call(this, code);
	      };
	    });
	
	    instance.extend('updateContext', function(inner) {
	      return function(prevType) {
	        if (this.type == tt.braceL) {
	          var curContext = this.curContext();
	          if (curContext == tc.j_oTag) this.context.push(tc.b_expr);
	          else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);
	          else inner.call(this, prevType);
	          this.exprAllowed = true;
	        } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
	          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
	          this.context.push(tc.j_cTag); // reconsider as closing tag context
	          this.exprAllowed = false;
	        } else {
	          return inner.call(this, prevType);
	        }
	      };
	    });
	  };
	
	  return acorn;
	};


/***/ },
/* 236 */
/*!*********************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/scope/index.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _visitors = __webpack_require__(/*! ../visitors */ 154);
	
	var _index = __webpack_require__(/*! ../index */ 151);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _lodashObjectDefaults = __webpack_require__(/*! lodash/object/defaults */ 238);
	
	var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
	
	var _messages = __webpack_require__(/*! ../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _binding = __webpack_require__(/*! ./binding */ 240);
	
	var _binding2 = _interopRequireDefault(_binding);
	
	var _globals = __webpack_require__(/*! globals */ 237);
	
	var _globals2 = _interopRequireDefault(_globals);
	
	var _lodashArrayFlatten = __webpack_require__(/*! lodash/array/flatten */ 241);
	
	var _lodashArrayFlatten2 = _interopRequireDefault(_lodashArrayFlatten);
	
	var _lodashObjectExtend = __webpack_require__(/*! lodash/object/extend */ 138);
	
	var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
	
	var _helpersObject = __webpack_require__(/*! ../../helpers/object */ 197);
	
	var _helpersObject2 = _interopRequireDefault(_helpersObject);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var functionVariableVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (t.isFor(node)) {
	      var _arr = t.FOR_INIT_KEYS;
	
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var key = _arr[_i];
	        var declar = this.get(key);
	        if (declar.isVar()) state.scope.registerBinding("var", declar);
	      }
	    }
	
	    // this block is a function so we'll stop since none of the variables
	    // declared within are accessible
	    if (this.isFunction()) return this.skip();
	
	    // function identifier doesn't belong to this scope
	    if (state.blockId && node === state.blockId) return;
	
	    // delegate block scope handling to the `blockVariableVisitor`
	    if (this.isBlockScoped()) return;
	
	    // this will be hit again once we traverse into it after this iteration
	    if (this.isExportDeclaration() && t.isDeclaration(node.declaration)) return;
	
	    // we've ran into a declaration!
	    if (this.isDeclaration()) state.scope.registerDeclaration(this);
	  }
	};
	
	var programReferenceVisitor = (0, _visitors.explode)({
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
	    var bindingInfo = scope.getBinding(node.name);
	    if (bindingInfo) {
	      bindingInfo.reference();
	    } else {
	      state.addGlobal(node);
	    }
	  },
	
	  Scopable: function Scopable(node, parent, scope, state) {
	    for (var name in scope.bindings) {
	      state.references[name] = true;
	    }
	  },
	
	  ExportDeclaration: {
	    exit: function exit(node, parent, scope, state) {
	      var declar = node.declaration;
	      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
	        scope.getBinding(declar.id.name).reference();
	      } else if (t.isVariableDeclaration(declar)) {
	        var _arr2 = declar.declarations;
	
	        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	          var decl = _arr2[_i2];
	          var ids = t.getBindingIdentifiers(decl);
	          for (var name in ids) {
	            scope.getBinding(name).reference();
	          }
	        }
	      }
	    }
	  },
	
	  LabeledStatement: function LabeledStatement(node, parent, scope, state) {
	    state.addGlobal(node);
	  },
	
	  AssignmentExpression: function AssignmentExpression(node, parent, scope, state) {
	    scope.registerConstantViolation(this.get("left"), this.get("right"));
	  },
	
	  UpdateExpression: function UpdateExpression(node, parent, scope, state) {
	    scope.registerConstantViolation(this.get("argument"), null);
	  },
	
	  UnaryExpression: function UnaryExpression(node, parent, scope, state) {
	    if (node.operator === "delete") scope.registerConstantViolation(this.get("left"), null);
	  }
	});
	
	var blockVariableVisitor = (0, _visitors.explode)({
	  Scope: function Scope() {
	    this.skip();
	  },
	
	  enter: function enter(node, parent, scope, state) {
	    if (this.isFunctionDeclaration() || this.isBlockScoped()) {
	      state.registerDeclaration(this);
	    }
	  }
	});
	
	var renameVisitor = (0, _visitors.explode)({
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
	    if (node.name === state.oldName) {
	      node.name = state.newName;
	    }
	  },
	
	  Declaration: function Declaration(node, parent, scope, state) {
	    var ids = this.getBindingIdentifiers();;
	
	    for (var name in ids) {
	      if (name === state.oldName) ids[name].name = state.newName;
	    }
	  },
	
	  Scopable: function Scopable(node, parent, scope, state) {
	    if (this.isScope()) {
	      if (!scope.bindingIdentifierEquals(state.oldName, state.binding)) {
	        this.skip();
	      }
	    }
	  }
	});
	
	var Scope = (function () {
	
	  /**
	   * This searches the current "scope" and collects all references/bindings
	   * within.
	   */
	
	  function Scope(path, parent, file) {
	    _classCallCheck(this, Scope);
	
	    if (parent && parent.block === path.node) {
	      return parent;
	    }
	
	    var cached = path.getData("scope");
	    if (cached && cached.parent === parent) {
	      return cached;
	    } else {}
	
	    this.parent = parent;
	    this.file = parent ? parent.file : file;
	
	    this.parentBlock = path.parent;
	    this.block = path.node;
	    this.path = path;
	
	    this.crawl();
	  }
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.traverse = function traverse(node, opts, state) {
	    (0, _index2["default"])(node, opts, this, state, this.path);
	  };
	
	  /**
	   * Since `Scope` instances are unique to their traversal we need some other
	   * way to compare if scopes are the same. Here we just compare `this.bindings`
	   * as it will be the same across all instances.
	   */
	
	  Scope.prototype.is = function is(scope) {
	    return this.bindings === scope.bindings;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {
	    var name = arguments[0] === undefined ? "temp" : arguments[0];
	
	    var id = this.generateUidIdentifier(name);
	    this.push({ id: id });
	    return id;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.generateUidIdentifier = function generateUidIdentifier(name) {
	    return t.identifier(this.generateUid(name));
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.generateUid = function generateUid(name) {
	    name = t.toIdentifier(name).replace(/^_+/, "");
	
	    var uid;
	    var i = 0;
	    do {
	      uid = this._generateUid(name, i);
	      i++;
	    } while (this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
	
	    var program = this.getProgramParent();
	    program.references[uid] = true;
	    program.uids[uid] = true;
	
	    return uid;
	  };
	
	  Scope.prototype._generateUid = function _generateUid(name, i) {
	    var id = name;
	    if (i > 1) id += i;
	    return "_" + id;
	  };
	
	  /*
	   * Description
	   */
	
	  Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {
	    var node = parent;
	
	    if (t.isAssignmentExpression(parent)) {
	      node = parent.left;
	    } else if (t.isVariableDeclarator(parent)) {
	      node = parent.id;
	    } else if (t.isProperty(node)) {
	      node = node.key;
	    }
	
	    var parts = [];
	
	    var add = function add(node) {
	      if (t.isModuleDeclaration(node)) {
	        if (node.source) {
	          add(node.source);
	        } else if (node.specifiers && node.specifiers.length) {
	          var _arr3 = node.specifiers;
	
	          for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	            var specifier = _arr3[_i3];
	            add(specifier);
	          }
	        } else if (node.declaration) {
	          add(node.declaration);
	        }
	      } else if (t.isModuleSpecifier(node)) {
	        add(node.local);
	      } else if (t.isMemberExpression(node)) {
	        add(node.object);
	        add(node.property);
	      } else if (t.isIdentifier(node)) {
	        parts.push(node.name);
	      } else if (t.isLiteral(node)) {
	        parts.push(node.value);
	      } else if (t.isCallExpression(node)) {
	        add(node.callee);
	      } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
	        var _arr4 = node.properties;
	
	        for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
	          var prop = _arr4[_i4];
	          add(prop.key || prop.argument);
	        }
	      }
	    };
	
	    add(node);
	
	    var id = parts.join("$");
	    id = id.replace(/^_/, "") || defaultName || "ref";
	
	    return this.generateUidIdentifier(id);
	  };
	
	  /**
	   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
	   * evaluating it wont result in potentially arbitrary code from being ran. The following are
	   * whitelisted and determined not cause side effects:
	   *
	   *  - `this` expressions
	   *  - `super` expressions
	   *  - Bound identifiers
	   */
	
	  Scope.prototype.isStatic = function isStatic(node) {
	    if (t.isThisExpression(node) || t.isSuper(node)) {
	      return true;
	    }
	
	    if (t.isIdentifier(node) && this.hasBinding(node.name)) {
	      return true;
	    }
	
	    return false;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
	    if (this.isStatic(node)) {
	      return null;
	    } else {
	      var id = this.generateUidIdentifierBasedOnNode(node);
	      if (!dontPush) this.push({ id: id });
	      return id;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(kind, name, id) {
	    var local = this.getOwnBindingInfo(name);
	    if (!local) return;
	
	    if (kind === "param") return;
	    if (kind === "hoisted" && local.kind === "let") return;
	
	    var duplicate = false;
	    if (!duplicate) duplicate = kind === "let" || kind === "const" || local.kind === "let" || local.kind === "const" || local.kind === "module";
	    if (!duplicate) duplicate = local.kind === "param" && (kind === "let" || kind === "const");
	
	    if (duplicate) {
	      throw this.file.errorWithNode(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.rename = function rename(oldName, newName, block) {
	    newName = newName || this.generateUidIdentifier(oldName).name;
	
	    var info = this.getBinding(oldName);
	    if (!info) return;
	
	    var state = {
	      newName: newName,
	      oldName: oldName,
	      binding: info.identifier,
	      info: info
	    };
	
	    var scope = info.scope;
	    scope.traverse(block || scope.block, renameVisitor, state);
	
	    if (!block) {
	      scope.removeOwnBinding(oldName);
	      scope.bindings[newName] = info;
	      state.binding.name = newName;
	    }
	
	    var file = this.file;
	    if (file) {
	      this._renameFromMap(file.moduleFormatter.localImports, oldName, newName, state.binding);
	      //this._renameFromMap(file.moduleFormatter.localExports, oldName, newName);
	    }
	  };
	
	  Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
	    if (map[oldName]) {
	      map[newName] = value;
	      map[oldName] = null;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.dump = function dump() {
	    var scope = this;
	    do {
	      console.log(scope.block.type, "Bindings:", Object.keys(scope.bindings));
	    } while (scope = scope.parent);
	    console.log("-------------");
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.toArray = function toArray(node, i) {
	    var file = this.file;
	
	    if (t.isIdentifier(node)) {
	      var binding = this.getBinding(node.name);
	      if (binding && binding.constant && binding.isTypeGeneric("Array")) return node;
	    }
	
	    if (t.isArrayExpression(node)) {
	      return node;
	    }
	
	    if (t.isIdentifier(node, { name: "arguments" })) {
	      return t.callExpression(t.memberExpression(file.addHelper("slice"), t.identifier("call")), [node]);
	    }
	
	    var helperName = "to-array";
	    var args = [node];
	    if (i === true) {
	      helperName = "to-consumable-array";
	    } else if (i) {
	      args.push(t.literal(i));
	      helperName = "sliced-to-array";
	      if (this.file.isLoose("es6.forOf")) helperName += "-loose";
	    }
	    return t.callExpression(file.addHelper(helperName), args);
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.registerDeclaration = function registerDeclaration(path) {
	    var node = path.node;
	    if (t.isFunctionDeclaration(node)) {
	      this.registerBinding("hoisted", path);
	    } else if (t.isVariableDeclaration(node)) {
	      var declarations = path.get("declarations");
	      var _arr5 = declarations;
	      for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
	        var declar = _arr5[_i5];
	        this.registerBinding(node.kind, declar);
	      }
	    } else if (t.isClassDeclaration(node)) {
	      this.registerBinding("let", path);
	    } else if (t.isImportDeclaration(node) || t.isExportDeclaration(node)) {
	      this.registerBinding("module", path);
	    } else {
	      this.registerBinding("unknown", path);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.registerConstantViolation = function registerConstantViolation(left, right) {
	    var ids = left.getBindingIdentifiers();
	    for (var name in ids) {
	      var binding = this.getBinding(name);
	      if (!binding) continue;
	
	      if (right) {
	        var rightType = right.typeAnnotation;
	        if (rightType && binding.isCompatibleWithType(rightType)) continue;
	      }
	
	      binding.reassign(left, right);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.registerBinding = function registerBinding(kind, path) {
	    if (!kind) throw new ReferenceError("no `kind`");
	
	    if (path.isVariableDeclaration()) {
	      var declarators = path.get("declarations");
	      var _arr6 = declarators;
	      for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
	        var declar = _arr6[_i6];
	        this.registerBinding(kind, declar);
	      }
	      return;
	    }
	
	    var ids = path.getBindingIdentifiers();
	
	    for (var name in ids) {
	      var id = ids[name];
	
	      this.checkBlockScopedCollisions(kind, name, id);
	
	      this.bindings[name] = new _binding2["default"]({
	        identifier: id,
	        scope: this,
	        path: path,
	        kind: kind
	      });
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.addGlobal = function addGlobal(node) {
	    this.globals[node.name] = node;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.hasUid = function hasUid(name) {
	    var scope = this;
	
	    do {
	      if (scope.uids[name]) return true;
	    } while (scope = scope.parent);
	
	    return false;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.hasGlobal = function hasGlobal(name) {
	    var scope = this;
	
	    do {
	      if (scope.globals[name]) return true;
	    } while (scope = scope.parent);
	
	    return false;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.hasReference = function hasReference(name) {
	    var scope = this;
	
	    do {
	      if (scope.references[name]) return true;
	    } while (scope = scope.parent);
	
	    return false;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.recrawl = function recrawl() {
	    this.path.setData("scopeInfo", null);
	    this.crawl();
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.isPure = function isPure(node) {
	    if (t.isIdentifier(node)) {
	      var bindingInfo = this.getBinding(node.name);
	      return bindingInfo && bindingInfo.constant;
	    } else {
	      return t.isPure(node);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.crawl = function crawl() {
	    var path = this.path;
	
	    //
	
	    var info = this.block._scopeInfo;
	    if (info) return (0, _lodashObjectExtend2["default"])(this, info);
	
	    info = this.block._scopeInfo = {
	      references: (0, _helpersObject2["default"])(),
	      bindings: (0, _helpersObject2["default"])(),
	      globals: (0, _helpersObject2["default"])(),
	      uids: (0, _helpersObject2["default"])() };
	
	    (0, _lodashObjectExtend2["default"])(this, info);
	
	    // ForStatement - left, init
	
	    if (path.isLoop()) {
	      var _arr7 = t.FOR_INIT_KEYS;
	
	      for (var _i7 = 0; _i7 < _arr7.length; _i7++) {
	        var key = _arr7[_i7];
	        var node = path.get(key);
	        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
	      }
	    }
	
	    // FunctionExpression - id
	
	    if (path.isFunctionExpression() && path.has("id")) {
	      if (!t.isProperty(path.parent, { method: true })) {
	        this.registerBinding("var", path.get("id"));
	      }
	    }
	
	    // Class
	
	    if (path.isClassDeclaration()) {
	      var name = path.node.id.name;
	      this.bindings[name] = this.parent.bindings[name];
	    }
	
	    if (path.isClassExpression() && path.has("id")) {
	      this.registerBinding("var", path);
	    }
	
	    // Function - params, rest
	
	    if (path.isFunction()) {
	      var params = path.get("params");
	      var _arr8 = params;
	      for (var _i8 = 0; _i8 < _arr8.length; _i8++) {
	        var param = _arr8[_i8];
	        this.registerBinding("param", param);
	      }
	      this.traverse(path.get("body").node, blockVariableVisitor, this);
	    }
	
	    // Program, Function - var variables
	
	    if (path.isProgram() || path.isFunction()) {
	      this.traverse(path.node, functionVariableVisitor, {
	        blockId: path.get("id").node,
	        scope: this
	      });
	    }
	
	    // Program, BlockStatement, Function - let variables
	
	    if (path.isBlockStatement() || path.isProgram()) {
	      this.traverse(path.node, blockVariableVisitor, this);
	    }
	
	    // CatchClause - param
	
	    if (path.isCatchClause()) {
	      this.registerBinding("let", path.get("param"));
	    }
	
	    // ComprehensionExpression - blocks
	
	    if (path.isComprehensionExpression()) {
	      this.registerBinding("let", path);
	    }
	
	    // Program
	
	    if (path.isProgram()) {
	      this.traverse(path.node, programReferenceVisitor, this);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.push = function push(opts) {
	    var path = this.path;
	
	    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
	      t.ensureBlock(path.node);
	      path = path.get("body");
	    }
	
	    if (!path.isBlockStatement() && !path.isProgram()) {
	      path = this.getBlockParent().path;
	    }
	
	    var unique = opts.unique;
	    var kind = opts.kind || "var";
	
	    var dataKey = "declaration:" + kind;
	    var declar = !unique && path.getData(dataKey);
	
	    if (!declar) {
	      declar = t.variableDeclaration(kind, []);
	      declar._generated = true;
	      declar._blockHoist = 2;
	
	      this.file.attachAuxiliaryComment(declar);
	
	      var _path$get$0$_containerInsertBefore = path.get("body")[0]._containerInsertBefore([declar]);
	
	      var declarPath = _path$get$0$_containerInsertBefore[0];
	
	      this.registerBinding(kind, declarPath);
	      if (!unique) path.setData(dataKey, declar);
	    }
	
	    declar.declarations.push(t.variableDeclarator(opts.id, opts.init));
	  };
	
	  /**
	   * Walk up to the top of the scope tree and get the `Program`.
	   */
	
	  Scope.prototype.getProgramParent = function getProgramParent() {
	    var scope = this;
	    while (scope.parent) {
	      scope = scope.parent;
	    }
	    return scope;
	  };
	
	  /**
	   * Walk up the scope tree until we hit either a Function or reach the
	   * very top and hit Program.
	   */
	
	  Scope.prototype.getFunctionParent = function getFunctionParent() {
	    var scope = this;
	    while (scope.parent && !t.isFunction(scope.block)) {
	      scope = scope.parent;
	    }
	    return scope;
	  };
	
	  /**
	   * Walk up the scope tree until we hit either a BlockStatement/Loop or reach the
	   * very top and hit Program.
	   */
	
	  Scope.prototype.getBlockParent = function getBlockParent() {
	    var scope = this;
	    while (scope.parent && !t.isFunction(scope.block) && !t.isLoop(scope.block) && !t.isFunction(scope.block)) {
	      scope = scope.parent;
	    }
	    return scope;
	  };
	
	  /**
	   * Walks the scope tree and gathers **all** bindings.
	   */
	
	  Scope.prototype.getAllBindings = function getAllBindings() {
	    var ids = (0, _helpersObject2["default"])();
	
	    var scope = this;
	    do {
	      (0, _lodashObjectDefaults2["default"])(ids, scope.bindings);
	      scope = scope.parent;
	    } while (scope);
	
	    return ids;
	  };
	
	  /**
	   * Walks the scope tree and gathers all declarations of `kind`.
	   */
	
	  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
	    var ids = (0, _helpersObject2["default"])();
	
	    var _arr9 = arguments;
	    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {
	      var kind = _arr9[_i9];
	      var scope = this;
	      do {
	        for (var name in scope.bindings) {
	          var binding = scope.bindings[name];
	          if (binding.kind === kind) ids[name] = binding;
	        }
	        scope = scope.parent;
	      } while (scope);
	    }
	
	    return ids;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
	    return this.getBindingIdentifier(name) === node;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.getBinding = function getBinding(name) {
	    var scope = this;
	
	    do {
	      var binding = scope.getOwnBindingInfo(name);
	      if (binding) return binding;
	    } while (scope = scope.parent);
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.getOwnBindingInfo = function getOwnBindingInfo(name) {
	    return this.bindings[name];
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {
	    var info = this.getBinding(name);
	    return info && info.identifier;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
	    var binding = this.bindings[name];
	    return binding && binding.identifier;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
	    return !!this.getOwnBindingInfo(name);
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.hasBinding = function hasBinding(name) {
	    if (!name) return false;
	    if (this.hasOwnBinding(name)) return true;
	    if (this.parentHasBinding(name)) return true;
	    if (this.hasUid(name)) return true;
	    if ((0, _lodashCollectionIncludes2["default"])(Scope.globals, name)) return true;
	    if ((0, _lodashCollectionIncludes2["default"])(Scope.contextVariables, name)) return true;
	    return false;
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.parentHasBinding = function parentHasBinding(name) {
	    return this.parent && this.parent.hasBinding(name);
	  };
	
	  /**
	   * Move a binding of `name` to another `scope`.
	   */
	
	  Scope.prototype.moveBindingTo = function moveBindingTo(name, scope) {
	    var info = this.getBinding(name);
	    if (info) {
	      info.scope.removeOwnBinding(name);
	      info.scope = scope;
	      scope.bindings[name] = info;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {
	    delete this.bindings[name];
	  };
	
	  /**
	   * Description
	   */
	
	  Scope.prototype.removeBinding = function removeBinding(name) {
	    var info = this.getBinding(name);
	    if (info) info.scope.removeOwnBinding(name);
	  };
	
	  _createClass(Scope, null, [{
	    key: "globals",
	    value: (0, _lodashArrayFlatten2["default"])([_globals2["default"].builtin, _globals2["default"].browser, _globals2["default"].node].map(Object.keys)),
	    enumerable: true
	  }, {
	    key: "contextVariables",
	    value: ["this", "arguments", "super"],
	    enumerable: true
	  }]);
	
	  return Scope;
	})();
	
	exports["default"] = Scope;
	module.exports = exports["default"];
	
	//path.setData("scope", this);

/***/ },
/* 237 */
/*!**************************!*\
  !*** external "globals" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("globals");

/***/ },
/* 238 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/lodash/object/defaults.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var assign = __webpack_require__(/*! ./assign */ 139),
	    assignDefaults = __webpack_require__(/*! ../internal/assignDefaults */ 239),
	    restParam = __webpack_require__(/*! ../function/restParam */ 137);
	
	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object for all destination properties that resolve to `undefined`. Once a
	 * property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	 * // => { 'user': 'barney', 'age': 36 }
	 */
	var defaults = restParam(function(args) {
	  var object = args[0];
	  if (object == null) {
	    return object;
	  }
	  args.push(assignDefaults);
	  return assign.apply(undefined, args);
	});
	
	module.exports = defaults;


/***/ },
/* 239 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/assignDefaults.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Used by `_.defaults` to customize its `_.assign` use.
	 *
	 * @private
	 * @param {*} objectValue The destination object property value.
	 * @param {*} sourceValue The source object property value.
	 * @returns {*} Returns the value to assign to the destination object.
	 */
	function assignDefaults(objectValue, sourceValue) {
	  return objectValue === undefined ? sourceValue : objectValue;
	}
	
	module.exports = assignDefaults;


/***/ },
/* 240 */
/*!***********************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/scope/binding.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var Binding = (function () {
	  function Binding(_ref) {
	    var identifier = _ref.identifier;
	    var scope = _ref.scope;
	    var path = _ref.path;
	    var kind = _ref.kind;
	
	    _classCallCheck(this, Binding);
	
	    this.constantViolations = [];
	    this.constant = true;
	
	    this.identifier = identifier;
	    this.references = 0;
	    this.referenced = false;
	
	    this.scope = scope;
	    this.path = path;
	    this.kind = kind;
	  }
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.setTypeAnnotation = function setTypeAnnotation() {
	    var typeInfo = this.path.getTypeAnnotation();
	    this.typeAnnotationInferred = typeInfo.inferred;
	    this.typeAnnotation = typeInfo.annotation;
	  };
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.isTypeGeneric = function isTypeGeneric() {
	    var _path;
	
	    return (_path = this.path).isTypeGeneric.apply(_path, arguments);
	  };
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.assignTypeGeneric = function assignTypeGeneric(type, params) {
	    var typeParams = null;
	    if (params) params = t.typeParameterInstantiation(params);
	    this.assignType(t.genericTypeAnnotation(t.identifier(type), typeParams));
	  };
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.assignType = function assignType(type) {
	    this.typeAnnotation = type;
	  };
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.reassign = function reassign(path) {
	    this.constant = false;
	    this.constantViolations.push(path);
	
	    if (this.typeAnnotationInferred) {
	      // destroy the inferred typeAnnotation
	      this.typeAnnotation = null;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.reference = function reference() {
	    this.referenced = true;
	    this.references++;
	  };
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.dereference = function dereference() {
	    this.references--;
	    this.referenced = !!this.references;
	  };
	
	  /**
	   * Description
	   */
	
	  Binding.prototype.isCompatibleWithType = function isCompatibleWithType(newType) {
	    return false;
	  };
	
	  return Binding;
	})();
	
	exports["default"] = Binding;
	module.exports = exports["default"];

/***/ },
/* 241 */
/*!************************************************!*\
  !*** ./~/babel-core/~/lodash/array/flatten.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(/*! ../internal/baseFlatten */ 242),
	    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ 136);
	
	/**
	 * Flattens a nested array. If `isDeep` is `true` the array is recursively
	 * flattened, otherwise it is only flattened a single level.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @param {boolean} [isDeep] Specify a deep flatten.
	 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, 3, [4]]]);
	 * // => [1, 2, 3, [4]]
	 *
	 * // using `isDeep`
	 * _.flatten([1, [2, 3, [4]]], true);
	 * // => [1, 2, 3, 4]
	 */
	function flatten(array, isDeep, guard) {
	  var length = array ? array.length : 0;
	  if (guard && isIterateeCall(array, isDeep, guard)) {
	    isDeep = false;
	  }
	  return length ? baseFlatten(array, isDeep) : [];
	}
	
	module.exports = flatten;


/***/ },
/* 242 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseFlatten.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(/*! ../lang/isArguments */ 109),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isArrayLike = __webpack_require__(/*! ./isArrayLike */ 110),
	    isObjectLike = __webpack_require__(/*! ./isObjectLike */ 114);
	
	/**
	 * The base implementation of `_.flatten` with added support for restricting
	 * flattening and specifying the start index.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {boolean} [isDeep] Specify a deep flatten.
	 * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, isDeep, isStrict) {
	  var index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	
	  while (++index < length) {
	    var value = array[index];
	    if (isObjectLike(value) && isArrayLike(value) &&
	        (isStrict || isArray(value) || isArguments(value))) {
	      if (isDeep) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        value = baseFlatten(value, isDeep, isStrict);
	      }
	      var valIndex = -1,
	          valLength = value.length;
	
	      while (++valIndex < valLength) {
	        result[++resIndex] = value[valIndex];
	      }
	    } else if (!isStrict) {
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = baseFlatten;


/***/ },
/* 243 */
/*!*************************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/path/evaluation.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	/**
	 * Walk the input `node` and statically evaluate if it's truthy.
	 *
	 * Returning `true` when we're sure that the expression will evaluate to a
	 * truthy value, `false` if we're sure that it will evaluate to a falsy
	 * value and `undefined` if we aren't sure. Because of this please do not
	 * rely on coercion when using this method and check with === if it's false.
	 *
	 * For example do:
	 *
	 *   if (t.evaluateTruthy(node) === false) falsyLogic();
	 *
	 * **AND NOT**
	 *
	 *   if (!t.evaluateTruthy(node)) falsyLogic();
	 *
	 */
	
	exports.evaluateTruthy = evaluateTruthy;
	
	/**
	 * Walk the input `node` and statically evaluate it.
	 *
	 * Returns an object in the form `{ confident, value }`. `confident` indicates
	 * whether or not we had to drop out of evaluating the expression because of
	 * hitting an unknown node that we couldn't confidently find the value of.
	 *
	 * Example:
	 *
	 *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
	 *   t.evaluate(parse("!true")) // { confident: true, value: false }
	 *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
	 *
	 */
	
	exports.evaluate = evaluate;
	
	function evaluateTruthy() {
	  var res = this.evaluate();
	  if (res.confident) return !!res.value;
	}
	
	function evaluate() {
	  var confident = true;
	
	  var value = evaluate(this);
	  if (!confident) value = undefined;
	  return {
	    confident: confident,
	    value: value
	  };
	
	  function evaluate(path) {
	    if (!confident) return;
	
	    var node = path.node;
	
	    if (path.isSequenceExpression()) {
	      var exprs = path.get("expressions");
	      return evaluate(exprs[exprs.length - 1]);
	    }
	
	    if (path.isLiteral()) {
	      if (node.regex) {} else {
	        return node.value;
	      }
	    }
	
	    if (path.isConditionalExpression()) {
	      if (evaluate(path.get("test"))) {
	        return evaluate(path.get("consequent"));
	      } else {
	        return evaluate(path.get("alternate"));
	      }
	    }
	
	    if (path.isIdentifier({ name: "undefined" })) {
	      return undefined;
	    }
	
	    if (path.isIdentifier() || path.isMemberExpression()) {
	      path = path.resolve();
	      if (path) {
	        return evaluate(path);
	      } else {
	        return confident = false;
	      }
	    }
	
	    if (path.isUnaryExpression({ prefix: true })) {
	      var arg = evaluate(path.get("argument"));
	      switch (node.operator) {
	        case "void":
	          return undefined;
	        case "!":
	          return !arg;
	        case "+":
	          return +arg;
	        case "-":
	          return -arg;
	        case "~":
	          return ~arg;
	      }
	    }
	
	    if (path.isArrayExpression() || path.isObjectExpression()) {}
	
	    if (path.isLogicalExpression()) {
	      var left = evaluate(path.get("left"));
	      var right = evaluate(path.get("right"));
	
	      switch (node.operator) {
	        case "||":
	          return left || right;
	        case "&&":
	          return left && right;
	      }
	    }
	
	    if (path.isBinaryExpression()) {
	      var left = evaluate(path.get("left"));
	      var right = evaluate(path.get("right"));
	
	      switch (node.operator) {
	        case "-":
	          return left - right;
	        case "+":
	          return left + right;
	        case "/":
	          return left / right;
	        case "*":
	          return left * right;
	        case "%":
	          return left % right;
	        case "**":
	          return Math.pow(left, right);
	        case "<":
	          return left < right;
	        case ">":
	          return left > right;
	        case "<=":
	          return left <= right;
	        case ">=":
	          return left >= right;
	        case "==":
	          return left == right;
	        case "!=":
	          return left != right;
	        case "===":
	          return left === right;
	        case "!==":
	          return left !== right;
	      }
	    }
	
	    confident = false;
	  }
	}
	
	// we have a regex and we can't represent it natively
	
	// we could evaluate these but it's probably impractical and not very useful

/***/ },
/* 244 */
/*!*************************************************************!*\
  !*** ./~/babel-core/lib/babel/traversal/path/conversion.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	/**
	 * Description
	 */
	
	exports.toComputedKey = toComputedKey;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function toComputedKey() {
	  var node = this.node;
	
	  var key;
	  if (this.isMemberExpression()) {
	    key = node.property;
	  } else if (this.isProperty()) {
	    key = node.key;
	  } else {
	    throw new ReferenceError("todo");
	  }
	
	  if (!node.computed) {
	    if (t.isIdentifier(key)) key = t.literal(key.name);
	  }
	
	  return key;
	}

/***/ },
/* 245 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isFunction.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseIsFunction = __webpack_require__(/*! ../internal/baseIsFunction */ 246),
	    getNative = __webpack_require__(/*! ../internal/getNative */ 116);
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/** Native method references. */
	var Uint8Array = getNative(global, 'Uint8Array');
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return objToString.call(value) == funcTag;
	};
	
	module.exports = isFunction;


/***/ },
/* 246 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseIsFunction.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.isFunction` without support for environments
	 * with incorrect `typeof` results.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 */
	function baseIsFunction(value) {
	  // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	  // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	  return typeof value == 'function' || false;
	}
	
	module.exports = baseIsFunction;


/***/ },
/* 247 */
/*!*************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/file/index.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _convertSourceMap = __webpack_require__(/*! convert-source-map */ 248);
	
	var _convertSourceMap2 = _interopRequireDefault(_convertSourceMap);
	
	var _optionParsers = __webpack_require__(/*! ./option-parsers */ 249);
	
	var optionParsers = _interopRequireWildcard(_optionParsers);
	
	var _modules = __webpack_require__(/*! ../modules */ 422);
	
	var _modules2 = _interopRequireDefault(_modules);
	
	var _pluginManager = __webpack_require__(/*! ./plugin-manager */ 412);
	
	var _pluginManager2 = _interopRequireDefault(_pluginManager);
	
	var _shebangRegex = __webpack_require__(/*! shebang-regex */ 427);
	
	var _shebangRegex2 = _interopRequireDefault(_shebangRegex);
	
	var _traversalPath = __webpack_require__(/*! ../../traversal/path */ 153);
	
	var _traversalPath2 = _interopRequireDefault(_traversalPath);
	
	var _transformer = __webpack_require__(/*! ../transformer */ 143);
	
	var _transformer2 = _interopRequireDefault(_transformer);
	
	var _lodashLangIsFunction = __webpack_require__(/*! lodash/lang/isFunction */ 245);
	
	var _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);
	
	var _pathIsAbsolute = __webpack_require__(/*! path-is-absolute */ 428);
	
	var _pathIsAbsolute2 = _interopRequireDefault(_pathIsAbsolute);
	
	var _toolsResolveRc = __webpack_require__(/*! ../../tools/resolve-rc */ 100);
	
	var _toolsResolveRc2 = _interopRequireDefault(_toolsResolveRc);
	
	var _sourceMap = __webpack_require__(/*! source-map */ 398);
	
	var _sourceMap2 = _interopRequireDefault(_sourceMap);
	
	var _index = __webpack_require__(/*! ./../index */ 268);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _generation = __webpack_require__(/*! ../../generation */ 394);
	
	var _generation2 = _interopRequireDefault(_generation);
	
	var _helpersCodeFrame = __webpack_require__(/*! ../../helpers/code-frame */ 209);
	
	var _helpersCodeFrame2 = _interopRequireDefault(_helpersCodeFrame);
	
	var _lodashObjectDefaults = __webpack_require__(/*! lodash/object/defaults */ 238);
	
	var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _traversal = __webpack_require__(/*! ../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _lodashObjectAssign = __webpack_require__(/*! lodash/object/assign */ 139);
	
	var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
	
	var _logger = __webpack_require__(/*! ./logger */ 406);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _helpersParse = __webpack_require__(/*! ../../helpers/parse */ 214);
	
	var _helpersParse2 = _interopRequireDefault(_helpersParse);
	
	var _traversalScope = __webpack_require__(/*! ../../traversal/scope */ 236);
	
	var _traversalScope2 = _interopRequireDefault(_traversalScope);
	
	var _helpersMerge = __webpack_require__(/*! ../../helpers/merge */ 102);
	
	var _helpersMerge2 = _interopRequireDefault(_helpersMerge);
	
	var _slash = __webpack_require__(/*! slash */ 265);
	
	var _slash2 = _interopRequireDefault(_slash);
	
	var _lodashLangClone = __webpack_require__(/*! lodash/lang/clone */ 273);
	
	var _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _apiNode = __webpack_require__(/*! ../../api/node */ 142);
	
	var api = _interopRequireWildcard(_apiNode);
	
	var _path = __webpack_require__(/*! path */ 96);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var File = (function () {
	  function File(_x, pipeline) {
	    var opts = arguments[0] === undefined ? {} : arguments[0];
	
	    _classCallCheck(this, File);
	
	    this.transformerDependencies = {};
	
	    this.dynamicImportTypes = {};
	    this.dynamicImportIds = {};
	    this.dynamicImports = [];
	
	    this.declarations = {};
	    this.usedHelpers = {};
	    this.dynamicData = {};
	    this.metadata = {};
	    this.data = {};
	
	    this.pipeline = pipeline;
	    this.log = new _logger2["default"](this, opts.filename || "unknown");
	    this.opts = this.normalizeOptions(opts);
	    this.ast = {};
	
	    this.buildTransformers();
	  }
	
	  File.prototype.normalizeOptions = function normalizeOptions(opts) {
	    opts = (0, _lodashObjectAssign2["default"])({}, opts);
	
	    if (opts.filename) {
	      var rcFilename = opts.filename;
	      if (!(0, _pathIsAbsolute2["default"])(rcFilename)) rcFilename = _path2["default"].join(process.cwd(), rcFilename);
	      opts = (0, _toolsResolveRc2["default"])(rcFilename, opts);
	    }
	
	    //
	
	    for (var key in opts) {
	      if (key[0] === "_") continue;
	
	      var option = File.options[key];
	      if (!option) this.log.error("Unknown option: " + key, ReferenceError);
	    }
	
	    var envKey = process.env.BABEL_ENV || process.env.NODE_ENV || "development";
	    if (opts.env) (0, _helpersMerge2["default"])(opts, opts.env[envKey]);
	
	    for (var key in File.options) {
	      var option = File.options[key];
	
	      var val = opts[key];
	      if (!val && option.optional) continue;
	
	      if (val && option.deprecated) {
	        throw new Error("Deprecated option " + key + ": " + option.deprecated);
	      }
	
	      if (val == null) {
	        val = (0, _lodashLangClone2["default"])(option["default"]);
	      }
	
	      var optionParser = optionParsers[option.type];
	      if (optionParser) val = optionParser(key, val, this.pipeline);
	
	      if (option.alias) {
	        opts[option.alias] = opts[option.alias] || val;
	      } else {
	        opts[key] = val;
	      }
	    }
	
	    if (opts.inputSourceMap) {
	      opts.sourceMaps = true;
	    }
	
	    // normalize windows path separators to unix
	    opts.filename = (0, _slash2["default"])(opts.filename);
	    if (opts.sourceRoot) {
	      opts.sourceRoot = (0, _slash2["default"])(opts.sourceRoot);
	    }
	
	    if (opts.moduleId) {
	      opts.moduleIds = true;
	    }
	
	    opts.basename = _path2["default"].basename(opts.filename, _path2["default"].extname(opts.filename));
	
	    opts.ignore = util.arrayify(opts.ignore, util.regexify);
	    opts.only = util.arrayify(opts.only, util.regexify);
	
	    (0, _lodashObjectDefaults2["default"])(opts, {
	      moduleRoot: opts.sourceRoot
	    });
	
	    (0, _lodashObjectDefaults2["default"])(opts, {
	      sourceRoot: opts.moduleRoot
	    });
	
	    (0, _lodashObjectDefaults2["default"])(opts, {
	      filenameRelative: opts.filename
	    });
	
	    (0, _lodashObjectDefaults2["default"])(opts, {
	      sourceFileName: opts.filenameRelative,
	      sourceMapTarget: opts.filenameRelative
	    });
	
	    //
	
	    if (opts.externalHelpers) {
	      this.set("helpersNamespace", t.identifier("babelHelpers"));
	    }
	
	    return opts;
	  };
	
	  File.prototype.isLoose = function isLoose(key) {
	    return (0, _lodashCollectionIncludes2["default"])(this.opts.loose, key);
	  };
	
	  File.prototype.buildTransformers = function buildTransformers() {
	    var file = this;
	
	    var transformers = this.transformers = {};
	
	    var secondaryStack = [];
	    var stack = [];
	
	    // build internal transformers
	    for (var key in this.pipeline.transformers) {
	      var transformer = this.pipeline.transformers[key];
	      var pass = transformers[key] = transformer.buildPass(file);
	
	      if (pass.canTransform()) {
	        stack.push(pass);
	
	        if (transformer.metadata.secondPass) {
	          secondaryStack.push(pass);
	        }
	
	        if (transformer.manipulateOptions) {
	          transformer.manipulateOptions(file.opts, file);
	        }
	      }
	    }
	
	    // init plugins!
	    var beforePlugins = [];
	    var afterPlugins = [];
	    var pluginManager = new _pluginManager2["default"]({
	      file: this,
	      transformers: this.transformers,
	      before: beforePlugins,
	      after: afterPlugins
	    });
	    for (var i = 0; i < file.opts.plugins.length; i++) {
	      pluginManager.add(file.opts.plugins[i]);
	    }
	    stack = beforePlugins.concat(stack, afterPlugins);
	
	    // build transformer stack
	    this.uncollapsedTransformerStack = stack = stack.concat(secondaryStack);
	
	    // build dependency graph
	    var _arr = stack;
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var pass = _arr[_i];var _arr2 = pass.transformer.dependencies;
	
	      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	        var dep = _arr2[_i2];
	        this.transformerDependencies[dep] = pass.key;
	      }
	    }
	
	    // collapse stack categories
	    this.transformerStack = this.collapseStack(stack);
	  };
	
	  File.prototype.collapseStack = function collapseStack(_stack) {
	    var stack = [];
	    var ignore = [];
	
	    var _arr3 = _stack;
	    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	      var pass = _arr3[_i3];
	      // been merged
	      if (ignore.indexOf(pass) >= 0) continue;
	
	      var group = pass.transformer.metadata.group;
	
	      // can't merge
	      if (!pass.canTransform() || !group) {
	        stack.push(pass);
	        continue;
	      }
	
	      var mergeStack = [];
	      var _arr4 = _stack;
	      for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
	        var _pass = _arr4[_i4];
	        if (_pass.transformer.metadata.group === group) {
	          mergeStack.push(_pass);
	          ignore.push(_pass);
	        }
	      }
	
	      var visitors = [];
	      var _arr5 = mergeStack;
	      for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
	        var _pass2 = _arr5[_i5];
	        visitors.push(_pass2.handlers);
	      }
	      var visitor = _traversal2["default"].visitors.merge(visitors);
	      var mergeTransformer = new _transformer2["default"](group, visitor);
	      //console.log(mergeTransformer);
	      stack.push(mergeTransformer.buildPass(this));
	    }
	
	    return stack;
	  };
	
	  File.prototype.set = function set(key, val) {
	    return this.data[key] = val;
	  };
	
	  File.prototype.setDynamic = function setDynamic(key, fn) {
	    this.dynamicData[key] = fn;
	  };
	
	  File.prototype.get = function get(key) {
	    var data = this.data[key];
	    if (data) {
	      return data;
	    } else {
	      var dynamic = this.dynamicData[key];
	      if (dynamic) {
	        return this.set(key, dynamic());
	      }
	    }
	  };
	
	  File.prototype.resolveModuleSource = function resolveModuleSource(source) {
	    var resolveModuleSource = this.opts.resolveModuleSource;
	    if (resolveModuleSource) source = resolveModuleSource(source, this.opts.filename);
	    return source;
	  };
	
	  File.prototype.addImport = function addImport(source, name, type) {
	    name = name || source;
	    var id = this.dynamicImportIds[name];
	
	    if (!id) {
	      source = this.resolveModuleSource(source);
	      id = this.dynamicImportIds[name] = this.scope.generateUidIdentifier(name);
	
	      var specifiers = [t.importDefaultSpecifier(id)];
	      var declar = t.importDeclaration(specifiers, t.literal(source));
	      declar._blockHoist = 3;
	
	      if (type) {
	        var modules = this.dynamicImportTypes[type] = this.dynamicImportTypes[type] || [];
	        modules.push(declar);
	      }
	
	      if (this.transformers["es6.modules"].canTransform()) {
	        this.moduleFormatter.importSpecifier(specifiers[0], declar, this.dynamicImports);
	        this.moduleFormatter.hasLocalImports = true;
	      } else {
	        this.dynamicImports.push(declar);
	      }
	    }
	
	    return id;
	  };
	
	  File.prototype.attachAuxiliaryComment = function attachAuxiliaryComment(node) {
	    var comment = this.opts.auxiliaryComment;
	    if (comment) {
	      node.leadingComments = node.leadingComments || [];
	      node.leadingComments.push({
	        type: "Line",
	        value: " " + comment
	      });
	    }
	    return node;
	  };
	
	  File.prototype.addHelper = function addHelper(name) {
	    var isSolo = (0, _lodashCollectionIncludes2["default"])(File.soloHelpers, name);
	
	    if (!isSolo && !(0, _lodashCollectionIncludes2["default"])(File.helpers, name)) {
	      throw new ReferenceError("Unknown helper " + name);
	    }
	
	    var program = this.ast.program;
	
	    var declar = this.declarations[name];
	    if (declar) return declar;
	
	    this.usedHelpers[name] = true;
	
	    if (!isSolo) {
	      var generator = this.get("helperGenerator");
	      var runtime = this.get("helpersNamespace");
	      if (generator) {
	        return generator(name);
	      } else if (runtime) {
	        var id = t.identifier(t.toIdentifier(name));
	        return t.memberExpression(runtime, id);
	      }
	    }
	
	    var ref = util.template("helper-" + name);
	
	    var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
	
	    if (t.isFunctionExpression(ref) && !ref.id) {
	      ref.body._compact = true;
	      ref._generated = true;
	      ref.id = uid;
	      ref.type = "FunctionDeclaration";
	      this.attachAuxiliaryComment(ref);
	      this.path.unshiftContainer("body", ref);
	    } else {
	      ref._compact = true;
	      this.scope.push({
	        id: uid,
	        init: ref,
	        unique: true
	      });
	    }
	
	    return uid;
	  };
	
	  File.prototype.errorWithNode = function errorWithNode(node, msg) {
	    var Error = arguments[2] === undefined ? SyntaxError : arguments[2];
	
	    var loc = node.loc.start;
	    var err = new Error("Line " + loc.line + ": " + msg);
	    err.loc = loc;
	    return err;
	  };
	
	  File.prototype.mergeSourceMap = function mergeSourceMap(map) {
	    var opts = this.opts;
	
	    var inputMap = opts.inputSourceMap;
	
	    if (inputMap) {
	      map.sources[0] = inputMap.file;
	
	      var inputMapConsumer = new _sourceMap2["default"].SourceMapConsumer(inputMap);
	      var outputMapConsumer = new _sourceMap2["default"].SourceMapConsumer(map);
	      var outputMapGenerator = _sourceMap2["default"].SourceMapGenerator.fromSourceMap(outputMapConsumer);
	      outputMapGenerator.applySourceMap(inputMapConsumer);
	
	      var mergedMap = outputMapGenerator.toJSON();
	      mergedMap.sources = inputMap.sources;
	      mergedMap.file = inputMap.file;
	      return mergedMap;
	    }
	
	    return map;
	  };
	
	  File.prototype.getModuleFormatter = function getModuleFormatter(type) {
	    if ((0, _lodashLangIsFunction2["default"])(type) || !_modules2["default"][type]) {
	      this.log.deprecate("Custom module formatters are deprecated and will be removed in the next major. Please use Babel plugins instead.");
	    }
	
	    var ModuleFormatter = (0, _lodashLangIsFunction2["default"])(type) ? type : _modules2["default"][type];
	
	    if (!ModuleFormatter) {
	      var loc = util.resolveRelative(type);
	      if (loc) ModuleFormatter = __webpack_require__(/*! . */ 413)(loc);
	    }
	
	    if (!ModuleFormatter) {
	      throw new ReferenceError("Unknown module formatter type " + JSON.stringify(type));
	    }
	
	    return new ModuleFormatter(this);
	  };
	
	  File.prototype.parse = function parse(code) {
	    var opts = this.opts;
	
	    //
	
	    var parseOpts = {
	      highlightCode: opts.highlightCode,
	      nonStandard: opts.nonStandard,
	      filename: opts.filename,
	      plugins: {}
	    };
	
	    var features = parseOpts.features = {};
	    for (var key in this.transformers) {
	      var transformer = this.transformers[key];
	      features[key] = transformer.canTransform();
	    }
	
	    parseOpts.looseModules = this.isLoose("es6.modules");
	    parseOpts.strictMode = features.strict;
	    parseOpts.sourceType = "module";
	
	    this.log.debug("Parse start");
	    var tree = (0, _helpersParse2["default"])(code, parseOpts);
	    this.log.debug("Parse stop");
	    return tree;
	  };
	
	  File.prototype._addAst = function _addAst(ast) {
	    this.path = _traversalPath2["default"].get(null, ast, ast, "program", this).setContext(null, this);
	    this.scope = this.path.scope;
	    this.ast = ast;
	  };
	
	  File.prototype.addAst = function addAst(ast) {
	    this.log.debug("Start set AST");
	    this._addAst(ast);
	    this.log.debug("End set AST");
	
	    this.log.debug("Start module formatter init");
	    var modFormatter = this.moduleFormatter = this.getModuleFormatter(this.opts.modules);
	    if (modFormatter.init && this.transformers["es6.modules"].canTransform()) {
	      modFormatter.init();
	    }
	    this.log.debug("End module formatter init");
	
	    this.call("pre");
	    var _arr6 = this.transformerStack;
	    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
	      var pass = _arr6[_i6];
	      pass.transform();
	    }
	    this.call("post");
	  };
	
	  File.prototype.wrap = function wrap(code, callback) {
	    code = code + "";
	
	    try {
	      if (this.shouldIgnore()) {
	        return {
	          metadata: this.metadata,
	          ignored: true,
	          code: code,
	          map: null,
	          ast: null
	        };
	      }
	
	      callback();
	
	      return this.generate();
	    } catch (err) {
	      if (err._babel) {
	        throw err;
	      } else {
	        err._babel = true;
	      }
	
	      var message = err.message = "" + this.opts.filename + ": " + err.message;
	
	      var loc = err.loc;
	      if (loc) {
	        err.codeFrame = (0, _helpersCodeFrame2["default"])(code, loc.line, loc.column + 1, this.opts);
	        message += "\n" + err.codeFrame;
	      }
	
	      if (err.stack) {
	        var newStack = err.stack.replace(err.message, message);
	        try {
	          err.stack = newStack;
	        } catch (e) {}
	      }
	
	      throw err;
	    }
	  };
	
	  File.prototype.addCode = function addCode(code, parseCode) {
	    code = (code || "") + "";
	    code = this.parseInputSourceMap(code);
	    this.code = code;
	
	    if (parseCode) {
	      this.parseShebang();
	      this.addAst(this.parse(this.code));
	    }
	  };
	
	  File.prototype.shouldIgnore = function shouldIgnore() {
	    var opts = this.opts;
	    return util.shouldIgnore(opts.filename, opts.ignore, opts.only);
	  };
	
	  File.prototype.call = function call(key) {
	    var _arr7 = this.uncollapsedTransformerStack;
	
	    for (var _i7 = 0; _i7 < _arr7.length; _i7++) {
	      var pass = _arr7[_i7];
	      var fn = pass.transformer[key];
	      if (fn) fn(this);
	    }
	  };
	
	  File.prototype.parseInputSourceMap = function parseInputSourceMap(code) {
	    var opts = this.opts;
	
	    if (opts.inputSourceMap !== false) {
	      var inputMap = _convertSourceMap2["default"].fromSource(code);
	      if (inputMap) {
	        opts.inputSourceMap = inputMap.toObject();
	        code = _convertSourceMap2["default"].removeComments(code);
	      }
	    }
	
	    return code;
	  };
	
	  File.prototype.parseShebang = function parseShebang() {
	    var shebangMatch = _shebangRegex2["default"].exec(this.code);
	    if (shebangMatch) {
	      this.shebang = shebangMatch[0];
	      this.code = this.code.replace(_shebangRegex2["default"], "");
	    }
	  };
	
	  File.prototype.generate = function generate() {
	    var opts = this.opts;
	    var ast = this.ast;
	
	    var result = {
	      metadata: this.metadata,
	      code: "",
	      map: null,
	      ast: null
	    };
	
	    if (this.opts.metadataUsedHelpers) {
	      result.metadata.usedHelpers = Object.keys(this.usedHelpers);
	    }
	
	    if (opts.ast) result.ast = ast;
	    if (!opts.code) return result;
	
	    this.log.debug("Generation start");
	
	    var _result = (0, _generation2["default"])(ast, opts, this.code);
	    result.code = _result.code;
	    result.map = _result.map;
	
	    this.log.debug("Generation end");
	
	    if (this.shebang) {
	      // add back shebang
	      result.code = "" + this.shebang + "\n" + result.code;
	    }
	
	    if (result.map) {
	      result.map = this.mergeSourceMap(result.map);
	    }
	
	    if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
	      result.code += "\n" + _convertSourceMap2["default"].fromObject(result.map).toComment();
	    }
	
	    if (opts.sourceMaps === "inline") {
	      result.map = null;
	    }
	
	    return result;
	  };
	
	  _createClass(File, null, [{
	    key: "helpers",
	    value: ["inherits", "defaults", "create-class", "create-decorated-class", "create-decorated-object", "define-decorated-property-descriptor", "tagged-template-literal", "tagged-template-literal-loose", "to-array", "to-consumable-array", "sliced-to-array", "sliced-to-array-loose", "object-without-properties", "has-own", "slice", "bind", "define-property", "async-to-generator", "interop-require-wildcard", "interop-require-default", "typeof", "extends", "get", "set", "class-call-check", "object-destructuring-empty", "temporal-undefined", "temporal-assert-defined", "self-global", "default-props", "instanceof",
	
	    // legacy
	    "interop-require"],
	    enumerable: true
	  }, {
	    key: "soloHelpers",
	    value: [],
	    enumerable: true
	  }, {
	    key: "options",
	    value: __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./options\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
	    enumerable: true
	  }]);
	
	  return File;
	})();
	
	exports["default"] = File;
	module.exports = exports["default"];
	
	// `err.stack` may be a readonly property in some environments

/***/ },
/* 248 */
/*!*************************************!*\
  !*** external "convert-source-map" ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("convert-source-map");

/***/ },
/* 249 */
/*!**********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/file/option-parsers.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.transformerList = transformerList;
	exports.number = number;
	exports.boolean = boolean;
	exports.booleanString = booleanString;
	exports.list = list;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	function transformerList(key, val, pipeline) {
	  val = util.arrayify(val);
	
	  if (val.indexOf("all") >= 0 || val.indexOf(true) >= 0) {
	    val = Object.keys(pipeline.transformers);
	  }
	
	  return pipeline._ensureTransformerNames(key, val);
	}
	
	function number(key, val) {
	  return +val;
	}
	
	function boolean(key, val) {
	  return !!val;
	}
	
	function booleanString(key, val) {
	  return util.booleanify(val);
	}
	
	function list(key, val) {
	  return util.list(val);
	}

/***/ },
/* 250 */
/*!****************************************!*\
  !*** ./~/babel-core/lib/babel/util.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {"use strict";
	
	exports.__esModule = true;
	exports.canCompile = canCompile;
	exports.resolve = resolve;
	exports.resolveRelative = resolveRelative;
	exports.list = list;
	exports.regexify = regexify;
	exports.arrayify = arrayify;
	exports.booleanify = booleanify;
	exports.shouldIgnore = shouldIgnore;
	
	//
	
	exports.template = template;
	exports.parseTemplate = parseTemplate;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	__webpack_require__(/*! ./patch */ 252);
	
	var _lodashStringEscapeRegExp = __webpack_require__(/*! lodash/string/escapeRegExp */ 118);
	
	var _lodashStringEscapeRegExp2 = _interopRequireDefault(_lodashStringEscapeRegExp);
	
	var _lodashStringStartsWith = __webpack_require__(/*! lodash/string/startsWith */ 254);
	
	var _lodashStringStartsWith2 = _interopRequireDefault(_lodashStringStartsWith);
	
	var _lodashLangCloneDeep = __webpack_require__(/*! lodash/lang/cloneDeep */ 255);
	
	var _lodashLangCloneDeep2 = _interopRequireDefault(_lodashLangCloneDeep);
	
	var _lodashLangIsBoolean = __webpack_require__(/*! lodash/lang/isBoolean */ 208);
	
	var _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);
	
	var _messages = __webpack_require__(/*! ./messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _minimatch = __webpack_require__(/*! minimatch */ 261);
	
	var _minimatch2 = _interopRequireDefault(_minimatch);
	
	var _lodashCollectionContains = __webpack_require__(/*! lodash/collection/contains */ 262);
	
	var _lodashCollectionContains2 = _interopRequireDefault(_lodashCollectionContains);
	
	var _traversal = __webpack_require__(/*! ./traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _lodashLangIsString = __webpack_require__(/*! lodash/lang/isString */ 148);
	
	var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
	
	var _lodashLangIsRegExp = __webpack_require__(/*! lodash/lang/isRegExp */ 202);
	
	var _lodashLangIsRegExp2 = _interopRequireDefault(_lodashLangIsRegExp);
	
	var _module2 = __webpack_require__(/*! module */ 251);
	
	var _module3 = _interopRequireDefault(_module2);
	
	var _lodashLangIsEmpty = __webpack_require__(/*! lodash/lang/isEmpty */ 263);
	
	var _lodashLangIsEmpty2 = _interopRequireDefault(_lodashLangIsEmpty);
	
	var _helpersParse = __webpack_require__(/*! ./helpers/parse */ 214);
	
	var _helpersParse2 = _interopRequireDefault(_helpersParse);
	
	var _path = __webpack_require__(/*! path */ 96);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _lodashObjectHas = __webpack_require__(/*! lodash/object/has */ 264);
	
	var _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);
	
	var _fs = __webpack_require__(/*! fs */ 98);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _types = __webpack_require__(/*! ./types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var _slash = __webpack_require__(/*! slash */ 265);
	
	var _slash2 = _interopRequireDefault(_slash);
	
	var _util = __webpack_require__(/*! util */ 204);
	
	exports.inherits = _util.inherits;
	exports.inspect = _util.inspect;
	
	function canCompile(filename, altExts) {
	  var exts = altExts || canCompile.EXTENSIONS;
	  var ext = _path2["default"].extname(filename);
	  return (0, _lodashCollectionContains2["default"])(exts, ext);
	}
	
	canCompile.EXTENSIONS = [".js", ".jsx", ".es6", ".es"];
	
	function resolve(loc) {
	  try {
	    return /*require.resolve*/(__webpack_require__(/*! . */ 266).resolve(loc));
	  } catch (err) {
	    return null;
	  }
	}
	
	var relativeMod;
	
	function resolveRelative(loc) {
	  // we're in the browser, probably
	  if (typeof _module3["default"] === "object") return null;
	
	  if (!relativeMod) {
	    relativeMod = new _module3["default"]();
	    relativeMod.paths = _module3["default"]._nodeModulePaths(process.cwd());
	  }
	
	  try {
	    return _module3["default"]._resolveFilename(loc, relativeMod);
	  } catch (err) {
	    return null;
	  }
	}
	
	function list(val) {
	  if (!val) {
	    return [];
	  } else if (Array.isArray(val)) {
	    return val;
	  } else if (typeof val === "string") {
	    return val.split(",");
	  } else {
	    return [val];
	  }
	}
	
	function regexify(val) {
	  if (!val) return new RegExp(/.^/);
	
	  if (Array.isArray(val)) val = new RegExp(val.map(_lodashStringEscapeRegExp2["default"]).join("|"), "i");
	
	  if ((0, _lodashLangIsString2["default"])(val)) {
	    // normalise path separators
	    val = (0, _slash2["default"])(val);
	
	    // remove starting wildcards or relative separator if present
	    if ((0, _lodashStringStartsWith2["default"])(val, "./") || (0, _lodashStringStartsWith2["default"])(val, "*/")) val = val.slice(2);
	    if ((0, _lodashStringStartsWith2["default"])(val, "**/")) val = val.slice(3);
	
	    var regex = _minimatch2["default"].makeRe(val, { nocase: true });
	    return new RegExp(regex.source.slice(1, -1), "i");
	  }
	
	  if ((0, _lodashLangIsRegExp2["default"])(val)) return val;
	
	  throw new TypeError("illegal type for regexify");
	}
	
	function arrayify(val, mapFn) {
	  if (!val) return [];
	  if ((0, _lodashLangIsBoolean2["default"])(val)) return arrayify([val], mapFn);
	  if ((0, _lodashLangIsString2["default"])(val)) return arrayify(list(val), mapFn);
	
	  if (Array.isArray(val)) {
	    if (mapFn) val = val.map(mapFn);
	    return val;
	  }
	
	  return [val];
	}
	
	function booleanify(val) {
	  if (val === "true") return true;
	  if (val === "false") return false;
	  return val;
	}
	
	function shouldIgnore(filename, ignore, only) {
	  filename = (0, _slash2["default"])(filename);
	
	  if (only.length) {
	    var _arr = only;
	
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var pattern = _arr[_i];
	      if (pattern.test(filename)) return false;
	    }
	    return true;
	  } else if (ignore.length) {
	    var _arr2 = ignore;
	
	    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	      var pattern = _arr2[_i2];
	      if (pattern.test(filename)) return true;
	    }
	  }
	
	  return false;
	}
	
	var templateVisitor = {
	  enter: function enter(node, parent, scope, nodes) {
	    if (t.isExpressionStatement(node)) {
	      node = node.expression;
	    }
	
	    if (t.isIdentifier(node) && (0, _lodashObjectHas2["default"])(nodes, node.name)) {
	      this.skip();
	      this.replaceInline(nodes[node.name]);
	    }
	  }
	};
	function template(name, nodes, keepExpression) {
	  var ast = exports.templates[name];
	  if (!ast) throw new ReferenceError("unknown template " + name);
	
	  if (nodes === true) {
	    keepExpression = true;
	    nodes = null;
	  }
	
	  ast = (0, _lodashLangCloneDeep2["default"])(ast);
	
	  if (!(0, _lodashLangIsEmpty2["default"])(nodes)) {
	    (0, _traversal2["default"])(ast, templateVisitor, null, nodes);
	  }
	
	  if (ast.body.length > 1) return ast.body;
	
	  var node = ast.body[0];
	
	  if (!keepExpression && t.isExpressionStatement(node)) {
	    return node.expression;
	  } else {
	    return node;
	  }
	}
	
	function parseTemplate(loc, code) {
	  var ast = (0, _helpersParse2["default"])(code, { filename: loc, looseModules: true }).program;
	  ast = _traversal2["default"].removeProperties(ast);
	  return ast;
	}
	
	function loadTemplates() {
	  var templates = {};
	
	  var templatesLoc = _path2["default"].join(__dirname, "transformation/templates");
	  if (!_fs2["default"].existsSync(templatesLoc)) {
	    throw new ReferenceError(messages.get("missingTemplatesDirectory"));
	  }
	
	  var _arr3 = _fs2["default"].readdirSync(templatesLoc);
	
	  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	    var name = _arr3[_i3];
	    if (name[0] === ".") return;
	
	    var key = _path2["default"].basename(name, _path2["default"].extname(name));
	    var loc = _path2["default"].join(templatesLoc, name);
	    var code = _fs2["default"].readFileSync(loc, "utf8");
	
	    templates[key] = parseTemplate(loc, code);
	  }
	
	  return templates;
	}
	
	try {
	  exports.templates = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../../templates.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	} catch (err) {
	  if (err.code !== "MODULE_NOT_FOUND") throw err;
	  exports.templates = loadTemplates();
	}
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 251 */
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("module");

/***/ },
/* 252 */
/*!*****************************************!*\
  !*** ./~/babel-core/lib/babel/patch.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _estraverse = __webpack_require__(/*! estraverse */ 216);
	
	var _estraverse2 = _interopRequireDefault(_estraverse);
	
	var _lodashObjectExtend = __webpack_require__(/*! lodash/object/extend */ 138);
	
	var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
	
	var _astTypes = __webpack_require__(/*! ast-types */ 253);
	
	var _astTypes2 = _interopRequireDefault(_astTypes);
	
	var _types = __webpack_require__(/*! ./types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	// estraverse
	
	(0, _lodashObjectExtend2["default"])(_estraverse2["default"].VisitorKeys, t.VISITOR_KEYS);
	
	// regenerator/ast-types
	
	var def = _astTypes2["default"].Type.def;
	var or = _astTypes2["default"].Type.or;
	
	//def("File")
	//  .bases("Node")
	//  .build("program")
	//  .field("program", def("Program"));
	
	def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
	
	def("RestElement").bases("Pattern").build("argument").field("argument", def("expression"));
	
	def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
	
	def("Super").bases("Expression");
	
	def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression"), null));
	
	def("ExportNamedDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression"), null)).field("specifiers", [or(def("ExportSpecifier"))]).field("source", or(def("ModuleSpecifier"), null));
	
	def("ExportNamespaceSpecifier").bases("Specifier").field("exported", def("Identifier"));
	
	def("ExportDefaultSpecifier").bases("Specifier").field("exported", def("Identifier"));
	
	def("ExportAllDeclaration").bases("Declaration").build("exported", "source").field("exported", def("Identifier")).field("source", def("Literal"));
	
	def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
	
	_astTypes2["default"].finalize();

/***/ },
/* 253 */
/*!****************************!*\
  !*** external "ast-types" ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("ast-types");

/***/ },
/* 254 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/string/startsWith.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(/*! ../internal/baseToString */ 119);
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;
	
	/**
	 * Checks if `string` starts with the given target string.
	 *
	 * @static
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to search.
	 * @param {string} [target] The string to search for.
	 * @param {number} [position=0] The position to search from.
	 * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	 * @example
	 *
	 * _.startsWith('abc', 'a');
	 * // => true
	 *
	 * _.startsWith('abc', 'b');
	 * // => false
	 *
	 * _.startsWith('abc', 'b', 1);
	 * // => true
	 */
	function startsWith(string, target, position) {
	  string = baseToString(string);
	  position = position == null
	    ? 0
	    : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
	
	  return string.lastIndexOf(target, position) == position;
	}
	
	module.exports = startsWith;


/***/ },
/* 255 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/lodash/lang/cloneDeep.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseClone = __webpack_require__(/*! ../internal/baseClone */ 256),
	    bindCallback = __webpack_require__(/*! ../internal/bindCallback */ 134);
	
	/**
	 * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	 * to produce the cloned values. If `customizer` returns `undefined` cloning
	 * is handled by the method instead. The `customizer` is bound to `thisArg`
	 * and invoked with two argument; (value [, index|key, object]).
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	 * The enumerable properties of `arguments` objects and objects created by
	 * constructors other than `Object` are cloned to plain `Object` objects. An
	 * empty object is returned for uncloneable values such as functions, DOM nodes,
	 * Maps, Sets, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to deep clone.
	 * @param {Function} [customizer] The function to customize cloning values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {*} Returns the deep cloned value.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * var deep = _.cloneDeep(users);
	 * deep[0] === users[0];
	 * // => false
	 *
	 * // using a customizer callback
	 * var el = _.cloneDeep(document.body, function(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * });
	 *
	 * el === document.body
	 * // => false
	 * el.nodeName
	 * // => BODY
	 * el.childNodes.length;
	 * // => 20
	 */
	function cloneDeep(value, customizer, thisArg) {
	  return typeof customizer == 'function'
	    ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
	    : baseClone(value, true);
	}
	
	module.exports = cloneDeep;


/***/ },
/* 256 */
/*!*****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseClone.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arrayCopy = __webpack_require__(/*! ./arrayCopy */ 108),
	    arrayEach = __webpack_require__(/*! ./arrayEach */ 106),
	    baseAssign = __webpack_require__(/*! ./baseAssign */ 141),
	    baseForOwn = __webpack_require__(/*! ./baseForOwn */ 162),
	    initCloneArray = __webpack_require__(/*! ./initCloneArray */ 257),
	    initCloneByTag = __webpack_require__(/*! ./initCloneByTag */ 258),
	    initCloneObject = __webpack_require__(/*! ./initCloneObject */ 260),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isObject = __webpack_require__(/*! ../lang/isObject */ 105);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	cloneableTags[dateTag] = cloneableTags[float32Tag] =
	cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[stringTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[mapTag] = cloneableTags[setTag] =
	cloneableTags[weakMapTag] = false;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * The base implementation of `_.clone` without support for argument juggling
	 * and `this` binding `customizer` functions.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @param {Function} [customizer] The function to customize cloning values.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The object `value` belongs to.
	 * @param {Array} [stackA=[]] Tracks traversed source objects.
	 * @param {Array} [stackB=[]] Associates clones with source counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	  var result;
	  if (customizer) {
	    result = object ? customizer(value, key, object) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return arrayCopy(value, result);
	    }
	  } else {
	    var tag = objToString.call(value),
	        isFunc = tag == funcTag;
	
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = initCloneObject(isFunc ? {} : value);
	      if (!isDeep) {
	        return baseAssign(result, value);
	      }
	    } else {
	      return cloneableTags[tag]
	        ? initCloneByTag(value, tag, isDeep)
	        : (object ? value : {});
	    }
	  }
	  // Check for circular references and return corresponding clone.
	  stackA || (stackA = []);
	  stackB || (stackB = []);
	
	  var length = stackA.length;
	  while (length--) {
	    if (stackA[length] == value) {
	      return stackB[length];
	    }
	  }
	  // Add the source value to the stack of traversed objects and associate it with its clone.
	  stackA.push(value);
	  stackB.push(result);
	
	  // Recursively populate clone (susceptible to call stack limits).
	  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	  });
	  return result;
	}
	
	module.exports = baseClone;


/***/ },
/* 257 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/initCloneArray.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);
	
	  // Add array properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}
	
	module.exports = initCloneArray;


/***/ },
/* 258 */
/*!**********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/initCloneByTag.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var bufferClone = __webpack_require__(/*! ./bufferClone */ 259);
	
	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    stringTag = '[object String]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;
	
	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return bufferClone(object);
	
	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);
	
	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      var buffer = object.buffer;
	      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
	
	    case numberTag:
	    case stringTag:
	      return new Ctor(object);
	
	    case regexpTag:
	      var result = new Ctor(object.source, reFlags.exec(object));
	      result.lastIndex = object.lastIndex;
	  }
	  return result;
	}
	
	module.exports = initCloneByTag;


/***/ },
/* 259 */
/*!*******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/bufferClone.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(/*! ../utility/constant */ 191),
	    getNative = __webpack_require__(/*! ./getNative */ 116);
	
	/** Native method references. */
	var ArrayBuffer = getNative(global, 'ArrayBuffer'),
	    bufferSlice = getNative(ArrayBuffer && new ArrayBuffer(0), 'slice'),
	    floor = Math.floor,
	    Uint8Array = getNative(global, 'Uint8Array');
	
	/** Used to clone array buffers. */
	var Float64Array = (function() {
	  // Safari 5 errors when using an array buffer to initialize a typed array
	  // where the array buffer's `byteLength` is not a multiple of the typed
	  // array's `BYTES_PER_ELEMENT`.
	  try {
	    var func = getNative(global, 'Float64Array'),
	        result = new func(new ArrayBuffer(10), 0, 1) && func;
	  } catch(e) {}
	  return result || null;
	}());
	
	/** Used as the size, in bytes, of each `Float64Array` element. */
	var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
	
	/**
	 * Creates a clone of the given array buffer.
	 *
	 * @private
	 * @param {ArrayBuffer} buffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function bufferClone(buffer) {
	  return bufferSlice.call(buffer, 0);
	}
	if (!bufferSlice) {
	  // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
	  bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
	    var byteLength = buffer.byteLength,
	        floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
	        offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
	        result = new ArrayBuffer(byteLength);
	
	    if (floatLength) {
	      var view = new Float64Array(result, 0, floatLength);
	      view.set(new Float64Array(buffer, 0, floatLength));
	    }
	    if (byteLength != offset) {
	      view = new Uint8Array(result, offset);
	      view.set(new Uint8Array(buffer, offset));
	    }
	    return result;
	  };
	}
	
	module.exports = bufferClone;


/***/ },
/* 260 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/initCloneObject.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  var Ctor = object.constructor;
	  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	    Ctor = Object;
	  }
	  return new Ctor;
	}
	
	module.exports = initCloneObject;


/***/ },
/* 261 */
/*!****************************!*\
  !*** external "minimatch" ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("minimatch");

/***/ },
/* 262 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/contains.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./includes */ 145);


/***/ },
/* 263 */
/*!***********************************************!*\
  !*** ./~/babel-core/~/lodash/lang/isEmpty.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(/*! ./isArguments */ 109),
	    isArray = __webpack_require__(/*! ./isArray */ 115),
	    isArrayLike = __webpack_require__(/*! ../internal/isArrayLike */ 110),
	    isFunction = __webpack_require__(/*! ./isFunction */ 245),
	    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ 114),
	    isString = __webpack_require__(/*! ./isString */ 148),
	    keys = __webpack_require__(/*! ../object/keys */ 131);
	
	/**
	 * Checks if `value` is empty. A value is considered empty unless it is an
	 * `arguments` object, array, string, or jQuery-like collection with a length
	 * greater than `0` or an object with own enumerable properties.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {Array|Object|string} value The value to inspect.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
	      (isObjectLike(value) && isFunction(value.splice)))) {
	    return !value.length;
	  }
	  return !keys(value).length;
	}
	
	module.exports = isEmpty;


/***/ },
/* 264 */
/*!*********************************************!*\
  !*** ./~/babel-core/~/lodash/object/has.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(/*! ../internal/baseGet */ 179),
	    baseSlice = __webpack_require__(/*! ../internal/baseSlice */ 180),
	    isArguments = __webpack_require__(/*! ../lang/isArguments */ 109),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isIndex = __webpack_require__(/*! ../internal/isIndex */ 127),
	    isKey = __webpack_require__(/*! ../internal/isKey */ 181),
	    isLength = __webpack_require__(/*! ../internal/isLength */ 113),
	    last = __webpack_require__(/*! ../array/last */ 182),
	    toPath = __webpack_require__(/*! ../internal/toPath */ 183);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Checks if `path` is a direct property.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
	 * @example
	 *
	 * var object = { 'a': { 'b': { 'c': 3 } } };
	 *
	 * _.has(object, 'a');
	 * // => true
	 *
	 * _.has(object, 'a.b.c');
	 * // => true
	 *
	 * _.has(object, ['a', 'b', 'c']);
	 * // => true
	 */
	function has(object, path) {
	  if (object == null) {
	    return false;
	  }
	  var result = hasOwnProperty.call(object, path);
	  if (!result && !isKey(path)) {
	    path = toPath(path);
	    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	    if (object == null) {
	      return false;
	    }
	    path = last(path);
	    result = hasOwnProperty.call(object, path);
	  }
	  return result || (isLength(object.length) && isIndex(path, object.length) &&
	    (isArray(object) || isArguments(object)));
	}
	
	module.exports = has;


/***/ },
/* 265 */
/*!************************!*\
  !*** external "slash" ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("slash");

/***/ },
/* 266 */
/*!*****************************************!*\
  !*** ./~/babel-core/lib/babel ^\.\/.*$ ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./api/browser": 267,
		"./api/browser.js": 267,
		"./api/node": 142,
		"./api/node.js": 142,
		"./api/register/browser": 379,
		"./api/register/browser.js": 379,
		"./api/register/cache": 95,
		"./api/register/cache.js": 95,
		"./api/register/node": 93,
		"./api/register/node-polyfill": 3,
		"./api/register/node-polyfill.js": 3,
		"./api/register/node.js": 93,
		"./generation/buffer": 380,
		"./generation/buffer.js": 380,
		"./generation/generators/base": 382,
		"./generation/generators/base.js": 382,
		"./generation/generators/classes": 383,
		"./generation/generators/classes.js": 383,
		"./generation/generators/comprehensions": 384,
		"./generation/generators/comprehensions.js": 384,
		"./generation/generators/expressions": 385,
		"./generation/generators/expressions.js": 385,
		"./generation/generators/flow": 387,
		"./generation/generators/flow.js": 387,
		"./generation/generators/jsx": 388,
		"./generation/generators/jsx.js": 388,
		"./generation/generators/methods": 389,
		"./generation/generators/methods.js": 389,
		"./generation/generators/modules": 390,
		"./generation/generators/modules.js": 390,
		"./generation/generators/statements": 391,
		"./generation/generators/statements.js": 391,
		"./generation/generators/template-literals": 392,
		"./generation/generators/template-literals.js": 392,
		"./generation/generators/types": 393,
		"./generation/generators/types.js": 393,
		"./generation/index": 394,
		"./generation/index.js": 394,
		"./generation/node/index": 400,
		"./generation/node/index.js": 400,
		"./generation/node/parentheses": 402,
		"./generation/node/parentheses.js": 402,
		"./generation/node/whitespace": 401,
		"./generation/node/whitespace.js": 401,
		"./generation/position": 399,
		"./generation/position.js": 399,
		"./generation/source-map": 397,
		"./generation/source-map.js": 397,
		"./generation/whitespace": 396,
		"./generation/whitespace.js": 396,
		"./helpers/code-frame": 209,
		"./helpers/code-frame.js": 209,
		"./helpers/merge": 102,
		"./helpers/merge.js": 102,
		"./helpers/normalize-ast": 215,
		"./helpers/normalize-ast.js": 215,
		"./helpers/object": 197,
		"./helpers/object.js": 197,
		"./helpers/parse": 214,
		"./helpers/parse.js": 214,
		"./messages": 203,
		"./messages.js": 203,
		"./patch": 252,
		"./patch.js": 252,
		"./polyfill": 4,
		"./polyfill.js": 4,
		"./tools/build-external-helpers": 405,
		"./tools/build-external-helpers.js": 405,
		"./tools/resolve-rc": 100,
		"./tools/resolve-rc.js": 100,
		"./transformation/file/index": 247,
		"./transformation/file/index.js": 247,
		"./transformation/file/logger": 406,
		"./transformation/file/logger.js": 406,
		"./transformation/file/option-parsers": 249,
		"./transformation/file/option-parsers.js": 249,
		"./transformation/file/plugin-manager": 412,
		"./transformation/file/plugin-manager.js": 412,
		"./transformation/helpers/build-binary-assignment-operator-transformer": 308,
		"./transformation/helpers/build-binary-assignment-operator-transformer.js": 308,
		"./transformation/helpers/build-comprehension": 299,
		"./transformation/helpers/build-comprehension.js": 299,
		"./transformation/helpers/build-conditional-assignment-operator-transformer": 414,
		"./transformation/helpers/build-conditional-assignment-operator-transformer.js": 414,
		"./transformation/helpers/build-react-transformer": 344,
		"./transformation/helpers/build-react-transformer.js": 344,
		"./transformation/helpers/call-delegate": 331,
		"./transformation/helpers/call-delegate.js": 331,
		"./transformation/helpers/define-map": 290,
		"./transformation/helpers/define-map.js": 290,
		"./transformation/helpers/explode-assignable-expression": 309,
		"./transformation/helpers/explode-assignable-expression.js": 309,
		"./transformation/helpers/get-function-arity": 284,
		"./transformation/helpers/get-function-arity.js": 284,
		"./transformation/helpers/memoise-decorators": 289,
		"./transformation/helpers/memoise-decorators.js": 289,
		"./transformation/helpers/name-method": 283,
		"./transformation/helpers/name-method.js": 283,
		"./transformation/helpers/react": 207,
		"./transformation/helpers/react.js": 207,
		"./transformation/helpers/regex": 318,
		"./transformation/helpers/regex.js": 318,
		"./transformation/helpers/remap-async-to-generator": 303,
		"./transformation/helpers/remap-async-to-generator.js": 303,
		"./transformation/helpers/replace-supers": 301,
		"./transformation/helpers/replace-supers.js": 301,
		"./transformation/helpers/strict": 352,
		"./transformation/helpers/strict.js": 352,
		"./transformation/index": 268,
		"./transformation/index.js": 268,
		"./transformation/modules/_default": 415,
		"./transformation/modules/_default.js": 415,
		"./transformation/modules/_strict": 416,
		"./transformation/modules/_strict.js": 416,
		"./transformation/modules/amd": 417,
		"./transformation/modules/amd-strict": 419,
		"./transformation/modules/amd-strict.js": 419,
		"./transformation/modules/amd.js": 417,
		"./transformation/modules/common": 418,
		"./transformation/modules/common-strict": 420,
		"./transformation/modules/common-strict.js": 420,
		"./transformation/modules/common.js": 418,
		"./transformation/modules/ignore": 421,
		"./transformation/modules/ignore.js": 421,
		"./transformation/modules/index": 422,
		"./transformation/modules/index.js": 422,
		"./transformation/modules/system": 423,
		"./transformation/modules/system.js": 423,
		"./transformation/modules/umd": 425,
		"./transformation/modules/umd-strict": 424,
		"./transformation/modules/umd-strict.js": 424,
		"./transformation/modules/umd.js": 425,
		"./transformation/transformer": 143,
		"./transformation/transformer-pass": 144,
		"./transformation/transformer-pass.js": 144,
		"./transformation/transformer-pipeline": 269,
		"./transformation/transformer-pipeline.js": 269,
		"./transformation/transformer.js": 143,
		"./transformation/transformers/es3/member-expression-literals": 366,
		"./transformation/transformers/es3/member-expression-literals.js": 366,
		"./transformation/transformers/es3/property-literals": 365,
		"./transformation/transformers/es3/property-literals.js": 365,
		"./transformation/transformers/es5/properties.mutators": 312,
		"./transformation/transformers/es5/properties.mutators.js": 312,
		"./transformation/transformers/es6/arrow-functions": 294,
		"./transformation/transformers/es6/arrow-functions.js": 294,
		"./transformation/transformers/es6/block-scoping": 341,
		"./transformation/transformers/es6/block-scoping.js": 341,
		"./transformation/transformers/es6/classes": 300,
		"./transformation/transformers/es6/classes.js": 300,
		"./transformation/transformers/es6/constants": 327,
		"./transformation/transformers/es6/constants.js": 327,
		"./transformation/transformers/es6/destructuring": 340,
		"./transformation/transformers/es6/destructuring.js": 340,
		"./transformation/transformers/es6/for-of": 316,
		"./transformation/transformers/es6/for-of.js": 316,
		"./transformation/transformers/es6/modules": 350,
		"./transformation/transformers/es6/modules.js": 350,
		"./transformation/transformers/es6/object-super": 305,
		"./transformation/transformers/es6/object-super.js": 305,
		"./transformation/transformers/es6/parameters.default": 330,
		"./transformation/transformers/es6/parameters.default.js": 330,
		"./transformation/transformers/es6/parameters.rest": 328,
		"./transformation/transformers/es6/parameters.rest.js": 328,
		"./transformation/transformers/es6/properties.computed": 314,
		"./transformation/transformers/es6/properties.computed.js": 314,
		"./transformation/transformers/es6/properties.shorthand": 313,
		"./transformation/transformers/es6/properties.shorthand.js": 313,
		"./transformation/transformers/es6/regex.sticky": 317,
		"./transformation/transformers/es6/regex.sticky.js": 317,
		"./transformation/transformers/es6/regex.unicode": 320,
		"./transformation/transformers/es6/regex.unicode.js": 320,
		"./transformation/transformers/es6/spec.block-scoping": 342,
		"./transformation/transformers/es6/spec.block-scoping.js": 342,
		"./transformation/transformers/es6/spec.symbols": 335,
		"./transformation/transformers/es6/spec.symbols.js": 335,
		"./transformation/transformers/es6/spec.template-literals": 310,
		"./transformation/transformers/es6/spec.template-literals.js": 310,
		"./transformation/transformers/es6/spread": 329,
		"./transformation/transformers/es6/spread.js": 329,
		"./transformation/transformers/es6/tail-call": 353,
		"./transformation/transformers/es6/tail-call.js": 353,
		"./transformation/transformers/es6/template-literals": 311,
		"./transformation/transformers/es6/template-literals.js": 311,
		"./transformation/transformers/es7/async-functions": 287,
		"./transformation/transformers/es7/async-functions.js": 287,
		"./transformation/transformers/es7/class-properties": 285,
		"./transformation/transformers/es7/class-properties.js": 285,
		"./transformation/transformers/es7/comprehensions": 298,
		"./transformation/transformers/es7/comprehensions.js": 298,
		"./transformation/transformers/es7/decorators": 288,
		"./transformation/transformers/es7/decorators.js": 288,
		"./transformation/transformers/es7/do-expressions": 334,
		"./transformation/transformers/es7/do-expressions.js": 334,
		"./transformation/transformers/es7/exponentiation-operator": 307,
		"./transformation/transformers/es7/exponentiation-operator.js": 307,
		"./transformation/transformers/es7/export-extensions": 332,
		"./transformation/transformers/es7/export-extensions.js": 332,
		"./transformation/transformers/es7/function-bind": 336,
		"./transformation/transformers/es7/function-bind.js": 336,
		"./transformation/transformers/es7/object-rest-spread": 306,
		"./transformation/transformers/es7/object-rest-spread.js": 306,
		"./transformation/transformers/es7/trailing-function-commas": 286,
		"./transformation/transformers/es7/trailing-function-commas.js": 286,
		"./transformation/transformers/filters": 376,
		"./transformation/transformers/filters.js": 376,
		"./transformation/transformers/index": 270,
		"./transformation/transformers/index.js": 270,
		"./transformation/transformers/internal/block-hoist": 369,
		"./transformation/transformers/internal/block-hoist.js": 369,
		"./transformation/transformers/internal/explode": 272,
		"./transformation/transformers/internal/explode.js": 272,
		"./transformation/transformers/internal/hoist-directives": 275,
		"./transformation/transformers/internal/hoist-directives.js": 275,
		"./transformation/transformers/internal/module-formatter": 351,
		"./transformation/transformers/internal/module-formatter.js": 351,
		"./transformation/transformers/internal/modules": 281,
		"./transformation/transformers/internal/modules.js": 281,
		"./transformation/transformers/internal/shadow-functions": 364,
		"./transformation/transformers/internal/shadow-functions.js": 364,
		"./transformation/transformers/internal/validation": 274,
		"./transformation/transformers/internal/validation.js": 274,
		"./transformation/transformers/minification/dead-code-elimination": 280,
		"./transformation/transformers/minification/dead-code-elimination.js": 280,
		"./transformation/transformers/minification/inline-expressions": 279,
		"./transformation/transformers/minification/inline-expressions.js": 279,
		"./transformation/transformers/minification/member-expression-literals": 367,
		"./transformation/transformers/minification/member-expression-literals.js": 367,
		"./transformation/transformers/minification/property-literals": 368,
		"./transformation/transformers/minification/property-literals.js": 368,
		"./transformation/transformers/minification/remove-console": 277,
		"./transformation/transformers/minification/remove-console.js": 277,
		"./transformation/transformers/minification/remove-debugger": 276,
		"./transformation/transformers/minification/remove-debugger.js": 276,
		"./transformation/transformers/optimisation/flow.for-of": 315,
		"./transformation/transformers/optimisation/flow.for-of.js": 315,
		"./transformation/transformers/optimisation/react.constant-elements": 296,
		"./transformation/transformers/optimisation/react.constant-elements.js": 296,
		"./transformation/transformers/optimisation/react.inline-elements": 297,
		"./transformation/transformers/optimisation/react.inline-elements.js": 297,
		"./transformation/transformers/other/async-to-generator": 302,
		"./transformation/transformers/other/async-to-generator.js": 302,
		"./transformation/transformers/other/bluebird-coroutines": 304,
		"./transformation/transformers/other/bluebird-coroutines.js": 304,
		"./transformation/transformers/other/flow": 339,
		"./transformation/transformers/other/flow.js": 339,
		"./transformation/transformers/other/jscript": 338,
		"./transformation/transformers/other/jscript.js": 338,
		"./transformation/transformers/other/react": 345,
		"./transformation/transformers/other/react-compat": 343,
		"./transformation/transformers/other/react-compat.js": 343,
		"./transformation/transformers/other/react.js": 345,
		"./transformation/transformers/other/regenerator": 346,
		"./transformation/transformers/other/regenerator.js": 346,
		"./transformation/transformers/other/runtime/index": 348,
		"./transformation/transformers/other/runtime/index.js": 348,
		"./transformation/transformers/other/strict": 271,
		"./transformation/transformers/other/strict.js": 271,
		"./transformation/transformers/spec/block-scoped-functions": 295,
		"./transformation/transformers/spec/block-scoped-functions.js": 295,
		"./transformation/transformers/spec/function-name": 282,
		"./transformation/transformers/spec/function-name.js": 282,
		"./transformation/transformers/spec/proto-to-assign": 333,
		"./transformation/transformers/spec/proto-to-assign.js": 333,
		"./transformation/transformers/spec/undefined-to-void": 337,
		"./transformation/transformers/spec/undefined-to-void.js": 337,
		"./transformation/transformers/utility/inline-environment-variables": 278,
		"./transformation/transformers/utility/inline-environment-variables.js": 278,
		"./transformation/transformers/validation/react": 293,
		"./transformation/transformers/validation/react.js": 293,
		"./transformation/transformers/validation/undeclared-variable-check": 291,
		"./transformation/transformers/validation/undeclared-variable-check.js": 291,
		"./traversal/context": 152,
		"./traversal/context.js": 152,
		"./traversal/index": 151,
		"./traversal/index.js": 151,
		"./traversal/path/conversion": 244,
		"./traversal/path/conversion.js": 244,
		"./traversal/path/evaluation": 243,
		"./traversal/path/evaluation.js": 243,
		"./traversal/path/hoister": 206,
		"./traversal/path/hoister.js": 206,
		"./traversal/path/index": 153,
		"./traversal/path/index.js": 153,
		"./traversal/path/virtual-types": 155,
		"./traversal/path/virtual-types.js": 155,
		"./traversal/scope/binding": 240,
		"./traversal/scope/binding.js": 240,
		"./traversal/scope/index": 236,
		"./traversal/scope/index.js": 236,
		"./traversal/visitors": 154,
		"./traversal/visitors.js": 154,
		"./types/converters": 200,
		"./types/converters.js": 200,
		"./types/index": 156,
		"./types/index.js": 156,
		"./types/retrievers": 196,
		"./types/retrievers.js": 196,
		"./types/validators": 198,
		"./types/validators.js": 198,
		"./util": 250,
		"./util.js": 250
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 266;


/***/ },
/* 267 */
/*!***********************************************!*\
  !*** ./~/babel-core/lib/babel/api/browser.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	__webpack_require__(/*! ./node */ 142);
	var transform = module.exports = __webpack_require__(/*! ../transformation */ 268);
	
	transform.options = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../transformation/file/options\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	transform.version = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../../../package\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
	
	transform.transform = transform;
	
	transform.run = function (code) {
	  var opts = arguments[1] === undefined ? {} : arguments[1];
	
	  opts.sourceMaps = "inline";
	  return new Function(transform(code, opts).code)();
	};
	
	transform.load = function (url, callback, _x2, hold) {
	  var opts = arguments[2] === undefined ? {} : arguments[2];
	
	  opts.filename = opts.filename || url;
	
	  var xhr = global.ActiveXObject ? new global.ActiveXObject("Microsoft.XMLHTTP") : new global.XMLHttpRequest();
	  xhr.open("GET", url, true);
	  if ("overrideMimeType" in xhr) xhr.overrideMimeType("text/plain");
	
	  xhr.onreadystatechange = function () {
	    if (xhr.readyState !== 4) return;
	
	    var status = xhr.status;
	    if (status === 0 || status === 200) {
	      var param = [xhr.responseText, opts];
	      if (!hold) transform.run.apply(transform, param);
	      if (callback) callback(param);
	    } else {
	      throw new Error("Could not load " + url);
	    }
	  };
	
	  xhr.send(null);
	};
	
	var runScripts = function runScripts() {
	  var scripts = [];
	  var types = ["text/ecmascript-6", "text/6to5", "text/babel", "module"];
	  var index = 0;
	
	  var exec = function exec() {
	    var param = scripts[index];
	    if (param instanceof Array) {
	      transform.run.apply(transform, param);
	      index++;
	      exec();
	    }
	  };
	
	  var run = function run(script, i) {
	    var opts = {};
	
	    if (script.src) {
	      transform.load(script.src, function (param) {
	        scripts[i] = param;
	        exec();
	      }, opts, true);
	    } else {
	      opts.filename = "embedded";
	      scripts[i] = [script.innerHTML, opts];
	    }
	  };
	
	  var _scripts = global.document.getElementsByTagName("script");
	
	  for (var i = 0; i < _scripts.length; ++i) {
	    var _script = _scripts[i];
	    if (types.indexOf(_script.type) >= 0) scripts.push(_script);
	  }
	
	  for (i in scripts) {
	    run(scripts[i], i);
	  }
	
	  exec();
	};
	
	if (global.addEventListener) {
	  global.addEventListener("DOMContentLoaded", runScripts, false);
	} else if (global.attachEvent) {
	  global.attachEvent("onload", runScripts);
	}

/***/ },
/* 268 */
/*!********************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/index.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _transformerPipeline = __webpack_require__(/*! ./transformer-pipeline */ 269);
	
	var _transformerPipeline2 = _interopRequireDefault(_transformerPipeline);
	
	//
	
	var _transformers = __webpack_require__(/*! ./transformers */ 270);
	
	var _transformers2 = _interopRequireDefault(_transformers);
	
	//
	
	var _transformersDeprecated = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./transformers/deprecated\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	var _transformersDeprecated2 = _interopRequireDefault(_transformersDeprecated);
	
	//
	
	var _transformersAliases = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./transformers/aliases\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	var _transformersAliases2 = _interopRequireDefault(_transformersAliases);
	
	//
	
	var _transformersFilters = __webpack_require__(/*! ./transformers/filters */ 376);
	
	var filters = _interopRequireWildcard(_transformersFilters);
	
	var pipeline = new _transformerPipeline2["default"]();
	
	for (var key in _transformers2["default"]) {
	  var transformer = _transformers2["default"][key];
	  var metadata = transformer.metadata = transformer.metadata || {};
	  metadata.group = metadata.group || "builtin-basic";
	}
	
	pipeline.addTransformers(_transformers2["default"]);
	pipeline.addDeprecated(_transformersDeprecated2["default"]);
	pipeline.addAliases(_transformersAliases2["default"]);
	pipeline.addFilter(filters.internal);
	pipeline.addFilter(filters.blacklist);
	pipeline.addFilter(filters.whitelist);
	pipeline.addFilter(filters.stage);
	pipeline.addFilter(filters.optional);
	
	//
	
	var transform = pipeline.transform.bind(pipeline);
	transform.fromAst = pipeline.transformFromAst.bind(pipeline);
	transform.pipeline = pipeline;
	exports["default"] = transform;
	module.exports = exports["default"];

/***/ },
/* 269 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformer-pipeline.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _transformer = __webpack_require__(/*! ./transformer */ 143);
	
	var _transformer2 = _interopRequireDefault(_transformer);
	
	var _helpersNormalizeAst = __webpack_require__(/*! ../helpers/normalize-ast */ 215);
	
	var _helpersNormalizeAst2 = _interopRequireDefault(_helpersNormalizeAst);
	
	var _lodashObjectAssign = __webpack_require__(/*! lodash/object/assign */ 139);
	
	var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);
	
	var _helpersObject = __webpack_require__(/*! ../helpers/object */ 197);
	
	var _helpersObject2 = _interopRequireDefault(_helpersObject);
	
	var _file = __webpack_require__(/*! ./file */ 247);
	
	var _file2 = _interopRequireDefault(_file);
	
	var TransformerPipeline = (function () {
	  function TransformerPipeline() {
	    _classCallCheck(this, TransformerPipeline);
	
	    this.transformers = (0, _helpersObject2["default"])();
	    this.namespaces = (0, _helpersObject2["default"])();
	    this.deprecated = (0, _helpersObject2["default"])();
	    this.aliases = (0, _helpersObject2["default"])();
	    this.filters = [];
	  }
	
	  TransformerPipeline.prototype.addTransformers = function addTransformers(transformers) {
	    for (var key in transformers) {
	      this.addTransformer(key, transformers[key]);
	    }
	    return this;
	  };
	
	  TransformerPipeline.prototype.addTransformer = function addTransformer(key, transformer) {
	    if (this.transformers[key]) throw new Error(); // todo: error
	
	    var namespace = key.split(".")[0];
	    this.namespaces[namespace] = this.namespaces[namespace] || [];
	    this.namespaces[namespace].push(key);
	    this.namespaces[key] = namespace;
	
	    this.transformers[key] = new _transformer2["default"](key, transformer);
	  };
	
	  TransformerPipeline.prototype.addAliases = function addAliases(names) {
	    (0, _lodashObjectAssign2["default"])(this.aliases, names);
	    return this;
	  };
	
	  TransformerPipeline.prototype.addDeprecated = function addDeprecated(names) {
	    (0, _lodashObjectAssign2["default"])(this.deprecated, names);
	    return this;
	  };
	
	  TransformerPipeline.prototype.addFilter = function addFilter(filter) {
	    this.filters.push(filter);
	    return this;
	  };
	
	  TransformerPipeline.prototype.canTransform = function canTransform(transformer, fileOpts) {
	    if (transformer.metadata.plugin) return true;
	
	    var _arr = this.filters;
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var filter = _arr[_i];
	      var result = filter(transformer, fileOpts);
	      if (result != null) return result;
	    }
	
	    return true;
	  };
	
	  TransformerPipeline.prototype.transform = function transform(code, opts) {
	    var file = new _file2["default"](opts, this);
	    return file.wrap(code, function () {
	      file.addCode(code, true);
	    });
	  };
	
	  TransformerPipeline.prototype.transformFromAst = function transformFromAst(ast, code, opts) {
	    ast = (0, _helpersNormalizeAst2["default"])(ast);
	
	    var file = new _file2["default"](opts, this);
	    return file.wrap(code, function () {
	      file.addCode(code);
	      file.addAst(ast);
	    });
	  };
	
	  TransformerPipeline.prototype._ensureTransformerNames = function _ensureTransformerNames(type, rawKeys) {
	    var keys = [];
	
	    for (var i = 0; i < rawKeys.length; i++) {
	      var key = rawKeys[i];
	
	      var deprecatedKey = this.deprecated[key];
	      var aliasKey = this.aliases[key];
	      if (aliasKey) {
	        keys.push(aliasKey);
	      } else if (deprecatedKey) {
	        // deprecated key, remap it to the new one
	        console.error("[BABEL] The transformer " + key + " has been renamed to " + deprecatedKey);
	        rawKeys.push(deprecatedKey);
	      } else if (this.transformers[key]) {
	        // valid key
	        keys.push(key);
	      } else if (this.namespaces[key]) {
	        // namespace, append all transformers within this namespace
	        keys = keys.concat(this.namespaces[key]);
	      } else {
	        // invalid key
	        throw new ReferenceError("Unknown transformer " + key + " specified in " + type);
	      }
	    }
	
	    return keys;
	  };
	
	  return TransformerPipeline;
	})();
	
	exports["default"] = TransformerPipeline;
	module.exports = exports["default"];

/***/ },
/* 270 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/index.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = {
	  //- builtin-setup
	  strict: __webpack_require__(/*! ./other/strict */ 271),
	  _explode: __webpack_require__(/*! ./internal/explode */ 272),
	  _validation: __webpack_require__(/*! ./internal/validation */ 274),
	  _hoistDirectives: __webpack_require__(/*! ./internal/hoist-directives */ 275),
	  "minification.removeDebugger": __webpack_require__(/*! ./minification/remove-debugger */ 276),
	  "minification.removeConsole": __webpack_require__(/*! ./minification/remove-console */ 277),
	  "utility.inlineEnvironmentVariables": __webpack_require__(/*! ./utility/inline-environment-variables */ 278),
	  "minification.inlineExpressions": __webpack_require__(/*! ./minification/inline-expressions */ 279),
	  "minification.deadCodeElimination": __webpack_require__(/*! ./minification/dead-code-elimination */ 280),
	  _modules: __webpack_require__(/*! ./internal/modules */ 281),
	  "spec.functionName": __webpack_require__(/*! ./spec/function-name */ 282),
	
	  //- builtin-basic
	  // this is where the bulk of the ES6 transformations take place, none of them require traversal state
	  // so they can all be concatenated together for performance
	  "es7.classProperties": __webpack_require__(/*! ./es7/class-properties */ 285),
	  "es7.trailingFunctionCommas": __webpack_require__(/*! ./es7/trailing-function-commas */ 286),
	  "es7.asyncFunctions": __webpack_require__(/*! ./es7/async-functions */ 287),
	  "es7.decorators": __webpack_require__(/*! ./es7/decorators */ 288),
	  "validation.undeclaredVariableCheck": __webpack_require__(/*! ./validation/undeclared-variable-check */ 291),
	  "validation.react": __webpack_require__(/*! ./validation/react */ 293),
	  "es6.arrowFunctions": __webpack_require__(/*! ./es6/arrow-functions */ 294),
	  "spec.blockScopedFunctions": __webpack_require__(/*! ./spec/block-scoped-functions */ 295),
	  "optimisation.react.constantElements": __webpack_require__(/*! ./optimisation/react.constant-elements */ 296),
	  "optimisation.react.inlineElements": __webpack_require__(/*! ./optimisation/react.inline-elements */ 297),
	  "es7.comprehensions": __webpack_require__(/*! ./es7/comprehensions */ 298),
	  "es6.classes": __webpack_require__(/*! ./es6/classes */ 300),
	  asyncToGenerator: __webpack_require__(/*! ./other/async-to-generator */ 302),
	  bluebirdCoroutines: __webpack_require__(/*! ./other/bluebird-coroutines */ 304),
	  "es6.objectSuper": __webpack_require__(/*! ./es6/object-super */ 305),
	  "es7.objectRestSpread": __webpack_require__(/*! ./es7/object-rest-spread */ 306),
	  "es7.exponentiationOperator": __webpack_require__(/*! ./es7/exponentiation-operator */ 307),
	  "es6.spec.templateLiterals": __webpack_require__(/*! ./es6/spec.template-literals */ 310),
	  "es6.templateLiterals": __webpack_require__(/*! ./es6/template-literals */ 311),
	  "es5.properties.mutators": __webpack_require__(/*! ./es5/properties.mutators */ 312),
	  "es6.properties.shorthand": __webpack_require__(/*! ./es6/properties.shorthand */ 313),
	  "es6.properties.computed": __webpack_require__(/*! ./es6/properties.computed */ 314),
	  "optimisation.flow.forOf": __webpack_require__(/*! ./optimisation/flow.for-of */ 315),
	  "es6.forOf": __webpack_require__(/*! ./es6/for-of */ 316),
	  "es6.regex.sticky": __webpack_require__(/*! ./es6/regex.sticky */ 317),
	  "es6.regex.unicode": __webpack_require__(/*! ./es6/regex.unicode */ 320),
	  "es6.constants": __webpack_require__(/*! ./es6/constants */ 327),
	  "es6.parameters.rest": __webpack_require__(/*! ./es6/parameters.rest */ 328),
	  "es6.spread": __webpack_require__(/*! ./es6/spread */ 329),
	  "es6.parameters.default": __webpack_require__(/*! ./es6/parameters.default */ 330),
	  "es7.exportExtensions": __webpack_require__(/*! ./es7/export-extensions */ 332),
	  "spec.protoToAssign": __webpack_require__(/*! ./spec/proto-to-assign */ 333),
	  "es7.doExpressions": __webpack_require__(/*! ./es7/do-expressions */ 334),
	  "es6.spec.symbols": __webpack_require__(/*! ./es6/spec.symbols */ 335),
	  "es7.functionBind": __webpack_require__(/*! ./es7/function-bind */ 336),
	  "spec.undefinedToVoid": __webpack_require__(/*! ./spec/undefined-to-void */ 337),
	  jscript: __webpack_require__(/*! ./other/jscript */ 338),
	  flow: __webpack_require__(/*! ./other/flow */ 339),
	
	  //- builtin-advanced
	  "es6.destructuring": __webpack_require__(/*! ./es6/destructuring */ 340),
	  "es6.blockScoping": __webpack_require__(/*! ./es6/block-scoping */ 341),
	  "es6.spec.blockScoping": __webpack_require__(/*! ./es6/spec.block-scoping */ 342),
	  reactCompat: __webpack_require__(/*! ./other/react-compat */ 343),
	  react: __webpack_require__(/*! ./other/react */ 345),
	
	  // es6 syntax transformation is **forbidden** past this point since regenerator will chuck a massive
	  // hissy fit
	
	  //- regenerator
	  regenerator: __webpack_require__(/*! ./other/regenerator */ 346),
	
	  //- builtin-modules
	  runtime: __webpack_require__(/*! ./other/runtime */ 348),
	  "es6.modules": __webpack_require__(/*! ./es6/modules */ 350),
	  _moduleFormatter: __webpack_require__(/*! ./internal/module-formatter */ 351),
	
	  //- builtin-trailing
	  // these clean up the output and do finishing up transformations, it's important to note that by this
	  // stage you can't import any new modules or insert new ES6 as all those transformers have already
	  // been ran
	  "es6.tailCall": __webpack_require__(/*! ./es6/tail-call */ 353),
	  _shadowFunctions: __webpack_require__(/*! ./internal/shadow-functions */ 364),
	  "es3.propertyLiterals": __webpack_require__(/*! ./es3/property-literals */ 365),
	  "es3.memberExpressionLiterals": __webpack_require__(/*! ./es3/member-expression-literals */ 366),
	  "minification.memberExpressionLiterals": __webpack_require__(/*! ./minification/member-expression-literals */ 367),
	  "minification.propertyLiterals": __webpack_require__(/*! ./minification/property-literals */ 368),
	  _blockHoist: __webpack_require__(/*! ./internal/block-hoist */ 369) };
	module.exports = exports["default"];

/***/ },
/* 271 */
/*!****************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/strict.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ThisExpression = ThisExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	var THIS_BREAK_KEYS = ["FunctionExpression", "FunctionDeclaration", "ClassExpression", "ClassDeclaration"];
	
	var Program = {
	  enter: function enter(program, parent, scope, file) {
	    var first = program.body[0];
	
	    var directive;
	    if (t.isExpressionStatement(first) && t.isLiteral(first.expression, { value: "use strict" })) {
	      directive = first;
	    } else {
	      directive = t.expressionStatement(t.literal("use strict"));
	      this.unshiftContainer("body", directive);
	      if (first) {
	        directive.leadingComments = first.leadingComments;
	        first.leadingComments = [];
	      }
	    }
	    directive._blockHoist = Infinity;
	  }
	};
	
	exports.Program = Program;
	
	function ThisExpression() {
	  if (!this.findParent(function (node) {
	    return !node.shadow && THIS_BREAK_KEYS.indexOf(node.type) >= 0;
	  })) {
	    return t.identifier("undefined");
	  }
	}

/***/ },
/* 272 */
/*!********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/internal/explode.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangClone = __webpack_require__(/*! lodash/lang/clone */ 273);
	
	var _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	function buildClone(bindingKey, refKey, check) {
	  return function (node) {
	    if (node[bindingKey] === node[refKey] || check && check(node)) {
	      node[refKey] = t.removeComments((0, _lodashLangClone2["default"])(node[refKey]));
	    }
	  };
	}
	
	function buildListClone(listKey, bindingKey, refKey) {
	  var clone = buildClone(bindingKey, refKey);
	
	  return function (node) {
	    if (!node[listKey]) return;
	
	    var _arr = node[listKey];
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var subNode = _arr[_i];
	      clone(subNode);
	    }
	  };
	}
	
	var Property = buildClone("value", "key", function (node) {
	  return t.isAssignmentPattern(node.value) && node.value.left === node.key;
	});
	
	exports.Property = Property;
	var ExportDeclaration = buildListClone("specifiers", "local", "exported");
	exports.ExportDeclaration = ExportDeclaration;
	var ImportDeclaration = buildListClone("specifiers", "local", "imported");
	exports.ImportDeclaration = ImportDeclaration;

/***/ },
/* 273 */
/*!*********************************************!*\
  !*** ./~/babel-core/~/lodash/lang/clone.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseClone = __webpack_require__(/*! ../internal/baseClone */ 256),
	    bindCallback = __webpack_require__(/*! ../internal/bindCallback */ 134),
	    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ 136);
	
	/**
	 * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	 * otherwise they are assigned by reference. If `customizer` is provided it is
	 * invoked to produce the cloned values. If `customizer` returns `undefined`
	 * cloning is handled by the method instead. The `customizer` is bound to
	 * `thisArg` and invoked with two argument; (value [, index|key, object]).
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	 * The enumerable properties of `arguments` objects and objects created by
	 * constructors other than `Object` are cloned to plain `Object` objects. An
	 * empty object is returned for uncloneable values such as functions, DOM nodes,
	 * Maps, Sets, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @param {Function} [customizer] The function to customize cloning values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {*} Returns the cloned value.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * var shallow = _.clone(users);
	 * shallow[0] === users[0];
	 * // => true
	 *
	 * var deep = _.clone(users, true);
	 * deep[0] === users[0];
	 * // => false
	 *
	 * // using a customizer callback
	 * var el = _.clone(document.body, function(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(false);
	 *   }
	 * });
	 *
	 * el === document.body
	 * // => false
	 * el.nodeName
	 * // => BODY
	 * el.childNodes.length;
	 * // => 0
	 */
	function clone(value, isDeep, customizer, thisArg) {
	  if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
	    isDeep = false;
	  }
	  else if (typeof isDeep == 'function') {
	    thisArg = customizer;
	    customizer = isDeep;
	    isDeep = false;
	  }
	  return typeof customizer == 'function'
	    ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
	    : baseClone(value, isDeep);
	}
	
	module.exports = clone;


/***/ },
/* 274 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/internal/validation.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ForOfStatement = ForOfStatement;
	exports.MethodDefinition = MethodDefinition;
	exports.Property = Property;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	
	function ForOfStatement(node, parent, scope, file) {
	  var left = node.left;
	  if (t.isVariableDeclaration(left)) {
	    var declar = left.declarations[0];
	    if (declar.init) throw file.errorWithNode(declar, messages.get("noAssignmentsInForHead"));
	  }
	}
	
	exports.ForInStatement = ForOfStatement;
	
	function MethodDefinition(node) {
	  if (node.kind !== "constructor") {
	    // get constructor() {}
	    var isConstructor = !node.computed && t.isIdentifier(node.key, { name: "constructor" });
	
	    // get ["constructor"]() {}
	    isConstructor = isConstructor || t.isLiteral(node.key, { value: "constructor" });
	
	    if (isConstructor) {
	      throw this.errorWithNode(messages.get("classesIllegalConstructorKind"));
	    }
	  }
	
	  Property.apply(this, arguments);
	}
	
	function Property(node, parent, scope, file) {
	  if (node.kind === "set") {
	    if (node.value.params.length !== 1) {
	      throw file.errorWithNode(node.value, messages.get("settersInvalidParamLength"));
	    }
	
	    var first = node.value.params[0];
	    if (t.isRestElement(first)) {
	      throw file.errorWithNode(first, messages.get("settersNoRest"));
	    }
	  }
	}

/***/ },
/* 275 */
/*!*****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/internal/hoist-directives.js ***!
  \*****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	var BlockStatement = {
	  exit: function exit(node) {
	    for (var i = 0; i < node.body.length; i++) {
	      var bodyNode = node.body[i];
	      if (t.isExpressionStatement(bodyNode) && t.isLiteral(bodyNode.expression)) {
	        bodyNode._blockHoist = Infinity;
	      } else {
	        return;
	      }
	    }
	  }
	};
	
	exports.BlockStatement = BlockStatement;
	exports.Program = BlockStatement;

/***/ },
/* 276 */
/*!********************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/minification/remove-debugger.js ***!
  \********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ExpressionStatement = ExpressionStatement;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	
	function ExpressionStatement(node) {
	  if (this.get("expression").isIdentifier({ name: "debugger" })) {
	    this.remove();
	  }
	}

/***/ },
/* 277 */
/*!*******************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/minification/remove-console.js ***!
  \*******************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.CallExpression = CallExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	
	function CallExpression(node, parent) {
	  if (this.get("callee").matchesPattern("console", true)) {
	    if (t.isExpressionStatement(parent)) {
	      this.parentPath.remove();
	    } else {
	      this.remove();
	    }
	  }
	}

/***/ },
/* 278 */
/*!****************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/utility/inline-environment-variables.js ***!
  \****************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.MemberExpression = MemberExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	var match = t.buildMatchMemberExpression("process.env");
	
	function MemberExpression(node) {
	  if (match(node.object)) {
	    var key = this.toComputedKey();
	    if (t.isLiteral(key)) {
	      return t.valueToNode(process.env[key.value]);
	    }
	  }
	}

/***/ },
/* 279 */
/*!***********************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/minification/inline-expressions.js ***!
  \***********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Identifier = Identifier;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	var Expression = {
	  exit: function exit(node, parent, scope) {
	    var res = this.evaluate();
	    if (res.confident) return t.valueToNode(res.value);
	  }
	};
	
	exports.Expression = Expression;
	
	function Identifier() {}
	
	// override Expression

/***/ },
/* 280 */
/*!**************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/minification/dead-code-elimination.js ***!
  \**************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ReferencedIdentifier = ReferencedIdentifier;
	exports.FunctionDeclaration = FunctionDeclaration;
	exports.VariableDeclarator = VariableDeclarator;
	exports.ConditionalExpression = ConditionalExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function toStatements(node) {
	  if (t.isBlockStatement(node)) {
	    var hasBlockScoped = false;
	
	    for (var i = 0; i < node.body.length; i++) {
	      var bodyNode = node.body[i];
	      if (t.isBlockScoped(bodyNode)) hasBlockScoped = true;
	    }
	
	    if (!hasBlockScoped) {
	      return node.body;
	    }
	  }
	
	  return node;
	}
	
	var metadata = {
	  optional: true,
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	
	function ReferencedIdentifier(node, parent, scope) {
	  var binding = scope.getBinding(node.name);
	  if (!binding || binding.references > 1 || !binding.constant) return;
	  if (binding.kind === "param" || binding.kind === "module") return;
	
	  var replacement = binding.path.node;
	  if (t.isVariableDeclarator(replacement)) {
	    replacement = replacement.init;
	  }
	  if (!replacement) return;
	
	  if (this.findParent(function (node) {
	    return replacement;
	  })) {
	    return;
	  }
	
	  t.toExpression(replacement);
	  scope.removeBinding(node.name);
	  binding.path.remove();
	  return replacement;
	}
	
	function FunctionDeclaration(node, parent, scope) {
	  var bindingInfo = scope.getBinding(node.id.name);
	  if (bindingInfo && !bindingInfo.referenced) {
	    this.remove();
	  }
	}
	
	exports.ClassDeclaration = FunctionDeclaration;
	
	function VariableDeclarator(node, parent, scope) {
	  if (!t.isIdentifier(node.id) || !scope.isPure(node.init)) return;
	  FunctionDeclaration.apply(this, arguments);
	}
	
	function ConditionalExpression(node, parent, scope) {
	  var evaluateTest = this.get("test").evaluateTruthy();
	  if (evaluateTest === true) {
	    return node.consequent;
	  } else if (evaluateTest === false) {
	    return node.alternate;
	  }
	}
	
	var IfStatement = {
	  exit: function exit(node, parent, scope) {
	    var consequent = node.consequent;
	    var alternate = node.alternate;
	    var test = node.test;
	
	    var evaluateTest = this.get("test").evaluateTruthy();
	
	    // we can check if a test will be truthy 100% and if so then we can inline
	    // the consequent and completely ignore the alternate
	    //
	    //   if (true) { foo; } -> { foo; }
	    //   if ("foo") { foo; } -> { foo; }
	    //
	
	    if (evaluateTest === true) {
	      return toStatements(consequent);
	    }
	
	    // we can check if a test will be falsy 100% and if so we can inline the
	    // alternate if there is one and completely remove the consequent
	    //
	    //   if ("") { bar; } else { foo; } -> { foo; }
	    //   if ("") { bar; } ->
	    //
	
	    if (evaluateTest === false) {
	      if (alternate) {
	        return toStatements(alternate);
	      } else {
	        return this.remove();
	      }
	    }
	
	    // remove alternate blocks that are empty
	    //
	    //   if (foo) { foo; } else {} -> if (foo) { foo; }
	    //
	
	    if (t.isBlockStatement(alternate) && !alternate.body.length) {
	      alternate = node.alternate = null;
	    }
	
	    // if the consequent block is empty turn alternate blocks into a consequent
	    // and flip the test
	    //
	    //   if (foo) {} else { bar; } -> if (!foo) { bar; }
	    //
	
	    if (t.isBlockStatement(consequent) && !consequent.body.length && t.isBlockStatement(alternate) && alternate.body.length) {
	      node.consequent = node.alternate;
	      node.alternate = null;
	      node.test = t.unaryExpression("!", test, true);
	    }
	  }
	};
	exports.IfStatement = IfStatement;

/***/ },
/* 281 */
/*!********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/internal/modules.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// in this transformer we have to split up classes and function declarations
	// from their exports. why? because sometimes we need to replace classes with
	// nodes that aren't allowed in the same contexts. also, if you're exporting
	// a generator function as a default then regenerator will destroy the export
	// declaration and leave a variable declaration in it's place... yeah, handy.
	
	"use strict";
	
	exports.__esModule = true;
	exports.ImportDeclaration = ImportDeclaration;
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangClone = __webpack_require__(/*! lodash/lang/clone */ 273);
	
	var _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function getDeclar(node) {
	  var declar = node.declaration;
	  t.inheritsComments(declar, node);
	  t.removeComments(node);
	  declar._ignoreUserWhitespace = true;
	  return declar;
	}
	
	var metadata = {
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	
	function ImportDeclaration(node, parent, scope, file) {
	  if (node.source) {
	    node.source.value = file.resolveModuleSource(node.source.value);
	  }
	}
	
	exports.ExportAllDeclaration = ImportDeclaration;
	
	function ExportDefaultDeclaration(node, parent, scope) {
	  ImportDeclaration.apply(this, arguments);
	
	  var declar = node.declaration;
	
	  if (t.isClassDeclaration(declar)) {
	    // export default class Foo {};
	    var nodes = [getDeclar(node), node];
	    node.declaration = declar.id;
	    return nodes;
	  } else if (t.isClassExpression(declar)) {
	    // export default class {};
	    var temp = scope.generateUidIdentifier("default");
	    node.declaration = t.variableDeclaration("var", [t.variableDeclarator(temp, declar)]);
	
	    var nodes = [getDeclar(node), node];
	    node.declaration = temp;
	    return nodes;
	  } else if (t.isFunctionDeclaration(declar)) {
	    // export default function Foo() {}
	    node._blockHoist = 2;
	
	    var nodes = [getDeclar(node), node];
	    node.declaration = declar.id;
	    return nodes;
	  }
	}
	
	function buildExportSpecifier(id) {
	  return t.exportSpecifier((0, _lodashLangClone2["default"])(id), (0, _lodashLangClone2["default"])(id));
	}
	
	function ExportNamedDeclaration(node, parent, scope) {
	  ImportDeclaration.apply(this, arguments);
	
	  var declar = node.declaration;
	
	  if (t.isClassDeclaration(declar)) {
	    // export class Foo {}
	    node.specifiers = [buildExportSpecifier(declar.id)];
	    var nodes = [getDeclar(node), node];
	    node.declaration = null;
	    return nodes;
	  } else if (t.isFunctionDeclaration(declar)) {
	    // export function Foo() {}
	    node.specifiers = [buildExportSpecifier(declar.id)];
	    node._blockHoist = 2;
	
	    var nodes = [getDeclar(node), node];
	    node.declaration = null;
	    return nodes;
	  } else if (t.isVariableDeclaration(declar)) {
	    // export var foo = "bar";
	    var specifiers = [];
	    var bindings = this.get("declaration").getBindingIdentifiers();
	    for (var key in bindings) {
	      specifiers.push(buildExportSpecifier(bindings[key]));
	    }
	    return [declar, t.exportNamedDeclaration(null, specifiers)];
	  }
	}
	
	var Program = {
	  enter: function enter(node) {
	    var imports = [];
	    var rest = [];
	
	    for (var i = 0; i < node.body.length; i++) {
	      var bodyNode = node.body[i];
	      if (t.isImportDeclaration(bodyNode)) {
	        imports.push(bodyNode);
	      } else {
	        rest.push(bodyNode);
	      }
	    }
	
	    node.body = imports.concat(rest);
	  },
	
	  exit: function exit(node, parent, scope, file) {
	    if (!file.transformers["es6.modules"].canTransform()) return;
	
	    if (file.moduleFormatter.setup) {
	      file.moduleFormatter.setup();
	    }
	  }
	};
	exports.Program = Program;

/***/ },
/* 282 */
/*!**********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/spec/function-name.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _helpersNameMethod = __webpack_require__(/*! ../../helpers/name-method */ 283);
	
	var metadata = {
	  group: "builtin-setup"
	};
	
	exports.metadata = metadata;
	var FunctionExpression = {
	  exit: _helpersNameMethod.bare
	};
	
	exports.FunctionExpression = FunctionExpression;
	exports.ArrowFunctionExpression = FunctionExpression;

/***/ },
/* 283 */
/*!**********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/name-method.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.custom = custom;
	exports.property = property;
	exports.bare = bare;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _getFunctionArity = __webpack_require__(/*! ./get-function-arity */ 284);
	
	var _getFunctionArity2 = _interopRequireDefault(_getFunctionArity);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var visitor = {
	  enter: function enter(node, parent, scope, state) {
	    // check if this node is a referenced identifier that matches the same as our
	    // function id
	    if (!this.isReferencedIdentifier({ name: state.name })) return;
	
	    // check that we don't have a local variable declared as that removes the need
	    // for the wrapper
	    var localDeclar = scope.getBindingIdentifier(state.name);
	    if (localDeclar !== state.outerDeclar) return;
	
	    state.selfReference = true;
	    this.stop();
	  }
	};
	
	var wrap = function wrap(state, method, id, scope) {
	  if (state.selfReference) {
	    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
	      // we can just munge the local binding
	      scope.rename(id.name);
	    } else {
	      // need to add a wrapper since we can't change the references
	      var templateName = "property-method-assignment-wrapper";
	      if (method.generator) templateName += "-generator";
	      var template = util.template(templateName, {
	        FUNCTION: method,
	        FUNCTION_ID: id,
	        FUNCTION_KEY: scope.generateUidIdentifier(id.name)
	      });
	      template.callee._skipModulesRemap = true;
	
	      // shim in dummy params to retain function arity, if you try to read the
	      // source then you'll get the original since it's proxied so it's all good
	      var params = template.callee.body.body[0].params;
	      for (var i = 0, len = (0, _getFunctionArity2["default"])(method); i < len; i++) {
	        params.push(scope.generateUidIdentifier("x"));
	      }
	
	      return template;
	    }
	  }
	
	  method.id = id;
	};
	
	var visit = function visit(node, name, scope) {
	  var state = {
	    selfAssignment: false,
	    selfReference: false,
	    outerDeclar: scope.getBindingIdentifier(name),
	    references: [],
	    name: name
	  };
	
	  // check to see if we have a local binding of the id we're setting inside of
	  // the function, this is important as there are caveats associated
	
	  var bindingInfo = scope.getOwnBindingInfo(name);
	
	  if (bindingInfo) {
	    if (bindingInfo.kind === "param") {
	      // safari will blow up in strict mode with code like:
	      //
	      //   var t = function t(t) {};
	      //
	      // with the error:
	      //
	      //   Cannot declare a parameter named 't' as it shadows the name of a
	      //   strict mode function.
	      //
	      // this isn't to the spec and they've invented this behaviour which is
	      // **extremely** annoying so we avoid setting the name if it has a param
	      // with the same id
	      state.selfReference = true;
	    } else {}
	  } else if (state.outerDeclar || scope.hasGlobal(name)) {
	    scope.traverse(node, visitor, state);
	  }
	
	  return state;
	};
	
	function custom(node, id, scope) {
	  var state = visit(node, id.name, scope);
	  return wrap(state, node, id, scope);
	}
	
	function property(node, file, scope) {
	  var key = t.toComputedKey(node, node.key);
	  if (!t.isLiteral(key)) return; // we can't set a function id with this
	
	  var name = t.toIdentifier(key.value);
	  if (name === "eval" || name === "arguments") name = "_" + name;
	  var id = t.identifier(name);
	
	  var method = node.value;
	  var state = visit(method, name, scope);
	  node.value = wrap(state, method, id, scope) || method;
	}
	
	function bare(node, parent, scope) {
	  // has an `id` so we don't need to infer one
	  if (node.id) return;
	
	  var id;
	  if (t.isProperty(parent) && parent.kind === "init" && (!parent.computed || t.isLiteral(parent.key))) {
	    // { foo() {} };
	    id = parent.key;
	  } else if (t.isVariableDeclarator(parent)) {
	    // var foo = function () {};
	    id = parent.id;
	
	    if (t.isIdentifier(id)) {
	      var bindingInfo = scope.parent.getBinding(id.name);
	      if (bindingInfo && bindingInfo.constant && scope.getBinding(id.name) === bindingInfo) {
	        // always going to reference this method
	        node.id = id;
	        return;
	      }
	    }
	  } else {
	    return;
	  }
	
	  var name;
	  if (t.isLiteral(id)) {
	    name = id.value;
	  } else if (t.isIdentifier(id)) {
	    name = id.name;
	  } else {
	    return;
	  }
	
	  name = t.toIdentifier(name);
	  id = t.identifier(name);
	
	  var state = visit(node, name, scope);
	  return wrap(state, node, id, scope);
	}
	
	// otherwise it's defined somewhere in scope like:
	//
	//   var t = function () {
	//     var t = 2;
	//   };
	//
	// so we can safely just set the id and move along as it shadows the
	// bound function id

/***/ },
/* 284 */
/*!*****************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/get-function-arity.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	exports["default"] = function (node) {
	  var lastNonDefault = 0;
	  for (var i = 0; i < node.params.length; i++) {
	    if (!t.isAssignmentPattern(node.params[i])) lastNonDefault = i + 1;
	  }
	  return lastNonDefault;
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 285 */
/*!************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/class-properties.js ***!
  \************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	var metadata = {
	  stage: 0,
	  dependencies: ["es6.classes"]
	};
	exports.metadata = metadata;

/***/ },
/* 286 */
/*!********************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/trailing-function-commas.js ***!
  \********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	var metadata = {
	  stage: 1
	};
	exports.metadata = metadata;

/***/ },
/* 287 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/async-functions.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	var metadata = {
	  stage: 1
	};
	exports.metadata = metadata;

/***/ },
/* 288 */
/*!******************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/decorators.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ObjectExpression = ObjectExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersMemoiseDecorators = __webpack_require__(/*! ../../helpers/memoise-decorators */ 289);
	
	var _helpersMemoiseDecorators2 = _interopRequireDefault(_helpersMemoiseDecorators);
	
	var _helpersDefineMap = __webpack_require__(/*! ../../helpers/define-map */ 290);
	
	var defineMap = _interopRequireWildcard(_helpersDefineMap);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  dependencies: ["es6.classes"],
	  optional: true,
	  stage: 1
	};
	
	exports.metadata = metadata;
	
	function ObjectExpression(node, parent, scope, file) {
	  var hasDecorators = false;
	  for (var i = 0; i < node.properties.length; i++) {
	    var prop = node.properties[i];
	    if (prop.decorators) {
	      hasDecorators = true;
	      break;
	    }
	  }
	  if (!hasDecorators) return;
	
	  var mutatorMap = {};
	
	  for (var i = 0; i < node.properties.length; i++) {
	    var prop = node.properties[i];
	    if (prop.decorators) (0, _helpersMemoiseDecorators2["default"])(prop.decorators, scope);
	
	    if (prop.kind === "init") {
	      prop.kind = "";
	      prop.value = t.functionExpression(null, [], t.blockStatement([t.returnStatement(prop.value)]));
	    }
	
	    defineMap.push(mutatorMap, prop, "initializer", file);
	  }
	
	  var obj = defineMap.toClassObject(mutatorMap);
	  obj = defineMap.toComputedObjectFromClass(obj);
	  return t.callExpression(file.addHelper("create-decorated-object"), [obj]);
	}

/***/ },
/* 289 */
/*!*****************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/memoise-decorators.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	exports["default"] = function (decorators, scope) {
	  for (var i = 0; i < decorators.length; i++) {
	    var decorator = decorators[i];
	    var expression = decorator.expression;
	    if (!t.isMemberExpression(expression)) continue;
	
	    var temp = scope.maybeGenerateMemoised(expression.object);
	    var ref;
	
	    var nodes = [];
	
	    if (temp) {
	      ref = temp;
	      nodes.push(t.assignmentExpression("=", temp, expression.object));
	    } else {
	      ref = expression.object;
	    }
	
	    nodes.push(t.callExpression(t.memberExpression(t.memberExpression(ref, expression.property, expression.computed), t.identifier("bind")), [ref]));
	
	    if (nodes.length === 1) {
	      decorator.expression = nodes[0];
	    } else {
	      decorator.expression = t.sequenceExpression(nodes);
	    }
	  }
	
	  return decorators;
	};
	
	module.exports = exports["default"];

/***/ },
/* 290 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/define-map.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.push = push;
	exports.hasComputed = hasComputed;
	exports.toComputedObjectFromClass = toComputedObjectFromClass;
	exports.toClassObject = toClassObject;
	exports.toDefineObject = toDefineObject;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangCloneDeep = __webpack_require__(/*! lodash/lang/cloneDeep */ 255);
	
	var _lodashLangCloneDeep2 = _interopRequireDefault(_lodashLangCloneDeep);
	
	var _traversal = __webpack_require__(/*! ../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _lodashObjectHas = __webpack_require__(/*! lodash/object/has */ 264);
	
	var _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function push(mutatorMap, node, kind, file) {
	  var alias = t.toKeyAlias(node);
	
	  //
	
	  var map = {};
	  if ((0, _lodashObjectHas2["default"])(mutatorMap, alias)) map = mutatorMap[alias];
	  mutatorMap[alias] = map;
	
	  //
	
	  map._inherits = map._inherits || [];
	  map._inherits.push(node);
	
	  map._key = node.key;
	
	  if (node.computed) {
	    map._computed = true;
	  }
	
	  if (node.decorators) {
	    var decorators = map.decorators = map.decorators || t.arrayExpression([]);
	    decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {
	      return dec.expression;
	    }).reverse());
	  }
	
	  if (map.value || map.initializer) {
	    throw file.errorWithNode(node, "Key conflict with sibling node");
	  }
	
	  if (node.value) {
	    if (node.kind === "init") kind = "value";
	    if (node.kind === "get") kind = "get";
	    if (node.kind === "set") kind = "set";
	
	    t.inheritsComments(node.value, node);
	    map[kind] = node.value;
	  }
	
	  return map;
	}
	
	function hasComputed(mutatorMap) {
	  for (var key in mutatorMap) {
	    if (mutatorMap[key]._computed) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function toComputedObjectFromClass(obj) {
	  var objExpr = t.arrayExpression([]);
	
	  for (var i = 0; i < obj.properties.length; i++) {
	    var prop = obj.properties[i];
	    var val = prop.value;
	    val.properties.unshift(t.property("init", t.identifier("key"), t.toComputedKey(prop)));
	    objExpr.elements.push(val);
	  }
	
	  return objExpr;
	}
	
	function toClassObject(mutatorMap) {
	  var objExpr = t.objectExpression([]);
	
	  (0, _lodashCollectionEach2["default"])(mutatorMap, function (map) {
	    var mapNode = t.objectExpression([]);
	
	    var propNode = t.property("init", map._key, mapNode, map._computed);
	
	    (0, _lodashCollectionEach2["default"])(map, function (node, key) {
	      if (key[0] === "_") return;
	
	      var inheritNode = node;
	      if (t.isMethodDefinition(node) || t.isClassProperty(node)) node = node.value;
	
	      var prop = t.property("init", t.identifier(key), node);
	      t.inheritsComments(prop, inheritNode);
	      t.removeComments(inheritNode);
	
	      mapNode.properties.push(prop);
	    });
	
	    objExpr.properties.push(propNode);
	  });
	
	  return objExpr;
	}
	
	function toDefineObject(mutatorMap) {
	  (0, _lodashCollectionEach2["default"])(mutatorMap, function (map) {
	    if (map.value) map.writable = t.literal(true);
	    map.configurable = t.literal(true);
	    map.enumerable = t.literal(true);
	  });
	
	  return toClassObject(mutatorMap);
	}

/***/ },
/* 291 */
/*!****************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/validation/undeclared-variable-check.js ***!
  \****************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Identifier = Identifier;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _leven = __webpack_require__(/*! leven */ 292);
	
	var _leven2 = _interopRequireDefault(_leven);
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var metadata = {
	  optional: true
	};
	
	exports.metadata = metadata;
	
	function Identifier(node, parent, scope, file) {
	  if (!this.isReferenced()) return;
	  if (scope.hasBinding(node.name)) return;
	
	  // get the closest declaration to offer as a suggestion
	  // the variable name may have just been mistyped
	
	  var bindings = scope.getAllBindings();
	
	  var closest;
	  var shortest = -1;
	
	  for (var name in bindings) {
	    var distance = (0, _leven2["default"])(node.name, name);
	    if (distance <= 0 || distance > 3) continue;
	    if (distance <= shortest) continue;
	
	    closest = name;
	    shortest = distance;
	  }
	
	  var msg;
	  if (closest) {
	    msg = messages.get("undeclaredVariableSuggestion", node.name, closest);
	  } else {
	    msg = messages.get("undeclaredVariable", node.name);
	  }
	
	  //
	
	  throw file.errorWithNode(node, msg, ReferenceError);
	}

/***/ },
/* 292 */
/*!************************!*\
  !*** external "leven" ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("leven");

/***/ },
/* 293 */
/*!********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/validation/react.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.CallExpression = CallExpression;
	exports.ModuleDeclaration = ModuleDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	// check if the input Literal `source` is an alternate casing of "react"
	function check(source, file) {
	  if (t.isLiteral(source)) {
	    var name = source.value;
	    var lower = name.toLowerCase();
	
	    if (lower === "react" && name !== lower) {
	      throw file.errorWithNode(source, messages.get("didYouMean", "react"));
	    }
	  }
	}
	
	function CallExpression(node, parent, scope, file) {
	  if (this.get("callee").isIdentifier({ name: "require" }) && node.arguments.length === 1) {
	    check(node.arguments[0], file);
	  }
	}
	
	function ModuleDeclaration(node, parent, scope, file) {
	  check(node.source, file);
	}

/***/ },
/* 294 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/arrow-functions.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function ArrowFunctionExpression(node) {
	  t.ensureBlock(node);
	
	  node.expression = false;
	  node.type = "FunctionExpression";
	  node.shadow = true;
	}

/***/ },
/* 295 */
/*!*******************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/spec/block-scoped-functions.js ***!
  \*******************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.BlockStatement = BlockStatement;
	exports.SwitchCase = SwitchCase;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function statementList(key, path, file) {
	  var paths = path.get(key);
	
	  for (var i = 0; i < paths.length; i++) {
	    var path = paths[i];
	
	    var func = path.node;
	    if (!t.isFunctionDeclaration(func)) continue;
	
	    var declar = t.variableDeclaration("let", [t.variableDeclarator(func.id, t.toExpression(func))]);
	
	    // hoist it up above everything else
	    declar._blockHoist = 2;
	
	    // todo: name this
	    func.id = null;
	
	    path.replaceWith(declar);
	  }
	}
	
	function BlockStatement(node, parent, scope, file) {
	  if (t.isFunction(parent) && parent.body === node || t.isExportDeclaration(parent)) {
	    return;
	  }
	
	  statementList("body", this, file);
	}
	
	function SwitchCase(node, parent, scope, file) {
	  statementList("consequent", this, file);
	}

/***/ },
/* 296 */
/*!****************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/optimisation/react.constant-elements.js ***!
  \****************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.JSXElement = JSXElement;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _helpersReact = __webpack_require__(/*! ../../helpers/react */ 207);
	
	var react = _interopRequireWildcard(_helpersReact);
	
	var metadata = {
	  optional: true
	};
	
	exports.metadata = metadata;
	var immutabilityVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    var _this = this;
	
	    var stop = function stop() {
	      state.isImmutable = false;
	      _this.stop();
	    };
	
	    if (this.isJSXClosingElement()) {
	      this.skip();
	      return;
	    }
	
	    if (this.isJSXIdentifier({ name: "ref" }) && this.parentPath.isJSXAttribute({ name: node })) {
	      return stop();
	    }
	
	    if (this.isJSXIdentifier() || this.isIdentifier() || this.isJSXMemberExpression()) {
	      return;
	    }
	
	    if (!this.isImmutable()) stop();
	  }
	};
	
	function JSXElement(node, parent, scope, file) {
	  if (node._hoisted) return;
	
	  var state = { isImmutable: true };
	  this.traverse(immutabilityVisitor, state);
	
	  if (state.isImmutable) {
	    this.hoist();
	  } else {
	    node._hoisted = true;
	  }
	}

/***/ },
/* 297 */
/*!**************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/optimisation/react.inline-elements.js ***!
  \**************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.JSXElement = JSXElement;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _helpersReact = __webpack_require__(/*! ../../helpers/react */ 207);
	
	var react = _interopRequireWildcard(_helpersReact);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true
	};
	
	exports.metadata = metadata;
	function hasRefOrSpread(attrs) {
	  for (var i = 0; i < attrs.length; i++) {
	    var attr = attrs[i];
	    if (t.isJSXSpreadAttribute(attr)) return true;
	    if (isJSXAttributeOfName(attr, "ref")) return true;
	  }
	  return false;
	}
	
	function isJSXAttributeOfName(attr, name) {
	  return t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name, { name: name });
	}
	
	function JSXElement(node, parent, scope, file) {
	  // filter
	  var open = node.openingElement;
	  if (hasRefOrSpread(open.attributes)) return;
	
	  // init
	  var isComponent = true;
	  var props = t.objectExpression([]);
	  var obj = t.objectExpression([]);
	  var key = t.literal(null);
	  var type = open.name;
	
	  if (t.isJSXIdentifier(type) && react.isCompatTag(type.name)) {
	    type = t.literal(type.name);
	    isComponent = false;
	  }
	
	  function pushElemProp(key, value) {
	    pushProp(obj.properties, t.identifier(key), value);
	  }
	
	  function pushProp(objProps, key, value) {
	    objProps.push(t.property("init", key, value));
	  }
	
	  // metadata
	  pushElemProp("type", type);
	  pushElemProp("ref", t.literal(null));
	
	  if (node.children.length) {
	    pushProp(props.properties, t.identifier("children"), t.arrayExpression(react.buildChildren(node)));
	  }
	
	  // props
	  for (var i = 0; i < open.attributes.length; i++) {
	    var attr = open.attributes[i];
	    if (isJSXAttributeOfName(attr, "key")) {
	      key = attr.value;
	    } else {
	      pushProp(props.properties, attr.name, attr.value || t.identifier("true"));
	    }
	  }
	
	  if (isComponent) {
	    props = t.callExpression(file.addHelper("default-props"), [t.memberExpression(type, t.identifier("defaultProps")), props]);
	  }
	
	  pushElemProp("props", props);
	
	  // key
	  pushElemProp("key", key);
	
	  return obj;
	}

/***/ },
/* 298 */
/*!**********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/comprehensions.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ComprehensionExpression = ComprehensionExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersBuildComprehension = __webpack_require__(/*! ../../helpers/build-comprehension */ 299);
	
	var _helpersBuildComprehension2 = _interopRequireDefault(_helpersBuildComprehension);
	
	var _traversal = __webpack_require__(/*! ../../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _util = __webpack_require__(/*! ../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  stage: 0
	};
	
	exports.metadata = metadata;
	
	function ComprehensionExpression(node, parent, scope, file) {
	  var callback = array;
	  if (node.generator) callback = generator;
	  return callback(node, parent, scope, file);
	}
	
	function generator(node) {
	  var body = [];
	  var container = t.functionExpression(null, [], t.blockStatement(body), true);
	  container.shadow = true;
	
	  body.push((0, _helpersBuildComprehension2["default"])(node, function () {
	    return t.expressionStatement(t.yieldExpression(node.body));
	  }));
	
	  return t.callExpression(container, []);
	}
	
	function array(node, parent, scope, file) {
	  var uid = scope.generateUidIdentifierBasedOnNode(parent);
	
	  var container = util.template("array-comprehension-container", {
	    KEY: uid
	  });
	  container.callee.shadow = true;
	
	  var block = container.callee.body;
	  var body = block.body;
	
	  if (_traversal2["default"].hasType(node, scope, "YieldExpression", t.FUNCTION_TYPES)) {
	    container.callee.generator = true;
	    container = t.yieldExpression(container, true);
	  }
	
	  var returnStatement = body.pop();
	
	  body.push((0, _helpersBuildComprehension2["default"])(node, function () {
	    return util.template("array-push", {
	      STATEMENT: node.body,
	      KEY: uid
	    }, true);
	  }));
	  body.push(returnStatement);
	
	  return container;
	}

/***/ },
/* 299 */
/*!******************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/build-comprehension.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = build;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function build(node, buildBody) {
	  var self = node.blocks.shift();
	  if (!self) return;
	
	  var child = build(node, buildBody);
	  if (!child) {
	    // last item
	    child = buildBody();
	
	    // add a filter as this is our final stop
	    if (node.filter) {
	      child = t.ifStatement(node.filter, t.blockStatement([child]));
	    }
	  }
	
	  return t.forOfStatement(t.variableDeclaration("let", [t.variableDeclarator(self.left)]), self.right, t.blockStatement([child]));
	}
	
	module.exports = exports["default"];

/***/ },
/* 300 */
/*!***************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/classes.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ClassDeclaration = ClassDeclaration;
	exports.ClassExpression = ClassExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _helpersMemoiseDecorators = __webpack_require__(/*! ../../helpers/memoise-decorators */ 289);
	
	var _helpersMemoiseDecorators2 = _interopRequireDefault(_helpersMemoiseDecorators);
	
	var _helpersReplaceSupers = __webpack_require__(/*! ../../helpers/replace-supers */ 301);
	
	var _helpersReplaceSupers2 = _interopRequireDefault(_helpersReplaceSupers);
	
	var _helpersNameMethod = __webpack_require__(/*! ../../helpers/name-method */ 283);
	
	var nameMethod = _interopRequireWildcard(_helpersNameMethod);
	
	var _helpersDefineMap = __webpack_require__(/*! ../../helpers/define-map */ 290);
	
	var defineMap = _interopRequireWildcard(_helpersDefineMap);
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _util = __webpack_require__(/*! ../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _traversal = __webpack_require__(/*! ../../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _lodashObjectHas = __webpack_require__(/*! lodash/object/has */ 264);
	
	var _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var PROPERTY_COLLISION_METHOD_NAME = "__initializeProperties";
	
	function ClassDeclaration(node, parent, scope, file) {
	  return t.variableDeclaration("let", [t.variableDeclarator(node.id, t.toExpression(node))]);
	}
	
	function ClassExpression(node, parent, scope, file) {
	  return new ClassTransformer(this, file).run();
	}
	
	var collectPropertyReferencesVisitor = {
	  Identifier: {
	    enter: function enter(node, parent, scope, state) {
	      if (this.parentPath.isClassProperty({ key: node })) {
	        return;
	      }
	
	      if (this.isReferenced() && scope.getBinding(node.name) === state.scope.getBinding(node.name)) {
	        state.references[node.name] = true;
	      }
	    }
	  }
	};
	
	var constructorVisitor = {
	  ThisExpression: {
	    enter: function enter(node, parent, scope, ref) {
	      return ref;
	    }
	  },
	
	  Function: {
	    enter: function enter(node) {
	      if (!node.shadow) {
	        this.skip();
	      }
	    }
	  }
	};
	
	var verifyConstructorVisitor = {
	  MethodDefinition: {
	    enter: function enter() {
	      this.skip();
	    }
	  },
	
	  Property: {
	    enter: function enter(node) {
	      if (node.method) this.skip();
	    }
	  },
	
	  CallExpression: {
	    exit: function exit(node, parent, scope, state) {
	      if (this.get("callee").isSuper()) {
	        state.hasBareSuper = true;
	        state.bareSuper = this;
	
	        if (!state.hasSuper) {
	          throw this.errorWithNode("super call is only allowed in derived constructor");
	        }
	      }
	    }
	  },
	
	  FunctionDeclaration: {
	    enter: function enter() {
	      this.skip();
	    }
	  },
	
	  FunctionExpression: {
	    enter: function enter() {
	      this.skip();
	    }
	  },
	
	  ThisExpression: {
	    enter: function enter(node, parent, scope, state) {
	      if (state.hasSuper && !state.hasBareSuper) {
	        throw this.errorWithNode("'this' is not allowed before super()");
	      }
	    }
	  }
	};
	
	var ClassTransformer = (function () {
	
	  /**
	   * Description
	   */
	
	  function ClassTransformer(path, file) {
	    _classCallCheck(this, ClassTransformer);
	
	    this.parent = path.parent;
	    this.scope = path.scope;
	    this.node = path.node;
	    this.path = path;
	    this.file = file;
	
	    this.hasInstanceDescriptors = false;
	    this.hasStaticDescriptors = false;
	
	    this.instanceMutatorMap = {};
	    this.staticMutatorMap = {};
	
	    this.instancePropBody = [];
	    this.instancePropRefs = {};
	    this.staticPropBody = [];
	    this.body = [];
	
	    this.hasConstructor = false;
	    this.hasDecorators = false;
	    this.className = this.node.id;
	    this.classRef = this.node.id || this.scope.generateUidIdentifier("class");
	
	    this.superName = this.node.superClass || t.identifier("Function");
	    this.hasSuper = !!this.node.superClass;
	
	    this.isLoose = file.isLoose("es6.classes");
	  }
	
	  /**
	   * Description
	   *
	   * @returns {Array}
	   */
	
	  ClassTransformer.prototype.run = function run() {
	    var superName = this.superName;
	    var className = this.className;
	    var classBody = this.node.body.body;
	    var classRef = this.classRef;
	    var file = this.file;
	
	    //
	
	    var body = this.body;
	
	    //
	
	    var constructorBody = this.constructorBody = t.blockStatement([]);
	    var constructor;
	
	    if (this.className) {
	      constructor = t.functionDeclaration(this.className, [], constructorBody);
	      body.push(constructor);
	    } else {
	      constructor = t.functionExpression(null, [], constructorBody);
	    }
	
	    this.constructor = constructor;
	
	    //
	
	    var closureParams = [];
	    var closureArgs = [];
	
	    //
	    if (this.hasSuper) {
	      closureArgs.push(superName);
	
	      superName = this.scope.generateUidIdentifierBasedOnNode(superName);
	      closureParams.push(superName);
	
	      this.superName = superName;
	      body.push(t.expressionStatement(t.callExpression(file.addHelper("inherits"), [classRef, superName])));
	    }
	
	    //
	    var decorators = this.node.decorators;
	    if (decorators) {
	      // create a class reference to use later on
	      this.classRef = this.scope.generateUidIdentifier(classRef);
	
	      // this is so super calls and the decorators have access to the raw function
	      body.push(t.variableDeclaration("var", [t.variableDeclarator(this.classRef, classRef)]));
	    }
	
	    //
	    this.buildBody();
	
	    // make sure this class isn't directly called
	    constructorBody.body.unshift(t.expressionStatement(t.callExpression(file.addHelper("class-call-check"), [t.thisExpression(), this.classRef])));
	
	    //
	
	    if (decorators) {
	      // reverse the decorators so we execute them in the right order
	      decorators = decorators.reverse();
	
	      for (var i = 0; i < decorators.length; i++) {
	        var decorator = decorators[i];
	
	        var decoratorNode = util.template("class-decorator", {
	          DECORATOR: decorator.expression,
	          CLASS_REF: classRef
	        }, true);
	        decoratorNode.expression._ignoreModulesRemap = true;
	        body.push(decoratorNode);
	      }
	    }
	
	    if (this.className) {
	      // named class with only a constructor
	      if (body.length === 1) return t.toExpression(body[0]);
	    } else {
	      // infer class name if this is a nameless class expression
	      constructor = nameMethod.bare(constructor, this.parent, this.scope) || constructor;
	
	      body.unshift(t.variableDeclaration("var", [t.variableDeclarator(classRef, constructor)]));
	
	      t.inheritsComments(body[0], this.node);
	    }
	
	    body = body.concat(this.staticPropBody);
	
	    //
	
	    body.push(t.returnStatement(classRef));
	
	    return t.callExpression(t.functionExpression(null, closureParams, t.blockStatement(body)), closureArgs);
	  };
	
	  /**
	   * Description
	   */
	
	  ClassTransformer.prototype.pushToMap = function pushToMap(node, enumerable) {
	    var kind = arguments[2] === undefined ? "value" : arguments[2];
	
	    var mutatorMap;
	    if (node["static"]) {
	      this.hasStaticDescriptors = true;
	      mutatorMap = this.staticMutatorMap;
	    } else {
	      this.hasInstanceDescriptors = true;
	      mutatorMap = this.instanceMutatorMap;
	    }
	
	    var map = defineMap.push(mutatorMap, node, kind, this.file);
	
	    if (enumerable) {
	      map.enumerable = t.literal(true);
	    }
	
	    if (map.decorators) {
	      this.hasDecorators = true;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  ClassTransformer.prototype.buildBody = function buildBody() {
	    var constructorBody = this.constructorBody;
	    var constructor = this.constructor;
	    var className = this.className;
	    var superName = this.superName;
	    var classBody = this.node.body.body;
	    var body = this.body;
	
	    var classBodyPaths = this.path.get("body").get("body");
	
	    for (var i = 0; i < classBody.length; i++) {
	      var node = classBody[i];
	      var path = classBodyPaths[i];
	
	      if (node.decorators) {
	        (0, _helpersMemoiseDecorators2["default"])(node.decorators, this.scope);
	      }
	
	      if (t.isMethodDefinition(node)) {
	        var isConstructor = node.kind === "constructor";
	        if (isConstructor) this.verifyConstructor(path);
	
	        var replaceSupers = new _helpersReplaceSupers2["default"]({
	          methodPath: path,
	          methodNode: node,
	          objectRef: this.classRef,
	          superRef: this.superName,
	          isStatic: node["static"],
	          isLoose: this.isLoose,
	          scope: this.scope,
	          file: this.file
	        }, true);
	
	        replaceSupers.replace();
	
	        if (isConstructor) {
	          this.pushConstructor(node, path);
	        } else {
	          this.pushMethod(node, path);
	        }
	      } else if (t.isClassProperty(node)) {
	        this.pushProperty(node);
	      }
	    }
	
	    // we have no constructor, but we're a derived class
	    if (!this.hasConstructor && this.hasSuper) {
	      var helperName = "class-super-constructor-call";
	      if (this.isLoose) helperName += "-loose";
	      constructorBody.body.push(util.template(helperName, {
	        CLASS_NAME: this.classRef,
	        SUPER_NAME: this.superName
	      }, true));
	    }
	
	    //
	    this.placePropertyInitializers();
	
	    //
	    if (this.userConstructor) {
	      constructorBody.body = constructorBody.body.concat(this.userConstructor.body.body);
	      t.inherits(this.constructor, this.userConstructor);
	      t.inherits(this.constructorBody, this.userConstructor.body);
	    }
	
	    var instanceProps;
	    var staticProps;
	    var classHelper = "create-class";
	    if (this.hasDecorators) classHelper = "create-decorated-class";
	
	    if (this.hasInstanceDescriptors) {
	      instanceProps = defineMap.toClassObject(this.instanceMutatorMap);
	    }
	
	    if (this.hasStaticDescriptors) {
	      staticProps = defineMap.toClassObject(this.staticMutatorMap);
	    }
	
	    if (instanceProps || staticProps) {
	      if (instanceProps) instanceProps = defineMap.toComputedObjectFromClass(instanceProps);
	      if (staticProps) staticProps = defineMap.toComputedObjectFromClass(staticProps);
	
	      var nullNode = t.literal(null);
	
	      // (Constructor, instanceDescriptors, staticDescriptors, instanceInitializers, staticInitializers)
	      var args = [this.classRef, nullNode, nullNode, nullNode, nullNode];
	
	      if (instanceProps) args[1] = instanceProps;
	      if (staticProps) args[2] = staticProps;
	
	      if (this.instanceInitializersId) {
	        args[3] = this.instanceInitializersId;
	        body.unshift(this.buildObjectAssignment(this.instanceInitializersId));
	      }
	
	      if (this.staticInitializersId) {
	        args[4] = this.staticInitializersId;
	        body.unshift(this.buildObjectAssignment(this.staticInitializersId));
	      }
	
	      var lastNonNullIndex = 0;
	      for (var i = 0; i < args.length; i++) {
	        if (args[i] !== nullNode) lastNonNullIndex = i;
	      }
	      args = args.slice(0, lastNonNullIndex + 1);
	
	      body.push(t.expressionStatement(t.callExpression(this.file.addHelper(classHelper), args)));
	    }
	  };
	
	  ClassTransformer.prototype.buildObjectAssignment = function buildObjectAssignment(id) {
	    return t.variableDeclaration("var", [t.variableDeclarator(id, t.objectExpression([]))]);
	  };
	
	  /**
	   * Description
	   */
	
	  ClassTransformer.prototype.placePropertyInitializers = function placePropertyInitializers() {
	    var body = this.instancePropBody;
	    if (!body.length) return;
	
	    if (this.hasPropertyCollision()) {
	      var call = t.expressionStatement(t.callExpression(t.memberExpression(t.thisExpression(), t.identifier(PROPERTY_COLLISION_METHOD_NAME)), []));
	
	      this.pushMethod(t.methodDefinition(t.identifier(PROPERTY_COLLISION_METHOD_NAME), t.functionExpression(null, [], t.blockStatement(body))), null, true);
	
	      if (this.hasSuper) {
	        this.bareSuper.insertAfter(call);
	      } else {
	        this.constructorBody.body.unshift(call);
	      }
	    } else {
	      if (this.hasSuper) {
	        if (this.hasConstructor) {
	          this.bareSuper.insertAfter(body);
	        } else {
	          this.constructorBody.body = this.constructorBody.body.concat(body);
	        }
	      } else {
	        this.constructorBody.body = body.concat(this.constructorBody.body);
	      }
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  ClassTransformer.prototype.hasPropertyCollision = function hasPropertyCollision() {
	    if (this.userConstructorPath) {
	      for (var name in this.instancePropRefs) {
	        if (this.userConstructorPath.scope.hasOwnBinding(name)) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  };
	
	  /**
	   * Description
	   */
	
	  ClassTransformer.prototype.verifyConstructor = function verifyConstructor(path) {
	    var state = {
	      hasBareSuper: false,
	      bareSuper: null,
	      hasSuper: this.hasSuper,
	      file: this.file
	    };
	
	    path.get("value").traverse(verifyConstructorVisitor, state);
	
	    this.bareSuper = state.bareSuper;
	
	    if (!state.hasBareSuper && this.hasSuper) {
	      throw path.errorWithNode("Derived constructor must call super()");
	    }
	  };
	
	  /**
	   * Push a method to its respective mutatorMap.
	   */
	
	  ClassTransformer.prototype.pushMethod = function pushMethod(node, path, allowedIllegal) {
	    if (!allowedIllegal && t.isLiteral(t.toComputedKey(node), { value: PROPERTY_COLLISION_METHOD_NAME })) {
	      throw this.file.errorWithNode(node, messages.get("illegalMethodName", PROPERTY_COLLISION_METHOD_NAME));
	    }
	
	    if (node.kind === "method") {
	      nameMethod.property(node, this.file, path ? path.get("value").scope : this.scope);
	
	      if (this.isLoose && !node.decorators) {
	        // use assignments instead of define properties for loose classes
	
	        var classRef = this.classRef;
	        if (!node["static"]) classRef = t.memberExpression(classRef, t.identifier("prototype"));
	        var methodName = t.memberExpression(classRef, node.key, node.computed);
	
	        var expr = t.expressionStatement(t.assignmentExpression("=", methodName, node.value));
	        t.inheritsComments(expr, node);
	        this.body.push(expr);
	        return;
	      }
	    }
	
	    this.pushToMap(node);
	  };
	
	  /**
	   * Description
	   */
	
	  ClassTransformer.prototype.pushProperty = function pushProperty(node) {
	    var key;
	
	    this.scope.traverse(node, collectPropertyReferencesVisitor, {
	      references: this.instancePropRefs,
	      scope: this.scope
	    });
	
	    if (node.decorators) {
	      var body = [];
	      if (node.value) {
	        body.push(t.returnStatement(node.value));
	        node.value = t.functionExpression(null, [], t.blockStatement(body));
	      } else {
	        node.value = t.literal(null);
	      }
	      this.pushToMap(node, true, "initializer");
	
	      var initializers;
	      var body;
	      var target;
	      if (node["static"]) {
	        initializers = this.staticInitializersId = this.staticInitializersId || this.scope.generateUidIdentifier("staticInitializers");
	        body = this.staticPropBody;
	        target = this.classRef;
	      } else {
	        initializers = this.instanceInitializersId = this.instanceInitializersId || this.scope.generateUidIdentifier("instanceInitializers");
	        body = this.instancePropBody;
	        target = t.thisExpression();
	      }
	
	      body.push(t.expressionStatement(t.callExpression(this.file.addHelper("define-decorated-property-descriptor"), [target, t.literal(node.key.name), initializers])));
	    } else {
	      if (!node.value && !node.decorators) return;
	
	      if (node["static"]) {
	        // can just be added to the static map
	        this.pushToMap(node, true);
	      } else if (node.value) {
	        // add this to the instancePropBody which will be added after the super call in a derived constructor
	        // or at the start of a constructor for a non-derived constructor
	        this.instancePropBody.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), node.key), node.value)));
	      }
	    }
	  };
	
	  /**
	   * Replace the constructor body of our class.
	   */
	
	  ClassTransformer.prototype.pushConstructor = function pushConstructor(method, path) {
	    // https://github.com/babel/babel/issues/1077
	    var fnPath = path.get("value");
	    if (fnPath.scope.hasOwnBinding(this.classRef.name)) {
	      fnPath.scope.rename(this.classRef.name);
	    }
	
	    var construct = this.constructor;
	    var fn = method.value;
	
	    this.userConstructorPath = fnPath;
	    this.userConstructor = fn;
	    this.hasConstructor = true;
	
	    t.inheritsComments(construct, method);
	
	    construct._ignoreUserWhitespace = true;
	    construct.params = fn.params;
	
	    t.inherits(construct.body, fn.body);
	  };
	
	  return ClassTransformer;
	})();

/***/ },
/* 301 */
/*!*************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/replace-supers.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _messages = __webpack_require__(/*! ../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function isIllegalBareSuper(node, parent) {
	  if (!t.isSuper(node)) return false;
	  if (t.isMemberExpression(parent, { computed: false })) return false;
	  if (t.isCallExpression(parent, { callee: node })) return false;
	  return true;
	}
	
	function isMemberExpressionSuper(node) {
	  return t.isMemberExpression(node) && t.isSuper(node.object);
	}
	
	var visitor = {
	  enter: function enter(node, parent, scope, state) {
	    var topLevel = state.topLevel;
	    var self = state.self;
	
	    if (t.isFunction(node) && !t.isArrowFunctionExpression(node)) {
	      // we need to call traverseLevel again so we're context aware
	      self.traverseLevel(this, false);
	      return this.skip();
	    }
	
	    if (t.isProperty(node, { method: true }) || t.isMethodDefinition(node)) {
	      // break on object methods
	      return this.skip();
	    }
	
	    var getThisReference = topLevel ?
	    // top level so `this` is the instance
	    t.thisExpression :
	    // not in the top level so we need to create a reference
	    self.getThisReference.bind(self);
	
	    var callback = self.specHandle;
	    if (self.isLoose) callback = self.looseHandle;
	    var result = callback.call(self, this, getThisReference);
	    if (result) this.hasSuper = true;
	    if (result === true) return;
	    return result;
	  }
	};
	
	var ReplaceSupers = (function () {
	
	  /**
	   * Description
	   */
	
	  function ReplaceSupers(opts) {
	    var inClass = arguments[1] === undefined ? false : arguments[1];
	
	    _classCallCheck(this, ReplaceSupers);
	
	    this.topLevelThisReference = opts.topLevelThisReference;
	    this.methodPath = opts.methodPath;
	    this.methodNode = opts.methodNode;
	    this.superRef = opts.superRef;
	    this.isStatic = opts.isStatic;
	    this.hasSuper = false;
	    this.inClass = inClass;
	    this.isLoose = opts.isLoose;
	    this.scope = opts.scope;
	    this.file = opts.file;
	    this.opts = opts;
	  }
	
	  ReplaceSupers.prototype.getObjectRef = function getObjectRef() {
	    return this.opts.objectRef || this.opts.getObjectRef();
	  };
	
	  /**
	   * Sets a super class value of the named property.
	   *
	   * @example
	   *
	   *   _set(Object.getPrototypeOf(CLASS.prototype), "METHOD", "VALUE", this)
	   *
	   */
	
	  ReplaceSupers.prototype.setSuperProperty = function setSuperProperty(property, value, isComputed, thisExpression) {
	    return t.callExpression(this.file.addHelper("set"), [t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")), [this.isStatic ? this.getObjectRef() : t.memberExpression(this.getObjectRef(), t.identifier("prototype"))]), isComputed ? property : t.literal(property.name), value, thisExpression]);
	  };
	
	  /**
	   * Gets a node representing the super class value of the named property.
	   *
	   * @example
	   *
	   *   _get(Object.getPrototypeOf(CLASS.prototype), "METHOD", this)
	   *
	   */
	
	  ReplaceSupers.prototype.getSuperProperty = function getSuperProperty(property, isComputed, thisExpression) {
	    return t.callExpression(this.file.addHelper("get"), [t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")), [this.isStatic ? this.getObjectRef() : t.memberExpression(this.getObjectRef(), t.identifier("prototype"))]), isComputed ? property : t.literal(property.name), thisExpression]);
	  };
	
	  /**
	   * Description
	   */
	
	  ReplaceSupers.prototype.replace = function replace() {
	    this.traverseLevel(this.methodPath.get("value"), true);
	  };
	
	  /**
	   * Description
	   */
	
	  ReplaceSupers.prototype.traverseLevel = function traverseLevel(path, topLevel) {
	    var state = { self: this, topLevel: topLevel };
	    path.traverse(visitor, state);
	  };
	
	  /**
	   * Description
	   */
	
	  ReplaceSupers.prototype.getThisReference = function getThisReference() {
	    if (this.topLevelThisReference) {
	      return this.topLevelThisReference;
	    } else {
	      var ref = this.topLevelThisReference = this.scope.generateUidIdentifier("this");
	      this.methodNode.value.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(this.topLevelThisReference, t.thisExpression())]));
	      return ref;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  ReplaceSupers.prototype.getLooseSuperProperty = function getLooseSuperProperty(id, parent) {
	    var methodNode = this.methodNode;
	    var methodName = methodNode.key;
	    var superRef = this.superRef || t.identifier("Function");
	
	    if (parent.property === id) {
	      return;
	    } else if (t.isCallExpression(parent, { callee: id })) {
	      // super(); -> objectRef.prototype.MethodName.call(this);
	      parent.arguments.unshift(t.thisExpression());
	
	      if (methodName.name === "constructor") {
	        // constructor() { super(); }
	        return t.memberExpression(superRef, t.identifier("call"));
	      } else {
	        id = superRef;
	
	        // foo() { super(); }
	        if (!methodNode["static"]) {
	          id = t.memberExpression(id, t.identifier("prototype"));
	        }
	
	        id = t.memberExpression(id, methodName, methodNode.computed);
	        return t.memberExpression(id, t.identifier("call"));
	      }
	    } else if (t.isMemberExpression(parent) && !methodNode["static"]) {
	      // super.test -> objectRef.prototype.test
	      return t.memberExpression(superRef, t.identifier("prototype"));
	    } else {
	      return superRef;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  ReplaceSupers.prototype.looseHandle = function looseHandle(path, getThisReference) {
	    var node = path.node;
	    if (path.isSuper()) {
	      return this.getLooseSuperProperty(node, path.parent);
	    } else if (path.isCallExpression()) {
	      var callee = node.callee;
	      if (!t.isMemberExpression(callee)) return;
	      if (!t.isSuper(callee.object)) return;
	
	      // super.test(); -> objectRef.prototype.MethodName.call(this);
	      t.appendToMemberExpression(callee, t.identifier("call"));
	      node.arguments.unshift(getThisReference());
	      return true;
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  ReplaceSupers.prototype.specHandleAssignmentExpression = function specHandleAssignmentExpression(ref, path, node, getThisReference) {
	    if (node.operator === "=") {
	      // super.name = "val"; -> _set(Object.getPrototypeOf(objectRef.prototype), "name", this);
	      return this.setSuperProperty(node.left.property, node.right, node.left.computed, getThisReference());
	    } else {
	      // super.age += 2; -> var _ref = super.age; super.age = _ref + 2;
	      ref = ref || path.scope.generateUidIdentifier("ref");
	      return [t.variableDeclaration("var", [t.variableDeclarator(ref, node.left)]), t.expressionStatement(t.assignmentExpression("=", node.left, t.binaryExpression(node.operator[0], ref, node.right)))];
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  ReplaceSupers.prototype.specHandle = function specHandle(path, getThisReference) {
	    var methodNode = this.methodNode;
	    var property;
	    var computed;
	    var args;
	    var thisReference;
	
	    var parent = path.parent;
	    var node = path.node;
	
	    if (isIllegalBareSuper(node, parent)) {
	      throw path.errorWithNode(messages.get("classesIllegalBareSuper"));
	    }
	
	    if (t.isCallExpression(node)) {
	      var callee = node.callee;
	      if (t.isSuper(callee)) {
	        // super(); -> _get(Object.getPrototypeOf(objectRef), "MethodName", this).call(this);
	        property = methodNode.key;
	        computed = methodNode.computed;
	        args = node.arguments;
	
	        // bare `super` call is illegal inside non-constructors
	        //  - https://esdiscuss.org/topic/super-call-in-methods
	        //  - https://twitter.com/wycats/status/544553184396836864
	        if (methodNode.key.name !== "constructor" || !this.inClass) {
	          var methodName = methodNode.key.name || "METHOD_NAME";
	          throw this.file.errorWithNode(node, messages.get("classesIllegalSuperCall", methodName));
	        }
	      } else if (isMemberExpressionSuper(callee)) {
	        // super.test(); -> _get(Object.getPrototypeOf(objectRef.prototype), "test", this).call(this);
	        property = callee.property;
	        computed = callee.computed;
	        args = node.arguments;
	      }
	    } else if (t.isMemberExpression(node) && t.isSuper(node.object)) {
	      // super.name; -> _get(Object.getPrototypeOf(objectRef.prototype), "name", this);
	      property = node.property;
	      computed = node.computed;
	    } else if (t.isUpdateExpression(node) && isMemberExpressionSuper(node.argument)) {
	      var binary = t.binaryExpression(node.operator[0], node.argument, t.literal(1));
	      if (node.prefix) {
	        // ++super.foo; -> super.foo += 1;
	        return this.specHandleAssignmentExpression(null, path, binary, getThisReference);
	      } else {
	        // super.foo++; -> var _ref = super.foo; super.foo = _ref + 1;
	        var ref = path.scope.generateUidIdentifier("ref");
	        return this.specHandleAssignmentExpression(ref, path, binary, getThisReference).concat(t.expressionStatement(ref));
	      }
	    } else if (t.isAssignmentExpression(node) && isMemberExpressionSuper(node.left)) {
	      return this.specHandleAssignmentExpression(null, path, node, getThisReference);
	    }
	
	    if (!property) return;
	
	    thisReference = getThisReference();
	    var superProperty = this.getSuperProperty(property, computed, thisReference);
	    if (args) {
	      if (args.length === 1 && t.isSpreadElement(args[0])) {
	        // super(...arguments);
	        return t.callExpression(t.memberExpression(superProperty, t.identifier("apply")), [thisReference, args[0].argument]);
	      } else {
	        return t.callExpression(t.memberExpression(superProperty, t.identifier("call")), [thisReference].concat(args));
	      }
	    } else {
	      return superProperty;
	    }
	  };
	
	  return ReplaceSupers;
	})();
	
	exports["default"] = ReplaceSupers;
	module.exports = exports["default"];

/***/ },
/* 302 */
/*!****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/async-to-generator.js ***!
  \****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Func /*tion*/ = Func;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersRemapAsyncToGenerator = __webpack_require__(/*! ../../helpers/remap-async-to-generator */ 303);
	
	var _helpersRemapAsyncToGenerator2 = _interopRequireDefault(_helpersRemapAsyncToGenerator);
	
	var _bluebirdCoroutines = __webpack_require__(/*! ./bluebird-coroutines */ 304);
	
	exports.manipulateOptions = _bluebirdCoroutines.manipulateOptions;
	var metadata = {
	  optional: true,
	  dependencies: ["es7.asyncFunctions", "es6.classes"]
	};
	
	exports.metadata = metadata;
	
	function Func(node, parent, scope, file) {
	  if (!node.async || node.generator) return;
	
	  return (0, _helpersRemapAsyncToGenerator2["default"])(node, file.addHelper("async-to-generator"), scope);
	}

/***/ },
/* 303 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/remap-async-to-generator.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var awaitVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (t.isFunction(node)) this.skip();
	
	    if (t.isAwaitExpression(node)) {
	      node.type = "YieldExpression";
	
	      if (node.all) {
	        // await* foo; -> yield Promise.all(foo);
	        node.all = false;
	        node.argument = t.callExpression(t.memberExpression(t.identifier("Promise"), t.identifier("all")), [node.argument]);
	      }
	    }
	  }
	};
	
	var referenceVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    var name = state.id.name;
	    if (this.isReferencedIdentifier({ name: name }) && scope.bindingIdentifierEquals(name, state.id)) {
	      return state.ref = state.ref || scope.generateUidIdentifier(name);
	    }
	  }
	};
	
	exports["default"] = function (node, callId, scope) {
	  node.async = false;
	  node.generator = true;
	
	  scope.traverse(node, awaitVisitor, state);
	
	  var call = t.callExpression(callId, [node]);
	
	  var id = node.id;
	  node.id = null;
	
	  if (t.isFunctionDeclaration(node)) {
	    var declar = t.variableDeclaration("let", [t.variableDeclarator(id, call)]);
	    declar._blockHoist = true;
	    return declar;
	  } else {
	    if (id) {
	      var state = { id: id };
	      scope.traverse(node, referenceVisitor, state);
	
	      if (state.ref) {
	        scope.parent.push({ id: state.ref });
	        return t.assignmentExpression("=", state.ref, call);
	      }
	    }
	
	    return call;
	  }
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 304 */
/*!*****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/bluebird-coroutines.js ***!
  \*****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.manipulateOptions = manipulateOptions;
	exports.Func /*tion*/ = Func;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersRemapAsyncToGenerator = __webpack_require__(/*! ../../helpers/remap-async-to-generator */ 303);
	
	var _helpersRemapAsyncToGenerator2 = _interopRequireDefault(_helpersRemapAsyncToGenerator);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function manipulateOptions(opts) {
	  opts.blacklist.push("regenerator");
	}
	
	var metadata = {
	  optional: true,
	  dependencies: ["es7.asyncFunctions", "es6.classes"]
	};
	
	exports.metadata = metadata;
	
	function Func(node, parent, scope, file) {
	  if (!node.async || node.generator) return;
	
	  return (0, _helpersRemapAsyncToGenerator2["default"])(node, t.memberExpression(file.addImport("bluebird", null, "absolute"), t.identifier("coroutine")), scope);
	}

/***/ },
/* 305 */
/*!********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/object-super.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ObjectExpression = ObjectExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersReplaceSupers = __webpack_require__(/*! ../../helpers/replace-supers */ 301);
	
	var _helpersReplaceSupers2 = _interopRequireDefault(_helpersReplaceSupers);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function Property(path, node, scope, getObjectRef, file) {
	  if (!node.method && node.kind === "init") return;
	  if (!t.isFunction(node.value)) return;
	
	  var replaceSupers = new _helpersReplaceSupers2["default"]({
	    getObjectRef: getObjectRef,
	    methodNode: node,
	    methodPath: path,
	    isStatic: true,
	    scope: scope,
	    file: file
	  });
	
	  replaceSupers.replace();
	}
	
	function ObjectExpression(node, parent, scope, file) {
	  var objectRef;
	  var getObjectRef = function getObjectRef() {
	    return objectRef = objectRef || scope.generateUidIdentifier("obj");
	  };
	
	  var propPaths = this.get("properties");
	  for (var i = 0; i < node.properties.length; i++) {
	    Property(propPaths[i], node.properties[i], scope, getObjectRef, file);
	  }
	
	  if (objectRef) {
	    scope.push({ id: objectRef });
	    return t.assignmentExpression("=", objectRef, node);
	  }
	}

/***/ },
/* 306 */
/*!**************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/object-rest-spread.js ***!
  \**************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/sebmarkbage/ecmascript-rest-spread
	
	"use strict";
	
	exports.__esModule = true;
	exports.ObjectExpression = ObjectExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  stage: 1,
	  dependencies: ["es6.destructuring"]
	};
	
	exports.metadata = metadata;
	var hasSpread = function hasSpread(node) {
	  for (var i = 0; i < node.properties.length; i++) {
	    if (t.isSpreadProperty(node.properties[i])) {
	      return true;
	    }
	  }
	  return false;
	};
	
	function ObjectExpression(node, parent, scope, file) {
	  if (!hasSpread(node)) return;
	
	  var args = [];
	  var props = [];
	
	  var push = function push() {
	    if (!props.length) return;
	    args.push(t.objectExpression(props));
	    props = [];
	  };
	
	  for (var i = 0; i < node.properties.length; i++) {
	    var prop = node.properties[i];
	    if (t.isSpreadProperty(prop)) {
	      push();
	      args.push(prop.argument);
	    } else {
	      props.push(prop);
	    }
	  }
	
	  push();
	
	  if (!t.isObjectExpression(args[0])) {
	    args.unshift(t.objectExpression([]));
	  }
	
	  return t.callExpression(file.addHelper("extends"), args);
	}

/***/ },
/* 307 */
/*!*******************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/exponentiation-operator.js ***!
  \*******************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/exponentiation-operator
	
	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersBuildBinaryAssignmentOperatorTransformer = __webpack_require__(/*! ../../helpers/build-binary-assignment-operator-transformer */ 308);
	
	var _helpersBuildBinaryAssignmentOperatorTransformer2 = _interopRequireDefault(_helpersBuildBinaryAssignmentOperatorTransformer);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  stage: 2
	};
	
	exports.metadata = metadata;
	var MATH_POW = t.memberExpression(t.identifier("Math"), t.identifier("pow"));
	
	var _build = (0, _helpersBuildBinaryAssignmentOperatorTransformer2["default"])({
	  operator: "**",
	
	  build: function build(left, right) {
	    return t.callExpression(MATH_POW, [left, right]);
	  }
	});
	
	var ExpressionStatement = _build.ExpressionStatement;
	var AssignmentExpression = _build.AssignmentExpression;
	var BinaryExpression = _build.BinaryExpression;
	exports.ExpressionStatement = ExpressionStatement;
	exports.AssignmentExpression = AssignmentExpression;
	exports.BinaryExpression = BinaryExpression;

/***/ },
/* 308 */
/*!*******************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/build-binary-assignment-operator-transformer.js ***!
  \*******************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _explodeAssignableExpression = __webpack_require__(/*! ./explode-assignable-expression */ 309);
	
	var _explodeAssignableExpression2 = _interopRequireDefault(_explodeAssignableExpression);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	exports["default"] = function (opts) {
	  var exports = {};
	
	  var isAssignment = function isAssignment(node) {
	    return node.operator === opts.operator + "=";
	  };
	
	  var buildAssignment = function buildAssignment(left, right) {
	    return t.assignmentExpression("=", left, right);
	  };
	
	  exports.ExpressionStatement = function (node, parent, scope, file) {
	    // hit the `AssignmentExpression` one below
	    if (this.isCompletionRecord()) return;
	
	    var expr = node.expression;
	    if (!isAssignment(expr)) return;
	
	    var nodes = [];
	    var exploded = (0, _explodeAssignableExpression2["default"])(expr.left, nodes, file, scope, true);
	
	    nodes.push(t.expressionStatement(buildAssignment(exploded.ref, opts.build(exploded.uid, expr.right))));
	
	    return nodes;
	  };
	
	  exports.AssignmentExpression = function (node, parent, scope, file) {
	    if (!isAssignment(node)) return;
	
	    var nodes = [];
	    var exploded = (0, _explodeAssignableExpression2["default"])(node.left, nodes, file, scope);
	    nodes.push(buildAssignment(exploded.ref, opts.build(exploded.uid, node.right)));
	    return nodes;
	  };
	
	  exports.BinaryExpression = function (node) {
	    if (node.operator !== opts.operator) return;
	    return opts.build(node.left, node.right);
	  };
	
	  return exports;
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 309 */
/*!****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/explode-assignable-expression.js ***!
  \****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var getObjRef = function getObjRef(node, nodes, file, scope) {
	  var ref;
	  if (t.isIdentifier(node)) {
	    if (scope.hasBinding(node.name)) {
	      // this variable is declared in scope so we can be 100% sure
	      // that evaluating it multiple times wont trigger a getter
	      // or something else
	      return node;
	    } else {
	      // could possibly trigger a getter so we need to only evaluate
	      // it once
	      ref = node;
	    }
	  } else if (t.isMemberExpression(node)) {
	    ref = node.object;
	
	    if (t.isIdentifier(ref) && scope.hasGlobal(ref.name)) {
	      // the object reference that we need to save is locally declared
	      // so as per the previous comment we can be 100% sure evaluating
	      // it multiple times will be safe
	      return ref;
	    }
	  } else {
	    throw new Error("We can't explode this node type " + node.type);
	  }
	
	  var temp = scope.generateUidIdentifierBasedOnNode(ref);
	  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(temp, ref)]));
	  return temp;
	};
	
	var getPropRef = function getPropRef(node, nodes, file, scope) {
	  var prop = node.property;
	  var key = t.toComputedKey(node, prop);
	  if (t.isLiteral(key)) return key;
	
	  var temp = scope.generateUidIdentifierBasedOnNode(prop);
	  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(temp, prop)]));
	  return temp;
	};
	
	exports["default"] = function (node, nodes, file, scope, allowedSingleIdent) {
	  var obj;
	  if (t.isIdentifier(node) && allowedSingleIdent) {
	    obj = node;
	  } else {
	    obj = getObjRef(node, nodes, file, scope);
	  }
	
	  var ref, uid;
	
	  if (t.isIdentifier(node)) {
	    ref = node;
	    uid = obj;
	  } else {
	    var prop = getPropRef(node, nodes, file, scope);
	    var computed = node.computed || t.isLiteral(prop);
	    uid = ref = t.memberExpression(obj, prop, computed);
	  }
	
	  return {
	    uid: uid,
	    ref: ref
	  };
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 310 */
/*!******************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/spec.template-literals.js ***!
  \******************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.TemplateLiteral = TemplateLiteral;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true
	};
	
	exports.metadata = metadata;
	
	function TemplateLiteral(node, parent, scope, file) {
	  if (t.isTaggedTemplateExpression(parent)) return;
	
	  for (var i = 0; i < node.expressions.length; i++) {
	    node.expressions[i] = t.callExpression(t.identifier("String"), [node.expressions[i]]);
	  }
	}

/***/ },
/* 311 */
/*!*************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/template-literals.js ***!
  \*************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	exports.TemplateLiteral = TemplateLiteral;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var buildBinaryExpression = function buildBinaryExpression(left, right) {
	  return t.binaryExpression("+", left, right);
	};
	
	function TaggedTemplateExpression(node, parent, scope, file) {
	  var quasi = node.quasi;
	  var args = [];
	
	  var strings = [];
	  var raw = [];
	
	  for (var i = 0; i < quasi.quasis.length; i++) {
	    var elem = quasi.quasis[i];
	    strings.push(t.literal(elem.value.cooked));
	    raw.push(t.literal(elem.value.raw));
	  }
	
	  strings = t.arrayExpression(strings);
	  raw = t.arrayExpression(raw);
	
	  var templateName = "tagged-template-literal";
	  if (file.isLoose("es6.templateLiterals")) templateName += "-loose";
	  args.push(t.callExpression(file.addHelper(templateName), [strings, raw]));
	
	  args = args.concat(quasi.expressions);
	
	  return t.callExpression(node.tag, args);
	}
	
	function TemplateLiteral(node, parent, scope, file) {
	  var nodes = [];
	  var i;
	
	  for (i = 0; i < node.quasis.length; i++) {
	    var elem = node.quasis[i];
	
	    nodes.push(t.literal(elem.value.cooked));
	
	    var expr = node.expressions.shift();
	    if (expr) nodes.push(expr);
	  }
	
	  if (nodes.length > 1) {
	    // remove redundant '' at the end of the expression
	    var last = nodes[nodes.length - 1];
	    if (t.isLiteral(last, { value: "" })) nodes.pop();
	
	    var root = buildBinaryExpression(nodes.shift(), nodes.shift());
	
	    for (i = 0; i < nodes.length; i++) {
	      root = buildBinaryExpression(root, nodes[i]);
	    }
	
	    return root;
	  } else {
	    return nodes[0];
	  }
	}

/***/ },
/* 312 */
/*!***************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es5/properties.mutators.js ***!
  \***************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ObjectExpression = ObjectExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _helpersDefineMap = __webpack_require__(/*! ../../helpers/define-map */ 290);
	
	var defineMap = _interopRequireWildcard(_helpersDefineMap);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function ObjectExpression(node, parent, scope, file) {
	  var mutatorMap = {};
	  var hasAny = false;
	
	  node.properties = node.properties.filter(function (prop) {
	    if (prop.kind === "get" || prop.kind === "set") {
	      hasAny = true;
	      defineMap.push(mutatorMap, prop, prop.kind, file);
	      return false;
	    } else {
	      return true;
	    }
	  });
	
	  if (!hasAny) return;
	
	  return t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("defineProperties")), [node, defineMap.toDefineObject(mutatorMap)]);
	}

/***/ },
/* 313 */
/*!****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/properties.shorthand.js ***!
  \****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Property = Property;
	
	function Property(node) {
	  if (node.method) {
	    node.method = false;
	  }
	
	  if (node.shorthand) {
	    node.shorthand = false;
	  }
	}

/***/ },
/* 314 */
/*!***************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/properties.computed.js ***!
  \***************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function loose(node, body, objId) {
	  for (var i = 0; i < node.properties.length; i++) {
	    var prop = node.properties[i];
	
	    body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(objId, prop.key, prop.computed || t.isLiteral(prop.key)), prop.value)));
	  }
	}
	
	function spec(node, body, objId, initProps, file) {
	  var props = node.properties;
	
	  // add all non-computed properties and `__proto__` properties to the initializer
	
	  var broken = false;
	
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	
	    if (prop.computed) {
	      broken = true;
	    }
	
	    if (prop.kind !== "init" || !broken || t.isLiteral(t.toComputedKey(prop, prop.key), { value: "__proto__" })) {
	      initProps.push(prop);
	      props[i] = null;
	    }
	  }
	
	  // add a simple assignment for all Symbol member expressions due to symbol polyfill limitations
	  // otherwise use Object.defineProperty
	
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    if (!prop) continue;
	
	    var key = prop.key;
	    if (t.isIdentifier(key) && !prop.computed) {
	      key = t.literal(key.name);
	    }
	
	    var bodyNode = t.callExpression(file.addHelper("define-property"), [objId, key, prop.value]);
	
	    body.push(t.expressionStatement(bodyNode));
	  }
	
	  // only one node and it's a Object.defineProperty that returns the object
	
	  if (body.length === 1) {
	    var first = body[0].expression;
	
	    if (t.isCallExpression(first)) {
	      first.arguments[0] = t.objectExpression(initProps);
	      return first;
	    }
	  }
	}
	
	var ObjectExpression = {
	  exit: function exit(node, parent, scope, file) {
	    var hasComputed = false;
	
	    var _arr = node.properties;
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var prop = _arr[_i];
	      hasComputed = t.isProperty(prop, { computed: true, kind: "init" });
	      if (hasComputed) break;
	    }
	
	    if (!hasComputed) return;
	
	    var initProps = [];
	    var objId = scope.generateUidIdentifierBasedOnNode(parent);
	
	    //
	
	    var body = [];
	
	    //
	
	    var callback = spec;
	    if (file.isLoose("es6.properties.computed")) callback = loose;
	
	    var result = callback(node, body, objId, initProps, file);
	    if (result) return result;
	
	    //
	
	    body.unshift(t.variableDeclaration("var", [t.variableDeclarator(objId, t.objectExpression(initProps))]));
	
	    body.push(t.expressionStatement(objId));
	
	    return body;
	  }
	};
	exports.ObjectExpression = ObjectExpression;

/***/ },
/* 315 */
/*!****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/optimisation/flow.for-of.js ***!
  \****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ForOfStatement = ForOfStatement;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _es6ForOf = __webpack_require__(/*! ../es6/for-of */ 316);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true
	};
	
	exports.metadata = metadata;
	
	function ForOfStatement(node, parent, scope, file) {
	  if (this.get("right").isTypeGeneric("Array")) {
	    return _es6ForOf._ForOfStatementArray.call(this, node, scope, file);
	  }
	}

/***/ },
/* 316 */
/*!**************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/for-of.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ForOfStatement = ForOfStatement;
	exports._ForOfStatementArray = _ForOfStatementArray;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _util = __webpack_require__(/*! ../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function ForOfStatement(node, parent, scope, file) {
	  if (this.get("right").isArrayExpression()) {
	    return _ForOfStatementArray.call(this, node, scope, file);
	  }
	
	  var callback = spec;
	  if (file.isLoose("es6.forOf")) callback = loose;
	
	  var build = callback(node, parent, scope, file);
	  var declar = build.declar;
	  var loop = build.loop;
	  var block = loop.body;
	
	  // ensure that it's a block so we can take all its statements
	  t.ensureBlock(node);
	
	  // add the value declaration to the new loop body
	  if (declar) {
	    block.body.push(declar);
	  }
	
	  // push the rest of the original loop body onto our new body
	  block.body = block.body.concat(node.body.body);
	
	  t.inherits(loop, node);
	  t.inherits(loop.body, node.body);
	
	  if (build.replaceParent) {
	    this.parentPath.replaceWithMultiple(build.node);
	    this.remove();
	  } else {
	    return build.node;
	  }
	}
	
	function _ForOfStatementArray(node, scope, file) {
	  var nodes = [];
	  var right = node.right;
	
	  if (!t.isIdentifier(right) || !scope.hasBinding(right.name)) {
	    var uid = scope.generateUidIdentifier("arr");
	    nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, right)]));
	    right = uid;
	  }
	
	  var iterationKey = scope.generateUidIdentifier("i");
	
	  var loop = util.template("for-of-array", {
	    BODY: node.body,
	    KEY: iterationKey,
	    ARR: right
	  });
	
	  t.inherits(loop, node);
	  t.ensureBlock(loop);
	
	  var iterationValue = t.memberExpression(right, iterationKey, true);
	
	  var left = node.left;
	  if (t.isVariableDeclaration(left)) {
	    left.declarations[0].init = iterationValue;
	    loop.body.body.unshift(left);
	  } else {
	    loop.body.body.unshift(t.expressionStatement(t.assignmentExpression("=", left, iterationValue)));
	  }
	
	  nodes.push(loop);
	
	  return nodes;
	}
	
	var loose = function loose(node, parent, scope, file) {
	  var left = node.left;
	  var declar, id;
	
	  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {
	    // for (i of test), for ({ i } of test)
	    id = left;
	  } else if (t.isVariableDeclaration(left)) {
	    // for (var i of test)
	    id = scope.generateUidIdentifier("ref");
	    declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, id)]);
	  } else {
	    throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
	  }
	
	  var iteratorKey = scope.generateUidIdentifier("iterator");
	  var isArrayKey = scope.generateUidIdentifier("isArray");
	
	  var loop = util.template("for-of-loose", {
	    LOOP_OBJECT: iteratorKey,
	    IS_ARRAY: isArrayKey,
	    OBJECT: node.right,
	    INDEX: scope.generateUidIdentifier("i"),
	    ID: id
	  });
	
	  if (!declar) {
	    // no declaration so we need to remove the variable declaration at the top of
	    // the for-of-loose template
	    loop.body.body.shift();
	  }
	
	  //
	
	  return {
	    declar: declar,
	    node: loop,
	    loop: loop
	  };
	};
	
	var spec = function spec(node, parent, scope, file) {
	  var left = node.left;
	  var declar;
	
	  var stepKey = scope.generateUidIdentifier("step");
	  var stepValue = t.memberExpression(stepKey, t.identifier("value"));
	
	  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {
	    // for (i of test), for ({ i } of test)
	    declar = t.expressionStatement(t.assignmentExpression("=", left, stepValue));
	  } else if (t.isVariableDeclaration(left)) {
	    // for (var i of test)
	    declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, stepValue)]);
	  } else {
	    throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
	  }
	
	  //
	
	  var iteratorKey = scope.generateUidIdentifier("iterator");
	
	  var template = util.template("for-of", {
	    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
	    ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
	    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
	    ITERATOR_KEY: iteratorKey,
	    STEP_KEY: stepKey,
	    OBJECT: node.right,
	    BODY: null
	  });
	
	  var isLabeledParent = t.isLabeledStatement(parent);
	
	  var tryBody = template[3].block.body;
	  var loop = tryBody[0];
	
	  if (isLabeledParent) {
	    tryBody[0] = t.labeledStatement(parent.label, loop);
	  }
	
	  //
	
	  return {
	    replaceParent: isLabeledParent,
	    declar: declar,
	    loop: loop,
	    node: template
	  };
	};

/***/ },
/* 317 */
/*!********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/regex.sticky.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Literal = Literal;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _helpersRegex = __webpack_require__(/*! ../../helpers/regex */ 318);
	
	var regex = _interopRequireWildcard(_helpersRegex);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function Literal(node) {
	  if (!regex.is(node, "y")) return;
	  return t.newExpression(t.identifier("RegExp"), [t.literal(node.regex.pattern), t.literal(node.regex.flags)]);
	}

/***/ },
/* 318 */
/*!****************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/regex.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.is = is;
	exports.pullFlag = pullFlag;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashArrayPull = __webpack_require__(/*! lodash/array/pull */ 319);
	
	var _lodashArrayPull2 = _interopRequireDefault(_lodashArrayPull);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function is(node, flag) {
	  return t.isLiteral(node) && node.regex && node.regex.flags.indexOf(flag) >= 0;
	}
	
	function pullFlag(node, flag) {
	  var flags = node.regex.flags.split("");
	  if (node.regex.flags.indexOf(flag) < 0) return;
	  (0, _lodashArrayPull2["default"])(flags, flag);
	  node.regex.flags = flags.join("");
	}

/***/ },
/* 319 */
/*!*********************************************!*\
  !*** ./~/babel-core/~/lodash/array/pull.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(/*! ../internal/baseIndexOf */ 146);
	
	/** Used for native method references. */
	var arrayProto = Array.prototype;
	
	/** Native method references. */
	var splice = arrayProto.splice;
	
	/**
	 * Removes all provided values from `array` using
	 * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * **Note:** Unlike `_.without`, this method mutates `array`.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {...*} [values] The values to remove.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = [1, 2, 3, 1, 2, 3];
	 *
	 * _.pull(array, 2, 3);
	 * console.log(array);
	 * // => [1, 1]
	 */
	function pull() {
	  var args = arguments,
	      array = args[0];
	
	  if (!(array && array.length)) {
	    return array;
	  }
	  var index = 0,
	      indexOf = baseIndexOf,
	      length = args.length;
	
	  while (++index < length) {
	    var fromIndex = 0,
	        value = args[index];
	
	    while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	      splice.call(array, fromIndex, 1);
	    }
	  }
	  return array;
	}
	
	module.exports = pull;


/***/ },
/* 320 */
/*!*********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/regex.unicode.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Literal = Literal;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _regexpuRewritePattern = __webpack_require__(/*! regexpu/rewrite-pattern */ 321);
	
	var _regexpuRewritePattern2 = _interopRequireDefault(_regexpuRewritePattern);
	
	var _helpersRegex = __webpack_require__(/*! ../../helpers/regex */ 318);
	
	var regex = _interopRequireWildcard(_helpersRegex);
	
	function Literal(node) {
	  if (!regex.is(node, "u")) return;
	  node.regex.pattern = (0, _regexpuRewritePattern2["default"])(node.regex.pattern, node.regex.flags);
	  regex.pullFlag(node, "u");
	}

/***/ },
/* 321 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/regexpu/rewrite-pattern.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var generate = __webpack_require__(/*! regjsgen */ 322).generate;
	var parse = __webpack_require__(/*! regjsparser */ 323).parse;
	var regenerate = __webpack_require__(/*! regenerate */ 324);
	var iuMappings = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./data/iu-mappings.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var ESCAPE_SETS = __webpack_require__(/*! ./data/character-class-escape-sets.js */ 326);
	
	function getCharacterClassEscapeSet(character) {
		if (unicode) {
			if (ignoreCase) {
				return ESCAPE_SETS.UNICODE_IGNORE_CASE[character];
			}
			return ESCAPE_SETS.UNICODE[character];
		}
		return ESCAPE_SETS.REGULAR[character];
	}
	
	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	function has(object, property) {
		return hasOwnProperty.call(object, property);
	}
	
	// Prepare a Regenerate set containing all code points, used for negative
	// character classes (if any).
	var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
	// Without the `u` flag, the range stops at 0xFFFF.
	// https://mths.be/es6#sec-pattern-semantics
	var BMP_SET = regenerate().addRange(0x0, 0xFFFF);
	
	// Prepare a Regenerate set containing all code points that are supposed to be
	// matched by `/./u`. https://mths.be/es6#sec-atom
	var DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points
		.remove(
			// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
			0x000A, // Line Feed <LF>
			0x000D, // Carriage Return <CR>
			0x2028, // Line Separator <LS>
			0x2029  // Paragraph Separator <PS>
		);
	// Prepare a Regenerate set containing all code points that are supposed to be
	// matched by `/./` (only BMP code points).
	var DOT_SET = DOT_SET_UNICODE.clone()
		.intersection(BMP_SET);
	
	// Add a range of code points + any case-folded code points in that range to a
	// set.
	regenerate.prototype.iuAddRange = function(min, max) {
		var $this = this;
		do {
			var folded = caseFold(min);
			if (folded) {
				$this.add(folded);
			}
		} while (++min <= max);
		return $this;
	};
	
	function assign(target, source) {
		for (var key in source) {
			// Note: `hasOwnProperty` is not needed here.
			target[key] = source[key];
		}
	}
	
	function update(item, pattern) {
		// TODO: Test if memoizing `pattern` here is worth the effort.
		if (!pattern) {
			return;
		}
		var tree = parse(pattern, '');
		switch (tree.type) {
			case 'characterClass':
			case 'group':
			case 'value':
				// No wrapping needed.
				break;
			default:
				// Wrap the pattern in a non-capturing group.
				tree = wrap(tree, pattern);
		}
		assign(item, tree);
	}
	
	function wrap(tree, pattern) {
		// Wrap the pattern in a non-capturing group.
		return {
			'type': 'group',
			'behavior': 'ignore',
			'body': [tree],
			'raw': '(?:' + pattern + ')'
		};
	}
	
	function caseFold(codePoint) {
		return has(iuMappings, codePoint) ? iuMappings[codePoint] : false;
	}
	
	var ignoreCase = false;
	var unicode = false;
	function processCharacterClass(characterClassItem) {
		var set = regenerate();
		var body = characterClassItem.body.forEach(function(item) {
			switch (item.type) {
				case 'value':
					set.add(item.codePoint);
					if (ignoreCase && unicode) {
						var folded = caseFold(item.codePoint);
						if (folded) {
							set.add(folded);
						}
					}
					break;
				case 'characterClassRange':
					var min = item.min.codePoint;
					var max = item.max.codePoint;
					set.addRange(min, max);
					if (ignoreCase && unicode) {
						set.iuAddRange(min, max);
					}
					break;
				case 'characterClassEscape':
					set.add(getCharacterClassEscapeSet(item.value));
					break;
				// The `default` clause is only here as a safeguard; it should never be
				// reached. Code coverage tools should ignore it.
				/* istanbul ignore next */
				default:
					throw Error('Unknown term type: ' + item.type);
			}
		});
		if (characterClassItem.negative) {
			set = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
		}
		update(characterClassItem, set.toString());
		return characterClassItem;
	}
	
	function processTerm(item) {
		switch (item.type) {
			case 'dot':
				update(
					item,
					(unicode ? DOT_SET_UNICODE : DOT_SET).toString()
				);
				break;
			case 'characterClass':
				item = processCharacterClass(item);
				break;
			case 'characterClassEscape':
				update(
					item,
					getCharacterClassEscapeSet(item.value).toString()
				);
				break;
			case 'alternative':
			case 'disjunction':
			case 'group':
			case 'quantifier':
				item.body = item.body.map(processTerm);
				break;
			case 'value':
				var codePoint = item.codePoint;
				var set = regenerate(codePoint);
				if (ignoreCase && unicode) {
					var folded = caseFold(codePoint);
					if (folded) {
						set.add(folded);
					}
				}
				update(item, set.toString());
				break;
			case 'anchor':
			case 'empty':
			case 'group':
			case 'reference':
				// Nothing to do here.
				break;
			// The `default` clause is only here as a safeguard; it should never be
			// reached. Code coverage tools should ignore it.
			/* istanbul ignore next */
			default:
				throw Error('Unknown term type: ' + item.type);
		}
		return item;
	};
	
	module.exports = function(pattern, flags) {
		var tree = parse(pattern, flags);
		ignoreCase = flags ? flags.indexOf('i') > -1 : false;
		unicode = flags ? flags.indexOf('u') > -1 : false;
		assign(tree, processTerm(tree));
		return generate(tree);
	};


/***/ },
/* 322 */
/*!***************************!*\
  !*** external "regjsgen" ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("regjsgen");

/***/ },
/* 323 */
/*!******************************!*\
  !*** external "regjsparser" ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("regjsparser");

/***/ },
/* 324 */
/*!*****************************!*\
  !*** external "regenerate" ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("regenerate");

/***/ },
/* 325 */,
/* 326 */
/*!********************************************************************!*\
  !*** ./~/babel-core/~/regexpu/data/character-class-escape-sets.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Generated by `/scripts/character-class-escape-sets.js`. Do not edit.
	var regenerate = __webpack_require__(/*! regenerate */ 324);
	
	exports.REGULAR = {
		'd': regenerate()
			.addRange(0x30, 0x39),
		'D': regenerate()
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0xFFFF),
		's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
			.addRange(0x9, 0xD)
			.addRange(0x2000, 0x200A)
			.addRange(0x2028, 0x2029),
		'S': regenerate()
			.addRange(0x0, 0x8)
			.addRange(0xE, 0x1F)
			.addRange(0x21, 0x9F)
			.addRange(0xA1, 0x167F)
			.addRange(0x1681, 0x180D)
			.addRange(0x180F, 0x1FFF)
			.addRange(0x200B, 0x2027)
			.addRange(0x202A, 0x202E)
			.addRange(0x2030, 0x205E)
			.addRange(0x2060, 0x2FFF)
			.addRange(0x3001, 0xFEFE)
			.addRange(0xFF00, 0xFFFF),
		'w': regenerate(0x5F)
			.addRange(0x30, 0x39)
			.addRange(0x41, 0x5A)
			.addRange(0x61, 0x7A),
		'W': regenerate(0x60)
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x40)
			.addRange(0x5B, 0x5E)
			.addRange(0x7B, 0xFFFF)
	};
	
	exports.UNICODE = {
		'd': regenerate()
			.addRange(0x30, 0x39),
		'D': regenerate()
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x10FFFF),
		's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
			.addRange(0x9, 0xD)
			.addRange(0x2000, 0x200A)
			.addRange(0x2028, 0x2029),
		'S': regenerate()
			.addRange(0x0, 0x8)
			.addRange(0xE, 0x1F)
			.addRange(0x21, 0x9F)
			.addRange(0xA1, 0x167F)
			.addRange(0x1681, 0x180D)
			.addRange(0x180F, 0x1FFF)
			.addRange(0x200B, 0x2027)
			.addRange(0x202A, 0x202E)
			.addRange(0x2030, 0x205E)
			.addRange(0x2060, 0x2FFF)
			.addRange(0x3001, 0xFEFE)
			.addRange(0xFF00, 0x10FFFF),
		'w': regenerate(0x5F)
			.addRange(0x30, 0x39)
			.addRange(0x41, 0x5A)
			.addRange(0x61, 0x7A),
		'W': regenerate(0x60)
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x40)
			.addRange(0x5B, 0x5E)
			.addRange(0x7B, 0x10FFFF)
	};
	
	exports.UNICODE_IGNORE_CASE = {
		'd': regenerate()
			.addRange(0x30, 0x39),
		'D': regenerate()
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x10FFFF),
		's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
			.addRange(0x9, 0xD)
			.addRange(0x2000, 0x200A)
			.addRange(0x2028, 0x2029),
		'S': regenerate()
			.addRange(0x0, 0x8)
			.addRange(0xE, 0x1F)
			.addRange(0x21, 0x9F)
			.addRange(0xA1, 0x167F)
			.addRange(0x1681, 0x180D)
			.addRange(0x180F, 0x1FFF)
			.addRange(0x200B, 0x2027)
			.addRange(0x202A, 0x202E)
			.addRange(0x2030, 0x205E)
			.addRange(0x2060, 0x2FFF)
			.addRange(0x3001, 0xFEFE)
			.addRange(0xFF00, 0x10FFFF),
		'w': regenerate(0x5F, 0x17F, 0x212A)
			.addRange(0x30, 0x39)
			.addRange(0x41, 0x5A)
			.addRange(0x61, 0x7A),
		'W': regenerate(0x4B, 0x53, 0x60)
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x40)
			.addRange(0x5B, 0x5E)
			.addRange(0x7B, 0x10FFFF)
	};


/***/ },
/* 327 */
/*!*****************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/constants.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.AssignmentExpression = AssignmentExpression;
	exports.VariableDeclaration = VariableDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function AssignmentExpression(node, parent, scope, file) {
	  var ids = this.getBindingIdentifiers();
	
	  for (var name in ids) {
	    var id = ids[name];
	
	    var binding = scope.getBinding(name);
	
	    // no binding exists
	    if (!binding) continue;
	
	    // not a constant
	    if (binding.kind !== "const" && binding.kind !== "module") continue;
	
	    // check if the assignment id matches the constant declaration id
	    // if it does then it was the id used to initially declare the
	    // constant so we can just ignore it
	    if (binding.identifier === id) continue;
	
	    throw file.errorWithNode(id, messages.get("readOnly", name));
	  }
	}
	
	exports.UpdateExpression = AssignmentExpression;
	
	function VariableDeclaration(node) {
	  if (node.kind === "const") node.kind = "let";
	}

/***/ },
/* 328 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/parameters.rest.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Func /*tion*/ = Func;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangIsNumber = __webpack_require__(/*! lodash/lang/isNumber */ 201);
	
	var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
	
	var _util = __webpack_require__(/*! ../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var memberExpressionOptimisationVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    // check if this scope has a local binding that will shadow the rest parameter
	    if (this.isScope() && !scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
	      return this.skip();
	    }
	
	    // skip over functions as whatever `arguments` we reference inside will refer
	    // to the wrong function
	    if (this.isFunctionDeclaration() || this.isFunctionExpression()) {
	      state.noOptimise = true;
	      this.traverse(memberExpressionOptimisationVisitor, state);
	      state.noOptimise = false;
	      return this.skip();
	    }
	
	    // is this a referenced identifier and is it referencing the rest parameter?
	    if (!this.isReferencedIdentifier({ name: state.name })) return;
	
	    if (!state.noOptimise && t.isMemberExpression(parent) && parent.computed) {
	      // if we know that this member expression is referencing a number then we can safely
	      // optimise it
	      var prop = parent.property;
	      if ((0, _lodashLangIsNumber2["default"])(prop.value) || t.isUnaryExpression(prop) || t.isBinaryExpression(prop)) {
	        state.candidates.push(this);
	        return;
	      }
	    }
	
	    state.canOptimise = false;
	    this.stop();
	  }
	};
	
	function optimizeMemberExpression(parent, offset) {
	  var newExpr;
	  var prop = parent.property;
	
	  if (t.isLiteral(prop)) {
	    prop.value += offset;
	    prop.raw = String(prop.value);
	  } else {
	    // // UnaryExpression, BinaryExpression
	    newExpr = t.binaryExpression("+", prop, t.literal(offset));
	    parent.property = newExpr;
	  }
	}
	
	var hasRest = function hasRest(node) {
	  return t.isRestElement(node.params[node.params.length - 1]);
	};
	
	function Func(node, parent, scope, file) {
	  if (!hasRest(node)) return;
	
	  var restParam = node.params.pop();
	  var rest = restParam.argument;
	
	  var argsId = t.identifier("arguments");
	
	  // otherwise `arguments` will be remapped in arrow functions
	  argsId._shadowedFunctionLiteral = true;
	
	  // support patterns
	  if (t.isPattern(rest)) {
	    var pattern = rest;
	    rest = scope.generateUidIdentifier("ref");
	
	    var declar = t.variableDeclaration("let", pattern.elements.map(function (elem, index) {
	      var accessExpr = t.memberExpression(rest, t.literal(index), true);
	      return t.variableDeclarator(elem, accessExpr);
	    }));
	    node.body.body.unshift(declar);
	  }
	
	  // check if rest is used in member expressions and optimise for those cases
	
	  var state = {
	    outerBinding: scope.getBindingIdentifier(rest.name),
	    canOptimise: true,
	    candidates: [],
	    method: node,
	    name: rest.name
	  };
	
	  this.traverse(memberExpressionOptimisationVisitor, state);
	
	  // we only have shorthands and there's no other references
	  if (state.canOptimise && state.candidates.length) {
	    for (var i = 0; i < state.candidates.length; i++) {
	      var candidate = state.candidates[i];
	      candidate.replaceWith(argsId);
	      optimizeMemberExpression(candidate.parent, node.params.length);
	    }
	    return;
	  }
	
	  //
	
	  var start = t.literal(node.params.length);
	  var key = scope.generateUidIdentifier("key");
	  var len = scope.generateUidIdentifier("len");
	
	  var arrKey = key;
	  var arrLen = len;
	  if (node.params.length) {
	    // this method has additional params, so we need to subtract
	    // the index of the current argument position from the
	    // position in the array that we want to populate
	    arrKey = t.binaryExpression("-", key, start);
	
	    // we need to work out the size of the array that we're
	    // going to store all the rest parameters
	    //
	    // we need to add a check to avoid constructing the array
	    // with <0 if there are less arguments than params as it'll
	    // cause an error
	    arrLen = t.conditionalExpression(t.binaryExpression(">", len, start), t.binaryExpression("-", len, start), t.literal(0));
	  }
	
	  var loop = util.template("rest", {
	    ARRAY_TYPE: restParam.typeAnnotation,
	    ARGUMENTS: argsId,
	    ARRAY_KEY: arrKey,
	    ARRAY_LEN: arrLen,
	    START: start,
	    ARRAY: rest,
	    KEY: key,
	    LEN: len
	  });
	  loop._blockHoist = node.params.length + 1;
	  node.body.body.unshift(loop);
	}

/***/ },
/* 329 */
/*!**************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/spread.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ArrayExpression = ArrayExpression;
	exports.CallExpression = CallExpression;
	exports.NewExpression = NewExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function getSpreadLiteral(spread, scope) {
	  if (scope.file.isLoose("es6.spread")) {
	    return spread.argument;
	  } else {
	    return scope.toArray(spread.argument, true);
	  }
	}
	
	function hasSpread(nodes) {
	  for (var i = 0; i < nodes.length; i++) {
	    if (t.isSpreadElement(nodes[i])) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function build(props, scope) {
	  var nodes = [];
	
	  var _props = [];
	
	  var push = function push() {
	    if (!_props.length) return;
	    nodes.push(t.arrayExpression(_props));
	    _props = [];
	  };
	
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    if (t.isSpreadElement(prop)) {
	      push();
	      nodes.push(getSpreadLiteral(prop, scope));
	    } else {
	      _props.push(prop);
	    }
	  }
	
	  push();
	
	  return nodes;
	}
	
	function ArrayExpression(node, parent, scope) {
	  var elements = node.elements;
	  if (!hasSpread(elements)) return;
	
	  var nodes = build(elements, scope);
	  var first = nodes.shift();
	
	  if (!t.isArrayExpression(first)) {
	    nodes.unshift(first);
	    first = t.arrayExpression([]);
	  }
	
	  return t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes);
	}
	
	function CallExpression(node, parent, scope) {
	  var args = node.arguments;
	  if (!hasSpread(args)) return;
	
	  var contextLiteral = t.identifier("undefined");
	
	  node.arguments = [];
	
	  var nodes;
	  if (args.length === 1 && args[0].argument.name === "arguments") {
	    nodes = [args[0].argument];
	  } else {
	    nodes = build(args, scope);
	  }
	
	  var first = nodes.shift();
	  if (nodes.length) {
	    node.arguments.push(t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes));
	  } else {
	    node.arguments.push(first);
	  }
	
	  var callee = node.callee;
	
	  if (this.get("callee").isMemberExpression()) {
	    var temp = scope.maybeGenerateMemoised(callee.object);
	    if (temp) {
	      callee.object = t.assignmentExpression("=", temp, callee.object);
	      contextLiteral = temp;
	    } else {
	      contextLiteral = callee.object;
	    }
	    t.appendToMemberExpression(callee, t.identifier("apply"));
	  } else {
	    node.callee = t.memberExpression(node.callee, t.identifier("apply"));
	  }
	
	  node.arguments.unshift(contextLiteral);
	}
	
	function NewExpression(node, parent, scope, file) {
	  var args = node.arguments;
	  if (!hasSpread(args)) return;
	
	  var nodes = build(args, scope);
	
	  var context = t.arrayExpression([t.literal(null)]);
	
	  args = t.callExpression(t.memberExpression(context, t.identifier("concat")), nodes);
	
	  return t.newExpression(t.callExpression(t.memberExpression(file.addHelper("bind"), t.identifier("apply")), [node.callee, args]), []);
	}

/***/ },
/* 330 */
/*!**************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/parameters.default.js ***!
  \**************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Func /*tion*/ = Func;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _helpersCallDelegate = __webpack_require__(/*! ../../helpers/call-delegate */ 331);
	
	var _helpersCallDelegate2 = _interopRequireDefault(_helpersCallDelegate);
	
	var _util = __webpack_require__(/*! ../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _traversal = __webpack_require__(/*! ../../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var hasDefaults = function hasDefaults(node) {
	  for (var i = 0; i < node.params.length; i++) {
	    if (!t.isIdentifier(node.params[i])) return true;
	  }
	  return false;
	};
	
	var iifeVisitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
	    if (node.name !== "eval") {
	      if (!state.scope.hasOwnBinding(node.name)) return;
	      if (state.scope.bindingIdentifierEquals(node.name, node)) return;
	    }
	
	    state.iife = true;
	    this.stop();
	  }
	};
	
	function Func(node, parent, scope, file) {
	  if (!hasDefaults(node)) return;
	
	  t.ensureBlock(node);
	
	  var body = [];
	
	  var argsIdentifier = t.identifier("arguments");
	  argsIdentifier._shadowedFunctionLiteral = true;
	
	  var lastNonDefaultParam = 0;
	
	  var state = { iife: false, scope: scope };
	
	  var pushDefNode = function pushDefNode(left, right, i) {
	    var defNode = util.template("default-parameter", {
	      VARIABLE_NAME: left,
	      DEFAULT_VALUE: right,
	      ARGUMENT_KEY: t.literal(i),
	      ARGUMENTS: argsIdentifier
	    }, true);
	    defNode._blockHoist = node.params.length - i;
	    body.push(defNode);
	  };
	
	  var params = this.get("params");
	  for (var i = 0; i < params.length; i++) {
	    var param = params[i];
	
	    if (!param.isAssignmentPattern()) {
	      if (!param.isRestElement()) {
	        lastNonDefaultParam = i + 1;
	      }
	
	      if (!param.isIdentifier()) {
	        param.traverse(iifeVisitor, state);
	      }
	
	      if (file.transformers["es6.spec.blockScoping"].canTransform() && param.isIdentifier()) {
	        pushDefNode(param.node, t.identifier("undefined"), i);
	      }
	
	      continue;
	    }
	
	    var left = param.get("left");
	    var right = param.get("right");
	
	    var placeholder = scope.generateUidIdentifier("x");
	    placeholder._isDefaultPlaceholder = true;
	    node.params[i] = placeholder;
	
	    if (!state.iife) {
	      if (right.isIdentifier() && scope.hasOwnBinding(right.node.name)) {
	        state.iife = true;
	      } else {
	        right.traverse(iifeVisitor, state);
	      }
	    }
	
	    pushDefNode(left.node, right.node, i);
	  }
	
	  // we need to cut off all trailing default parameters
	  node.params = node.params.slice(0, lastNonDefaultParam);
	
	  if (state.iife) {
	    body.push((0, _helpersCallDelegate2["default"])(node, scope));
	    node.body = t.blockStatement(body);
	  } else {
	    node.body.body = body.concat(node.body.body);
	  }
	}

/***/ },
/* 331 */
/*!************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/call-delegate.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _traversal = __webpack_require__(/*! ../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var visitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (this.isThisExpression() || this.isReferencedIdentifier({ name: "arguments" })) {
	      state.found = true;
	      this.stop();
	    }
	
	    if (this.isFunction()) {
	      this.skip();
	    }
	  }
	};
	
	exports["default"] = function (node, scope) {
	  var container = t.functionExpression(null, [], node.body, node.generator, node.async);
	
	  var callee = container;
	  var args = [];
	
	  var state = { found: false };
	  scope.traverse(node, visitor, state);
	  if (state.found) {
	    callee = t.memberExpression(container, t.identifier("apply"));
	    args = [t.thisExpression(), t.identifier("arguments")];
	  }
	
	  var call = t.callExpression(callee, args);
	  if (node.generator) call = t.yieldExpression(call, true);
	
	  return t.returnStatement(call);
	};
	
	module.exports = exports["default"];

/***/ },
/* 332 */
/*!*************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/export-extensions.js ***!
  \*************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/leebyron/ecmascript-more-export-from
	
	"use strict";
	
	exports.__esModule = true;
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  stage: 1
	};
	
	exports.metadata = metadata;
	function build(node, nodes, scope) {
	  var first = node.specifiers[0];
	  if (!t.isExportNamespaceSpecifier(first) && !t.isExportDefaultSpecifier(first)) return;
	
	  var specifier = node.specifiers.shift();
	  var uid = scope.generateUidIdentifier(specifier.exported.name);
	
	  var newSpecifier;
	  if (t.isExportNamespaceSpecifier(specifier)) {
	    newSpecifier = t.importNamespaceSpecifier(uid);
	  } else {
	    newSpecifier = t.importDefaultSpecifier(uid);
	  }
	
	  nodes.push(t.importDeclaration([newSpecifier], node.source));
	  nodes.push(t.exportNamedDeclaration(null, [t.exportSpecifier(uid, specifier.exported)]));
	
	  build(node, nodes, scope);
	}
	
	function ExportNamedDeclaration(node, parent, scope) {
	  var nodes = [];
	  build(node, nodes, scope);
	  if (!nodes.length) return;
	
	  if (node.specifiers.length >= 1) {
	    nodes.push(node);
	  }
	
	  return nodes;
	}

/***/ },
/* 333 */
/*!************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/spec/proto-to-assign.js ***!
  \************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.AssignmentExpression = AssignmentExpression;
	exports.ExpressionStatement = ExpressionStatement;
	exports.ObjectExpression = ObjectExpression;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var _lodashArrayPull = __webpack_require__(/*! lodash/array/pull */ 319);
	
	var _lodashArrayPull2 = _interopRequireDefault(_lodashArrayPull);
	
	function isProtoKey(node) {
	  return t.isLiteral(t.toComputedKey(node, node.key), { value: "__proto__" });
	}
	
	function isProtoAssignmentExpression(node) {
	  var left = node.left;
	  return t.isMemberExpression(left) && t.isLiteral(t.toComputedKey(left, left.property), { value: "__proto__" });
	}
	
	function buildDefaultsCallExpression(expr, ref, file) {
	  return t.expressionStatement(t.callExpression(file.addHelper("defaults"), [ref, expr.right]));
	}
	
	var metadata = {
	  secondPass: true,
	  optional: true
	};
	
	exports.metadata = metadata;
	
	function AssignmentExpression(node, parent, scope, file) {
	  if (!isProtoAssignmentExpression(node)) return;
	
	  var nodes = [];
	  var left = node.left.object;
	  var temp = scope.maybeGenerateMemoised(left);
	
	  nodes.push(t.expressionStatement(t.assignmentExpression("=", temp, left)));
	  nodes.push(buildDefaultsCallExpression(node, temp, file));
	  if (temp) nodes.push(temp);
	
	  return nodes;
	}
	
	function ExpressionStatement(node, parent, scope, file) {
	  var expr = node.expression;
	  if (!t.isAssignmentExpression(expr, { operator: "=" })) return;
	
	  if (isProtoAssignmentExpression(expr)) {
	    return buildDefaultsCallExpression(expr, expr.left.object, file);
	  }
	}
	
	function ObjectExpression(node, parent, scope, file) {
	  var proto;
	
	  for (var i = 0; i < node.properties.length; i++) {
	    var prop = node.properties[i];
	
	    if (isProtoKey(prop)) {
	      proto = prop.value;
	      (0, _lodashArrayPull2["default"])(node.properties, prop);
	    }
	  }
	
	  if (proto) {
	    var args = [t.objectExpression([]), proto];
	    if (node.properties.length) args.push(node);
	    return t.callExpression(file.addHelper("extends"), args);
	  }
	}

/***/ },
/* 334 */
/*!**********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/do-expressions.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.DoExpression = DoExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  stage: 0
	};
	
	exports.metadata = metadata;
	
	function DoExpression(node) {
	  var body = node.body.body;
	  if (body.length) {
	    return body;
	  } else {
	    return t.identifier("undefined");
	  }
	}

/***/ },
/* 335 */
/*!********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/spec.symbols.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.UnaryExpression = UnaryExpression;
	exports.BinaryExpression = BinaryExpression;
	exports.VariableDeclaration = VariableDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true
	};
	
	exports.metadata = metadata;
	
	function UnaryExpression(node, parent, scope, file) {
	  if (node._ignoreSpecSymbols) return;
	
	  if (node.operator === "typeof") {
	    var call = t.callExpression(file.addHelper("typeof"), [node.argument]);
	    if (this.get("argument").isIdentifier()) {
	      var undefLiteral = t.literal("undefined");
	      var unary = t.unaryExpression("typeof", node.argument);
	      unary._ignoreSpecSymbols = true;
	      return t.conditionalExpression(t.binaryExpression("===", unary, undefLiteral), undefLiteral, call);
	    } else {
	      return call;
	    }
	  }
	}
	
	function BinaryExpression(node, parent, scope, file) {
	  if (node.operator === "instanceof") {
	    return t.callExpression(file.addHelper("instanceof"), [node.left, node.right]);
	  }
	}
	
	function VariableDeclaration(node) {
	  if (node._generated) this.skip();
	}
	
	exports.FunctionDeclaration = VariableDeclaration;

/***/ },
/* 336 */
/*!*********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es7/function-bind.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/zenparsing/es-function-bind
	
	"use strict";
	
	exports.__esModule = true;
	exports.CallExpression = CallExpression;
	exports.BindExpression = BindExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  stage: 0
	};
	
	exports.metadata = metadata;
	function getTempId(scope) {
	  var id = scope.path.getData("functionBind");
	  if (id) return id;
	
	  id = scope.generateDeclaredUidIdentifier("context");
	  return scope.path.setData("functionBind", id);
	}
	
	function getStaticContext(bind, scope) {
	  var object = bind.object || bind.callee.object;
	  return scope.isStatic(object) && object;
	}
	
	function inferBindContext(bind, scope) {
	  var staticContext = getStaticContext(bind, scope);
	  if (staticContext) return staticContext;
	
	  var tempId = getTempId(scope);
	  if (bind.object) {
	    bind.callee = t.sequenceExpression([t.assignmentExpression("=", tempId, bind.object), bind.callee]);
	  } else {
	    bind.callee.object = t.assignmentExpression("=", tempId, bind.callee.object);
	  }
	  return tempId;
	}
	
	function CallExpression(node, parent, scope, file) {
	  var bind = node.callee;
	  if (!t.isBindExpression(bind)) return;
	
	  var context = inferBindContext(bind, scope);
	  node.callee = t.memberExpression(bind.callee, t.identifier("call"));
	  node.arguments.unshift(context);
	}
	
	function BindExpression(node, parent, scope, file) {
	  var context = inferBindContext(node, scope);
	  return t.callExpression(t.memberExpression(node.callee, t.identifier("bind")), [context]);
	}

/***/ },
/* 337 */
/*!**************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/spec/undefined-to-void.js ***!
  \**************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Identifier = Identifier;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  react: true
	};
	
	exports.metadata = metadata;
	
	function Identifier(node, parent) {
	  if (node.name === "undefined" && this.isReferenced()) {
	    return t.unaryExpression("void", t.literal(0), true);
	  }
	}

/***/ },
/* 338 */
/*!*****************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/jscript.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.FunctionExpression = FunctionExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true
	};
	
	exports.metadata = metadata;
	
	function FunctionExpression(node, print) {
	  if (!node.id) return;
	  node._ignoreUserWhitespace = true;
	
	  return t.callExpression(t.functionExpression(null, [], t.blockStatement([t.toStatement(node), t.returnStatement(node.id)])), []);
	}

/***/ },
/* 339 */
/*!**************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/flow.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Flow = Flow;
	exports.ClassProperty = ClassProperty;
	exports.Class = Class;
	exports.Func /*tion*/ = Func;
	exports.TypeCastExpression = TypeCastExpression;
	exports.ImportDeclaration = ImportDeclaration;
	exports.ExportDeclaration = ExportDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function Flow(node) {
	  this.remove();
	}
	
	function ClassProperty(node) {
	  node.typeAnnotation = null;
	}
	
	function Class(node) {
	  node["implements"] = null;
	}
	
	function Func(node) {
	  for (var i = 0; i < node.params.length; i++) {
	    var param = node.params[i];
	    param.optional = false;
	  }
	}
	
	function TypeCastExpression(node) {
	  return node.expression;
	}
	
	function ImportDeclaration(node) {
	  if (node.isType) this.remove();
	}
	
	function ExportDeclaration(node) {
	  if (this.get("declaration").isTypeAlias()) this.remove();
	}

/***/ },
/* 340 */
/*!*********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/destructuring.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ForOfStatement = ForOfStatement;
	exports.Func /*tion*/ = Func;
	exports.CatchClause = CatchClause;
	exports.ExpressionStatement = ExpressionStatement;
	exports.AssignmentExpression = AssignmentExpression;
	exports.VariableDeclaration = VariableDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-advanced"
	};
	
	exports.metadata = metadata;
	
	function ForOfStatement(node, parent, scope, file) {
	  var left = node.left;
	
	  if (t.isPattern(left)) {
	    // for ({ length: k } in { abc: 3 });
	
	    var temp = scope.generateUidIdentifier("ref");
	
	    node.left = t.variableDeclaration("var", [t.variableDeclarator(temp)]);
	
	    t.ensureBlock(node);
	
	    node.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(left, temp)]));
	
	    return;
	  }
	
	  if (!t.isVariableDeclaration(left)) return;
	
	  var pattern = left.declarations[0].id;
	  if (!t.isPattern(pattern)) return;
	
	  var key = scope.generateUidIdentifier("ref");
	  node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]);
	
	  var nodes = [];
	
	  var destructuring = new DestructuringTransformer({
	    kind: left.kind,
	    file: file,
	    scope: scope,
	    nodes: nodes
	  });
	
	  destructuring.init(pattern, key);
	
	  t.ensureBlock(node);
	
	  var block = node.body;
	  block.body = nodes.concat(block.body);
	}
	
	exports.ForInStatement = ForOfStatement;
	
	function Func(node, parent, scope, file) {
	  var nodes = [];
	
	  var hasDestructuring = false;
	
	  node.params = node.params.map(function (pattern, i) {
	    if (!t.isPattern(pattern)) return pattern;
	
	    hasDestructuring = true;
	    var ref = scope.generateUidIdentifier("ref");
	    t.inherits(ref, pattern);
	
	    var destructuring = new DestructuringTransformer({
	      blockHoist: node.params.length - i,
	      nodes: nodes,
	      scope: scope,
	      file: file,
	      kind: "let"
	    });
	    destructuring.init(pattern, ref);
	
	    return ref;
	  });
	
	  if (!hasDestructuring) return;
	
	  t.ensureBlock(node);
	
	  var block = node.body;
	  block.body = nodes.concat(block.body);
	}
	
	function CatchClause(node, parent, scope, file) {
	  var pattern = node.param;
	  if (!t.isPattern(pattern)) return;
	
	  var ref = scope.generateUidIdentifier("ref");
	  node.param = ref;
	
	  var nodes = [];
	
	  var destructuring = new DestructuringTransformer({
	    kind: "let",
	    file: file,
	    scope: scope,
	    nodes: nodes
	  });
	  destructuring.init(pattern, ref);
	
	  node.body.body = nodes.concat(node.body.body);
	}
	
	function ExpressionStatement(node, parent, scope, file) {
	  var expr = node.expression;
	  if (expr.type !== "AssignmentExpression") return;
	  if (!t.isPattern(expr.left)) return;
	  if (this.isCompletionRecord()) return;
	
	  var destructuring = new DestructuringTransformer({
	    operator: expr.operator,
	    scope: scope,
	    file: file });
	
	  return destructuring.init(expr.left, expr.right);
	}
	
	function AssignmentExpression(node, parent, scope, file) {
	  if (!t.isPattern(node.left)) return;
	
	  var ref = scope.generateUidIdentifier("temp");
	
	  var nodes = [];
	  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(ref, node.right)]));
	
	  var destructuring = new DestructuringTransformer({
	    operator: node.operator,
	    file: file,
	    scope: scope,
	    nodes: nodes
	  });
	
	  if (t.isArrayExpression(node.right)) {
	    destructuring.arrays[ref.name] = true;
	  }
	
	  destructuring.init(node.left, ref);
	
	  nodes.push(t.expressionStatement(ref));
	
	  return nodes;
	}
	
	function variableDeclarationHasPattern(node) {
	  for (var i = 0; i < node.declarations.length; i++) {
	    if (t.isPattern(node.declarations[i].id)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function VariableDeclaration(node, parent, scope, file) {
	  if (t.isForInStatement(parent) || t.isForOfStatement(parent)) return;
	  if (!variableDeclarationHasPattern(node)) return;
	
	  var nodes = [];
	  var declar;
	
	  for (var i = 0; i < node.declarations.length; i++) {
	    declar = node.declarations[i];
	
	    var patternId = declar.init;
	    var pattern = declar.id;
	
	    var destructuring = new DestructuringTransformer({
	      nodes: nodes,
	      scope: scope,
	      kind: node.kind,
	      file: file
	    });
	
	    if (t.isPattern(pattern)) {
	      destructuring.init(pattern, patternId);
	
	      if (+i !== node.declarations.length - 1) {
	        // we aren't the last declarator so let's just make the
	        // last transformed node inherit from us
	        t.inherits(nodes[nodes.length - 1], declar);
	      }
	    } else {
	      nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));
	    }
	  }
	
	  if (!t.isProgram(parent) && !t.isBlockStatement(parent)) {
	    // https://github.com/babel/babel/issues/113
	    // for (let [x] = [0]; false;) {}
	
	    declar = null;
	
	    for (i = 0; i < nodes.length; i++) {
	      node = nodes[i];
	      declar = declar || t.variableDeclaration(node.kind, []);
	
	      if (!t.isVariableDeclaration(node) && declar.kind !== node.kind) {
	        throw file.errorWithNode(node, messages.get("invalidParentForThisNode"));
	      }
	
	      declar.declarations = declar.declarations.concat(node.declarations);
	    }
	
	    return declar;
	  }
	
	  return nodes;
	}
	
	function hasRest(pattern) {
	  for (var i = 0; i < pattern.elements.length; i++) {
	    if (t.isRestElement(pattern.elements[i])) {
	      return true;
	    }
	  }
	  return false;
	}
	
	var arrayUnpackVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (this.isReferencedIdentifier() && state.bindings[node.name]) {
	      state.deopt = true;
	      this.stop();
	    }
	  }
	};
	
	var DestructuringTransformer = (function () {
	  function DestructuringTransformer(opts) {
	    _classCallCheck(this, DestructuringTransformer);
	
	    this.blockHoist = opts.blockHoist;
	    this.operator = opts.operator;
	    this.arrays = {};
	    this.nodes = opts.nodes || [];
	    this.scope = opts.scope;
	    this.file = opts.file;
	    this.kind = opts.kind;
	  }
	
	  DestructuringTransformer.prototype.buildVariableAssignment = function buildVariableAssignment(id, init) {
	    var op = this.operator;
	    if (t.isMemberExpression(id)) op = "=";
	
	    var node;
	
	    if (op) {
	      node = t.expressionStatement(t.assignmentExpression(op, id, init));
	    } else {
	      node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]);
	    }
	
	    node._blockHoist = this.blockHoist;
	
	    return node;
	  };
	
	  DestructuringTransformer.prototype.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
	    var declar = t.variableDeclaration("var", [t.variableDeclarator(id, init)]);
	    declar._blockHoist = this.blockHoist;
	    return declar;
	  };
	
	  DestructuringTransformer.prototype.push = function push(id, init) {
	    if (t.isObjectPattern(id)) {
	      this.pushObjectPattern(id, init);
	    } else if (t.isArrayPattern(id)) {
	      this.pushArrayPattern(id, init);
	    } else if (t.isAssignmentPattern(id)) {
	      this.pushAssignmentPattern(id, init);
	    } else {
	      this.nodes.push(this.buildVariableAssignment(id, init));
	    }
	  };
	
	  DestructuringTransformer.prototype.toArray = function toArray(node, count) {
	    if (this.file.isLoose("es6.destructuring") || t.isIdentifier(node) && this.arrays[node.name]) {
	      return node;
	    } else {
	      return this.scope.toArray(node, count);
	    }
	  };
	
	  DestructuringTransformer.prototype.pushAssignmentPattern = function pushAssignmentPattern(pattern, valueRef) {
	    // we need to assign the current value of the assignment to avoid evaluating
	    // it more than once
	
	    var tempValueRef = this.scope.generateUidIdentifierBasedOnNode(valueRef);
	
	    var declar = t.variableDeclaration("var", [t.variableDeclarator(tempValueRef, valueRef)]);
	    declar._blockHoist = this.blockHoist;
	    this.nodes.push(declar);
	
	    //
	
	    var tempConditional = t.conditionalExpression(t.binaryExpression("===", tempValueRef, t.identifier("undefined")), pattern.right, tempValueRef);
	
	    var left = pattern.left;
	    if (t.isPattern(left)) {
	      this.nodes.push(t.expressionStatement(t.assignmentExpression("=", tempValueRef, tempConditional)));
	      this.push(left, tempValueRef);
	    } else {
	      this.nodes.push(this.buildVariableAssignment(left, tempConditional));
	    }
	  };
	
	  DestructuringTransformer.prototype.pushObjectSpread = function pushObjectSpread(pattern, objRef, spreadProp, spreadPropIndex) {
	    // get all the keys that appear in this object before the current spread
	
	    var keys = [];
	
	    for (var i = 0; i < pattern.properties.length; i++) {
	      var prop = pattern.properties[i];
	
	      // we've exceeded the index of the spread property to all properties to the
	      // right need to be ignored
	      if (i >= spreadPropIndex) break;
	
	      // ignore other spread properties
	      if (t.isSpreadProperty(prop)) continue;
	
	      var key = prop.key;
	      if (t.isIdentifier(key) && !prop.computed) key = t.literal(prop.key.name);
	      keys.push(key);
	    }
	
	    keys = t.arrayExpression(keys);
	
	    //
	
	    var value = t.callExpression(this.file.addHelper("object-without-properties"), [objRef, keys]);
	    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
	  };
	
	  DestructuringTransformer.prototype.pushObjectProperty = function pushObjectProperty(prop, propRef) {
	    if (t.isLiteral(prop.key)) prop.computed = true;
	
	    var pattern = prop.value;
	    var objRef = t.memberExpression(propRef, prop.key, prop.computed);
	
	    if (t.isPattern(pattern)) {
	      this.push(pattern, objRef);
	    } else {
	      this.nodes.push(this.buildVariableAssignment(pattern, objRef));
	    }
	  };
	
	  DestructuringTransformer.prototype.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
	    // https://github.com/babel/babel/issues/681
	
	    if (!pattern.properties.length) {
	      this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper("object-destructuring-empty"), [objRef])));
	    }
	
	    // if we have more than one properties in this pattern and the objectRef is a
	    // member expression then we need to assign it to a temporary variable so it's
	    // only evaluated once
	
	    if (pattern.properties.length > 1 && t.isMemberExpression(objRef)) {
	      var temp = this.scope.generateUidIdentifierBasedOnNode(objRef, this.file);
	      this.nodes.push(this.buildVariableDeclaration(temp, objRef));
	      objRef = temp;
	    }
	
	    //
	
	    for (var i = 0; i < pattern.properties.length; i++) {
	      var prop = pattern.properties[i];
	      if (t.isSpreadProperty(prop)) {
	        this.pushObjectSpread(pattern, objRef, prop, i);
	      } else {
	        this.pushObjectProperty(prop, objRef);
	      }
	    }
	  };
	
	  DestructuringTransformer.prototype.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
	    // not an array so there's no way we can deal with this
	    if (!t.isArrayExpression(arr)) return false;
	
	    // pattern has less elements than the array and doesn't have a rest so some
	    // elements wont be evaluated
	    if (pattern.elements.length > arr.elements.length) return;
	    if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return false;
	
	    for (var i = 0; i < pattern.elements.length; i++) {
	      var elem = pattern.elements[i];
	
	      // deopt on holes
	      if (!elem) return false;
	
	      // deopt on member expressions
	      if (t.isMemberExpression(elem)) return false;
	    }
	
	    // deopt on reference to left side identifiers
	    var bindings = t.getBindingIdentifiers(pattern);
	    var state = { deopt: false, bindings: bindings };
	    this.scope.traverse(arr, arrayUnpackVisitor, state);
	    return !state.deopt;
	  };
	
	  DestructuringTransformer.prototype.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
	    for (var i = 0; i < pattern.elements.length; i++) {
	      var elem = pattern.elements[i];
	      if (t.isRestElement(elem)) {
	        this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));
	      } else {
	        this.push(elem, arr.elements[i]);
	      }
	    }
	  };
	
	  DestructuringTransformer.prototype.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
	    if (!pattern.elements) return;
	
	    // optimise basic array destructuring of an array expression
	    //
	    // we can't do this to a pattern of unequal size to it's right hand
	    // array expression as then there will be values that wont be evaluated
	    //
	    // eg: var [a, b] = [1, 2];
	
	    if (this.canUnpackArrayPattern(pattern, arrayRef)) {
	      return this.pushUnpackedArrayPattern(pattern, arrayRef);
	    }
	
	    // if we have a rest then we need all the elements so don't tell
	    // `scope.toArray` to only get a certain amount
	
	    var count = !hasRest(pattern) && pattern.elements.length;
	
	    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will
	    // return a locally bound identifier if it's been inferred to be an array,
	    // otherwise it'll be a call to a helper that will ensure it's one
	
	    var toArray = this.toArray(arrayRef, count);
	
	    if (t.isIdentifier(toArray)) {
	      // we've been given an identifier so it must have been inferred to be an
	      // array
	      arrayRef = toArray;
	    } else {
	      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
	      this.arrays[arrayRef.name] = true;
	      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
	    }
	
	    //
	
	    for (var i = 0; i < pattern.elements.length; i++) {
	      var elem = pattern.elements[i];
	
	      // hole
	      if (!elem) continue;
	
	      var elemRef;
	
	      if (t.isRestElement(elem)) {
	        elemRef = this.toArray(arrayRef);
	
	        if (i > 0) {
	          elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier("slice")), [t.literal(i)]);
	        }
	
	        // set the element to the rest element argument since we've dealt with it
	        // being a rest already
	        elem = elem.argument;
	      } else {
	        elemRef = t.memberExpression(arrayRef, t.literal(i), true);
	      }
	
	      this.push(elem, elemRef);
	    }
	  };
	
	  DestructuringTransformer.prototype.init = function init(pattern, ref) {
	    // trying to destructure a value that we can't evaluate more than once so we
	    // need to save it to a variable
	
	    var shouldMemoise = true;
	    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {
	      var memo = this.scope.maybeGenerateMemoised(ref, true);
	      if (memo) {
	        this.nodes.push(this.buildVariableDeclaration(memo, ref));
	        ref = memo;
	      }
	    }
	
	    //
	
	    this.push(pattern, ref);
	
	    return this.nodes;
	  };
	
	  return DestructuringTransformer;
	})();

/***/ },
/* 341 */
/*!*********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/block-scoping.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.VariableDeclaration = VariableDeclaration;
	exports.Loop = Loop;
	exports.BlockStatement = BlockStatement;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _traversal = __webpack_require__(/*! ../../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _helpersObject = __webpack_require__(/*! ../../../helpers/object */ 197);
	
	var _helpersObject2 = _interopRequireDefault(_helpersObject);
	
	var _util = __webpack_require__(/*! ../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var _lodashObjectValues = __webpack_require__(/*! lodash/object/values */ 149);
	
	var _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);
	
	var _lodashObjectExtend = __webpack_require__(/*! lodash/object/extend */ 138);
	
	var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
	
	function isLet(node, parent) {
	  if (!t.isVariableDeclaration(node)) return false;
	  if (node._let) return true;
	  if (node.kind !== "let") return false;
	
	  // https://github.com/babel/babel/issues/255
	  if (isLetInitable(node, parent)) {
	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	      declar.init = declar.init || t.identifier("undefined");
	    }
	  }
	
	  node._let = true;
	  node.kind = "var";
	  return true;
	}
	
	function isLetInitable(node, parent) {
	  return !t.isFor(parent) || !t.isFor(parent, { left: node });
	}
	
	function isVar(node, parent) {
	  return t.isVariableDeclaration(node, { kind: "var" }) && !isLet(node, parent);
	}
	
	function standardizeLets(declars) {
	  var _arr = declars;
	
	  for (var _i = 0; _i < _arr.length; _i++) {
	    var declar = _arr[_i];
	    delete declar._let;
	  }
	}
	
	var metadata = {
	  group: "builtin-advanced"
	};
	
	exports.metadata = metadata;
	
	function VariableDeclaration(node, parent, scope, file) {
	  if (!isLet(node, parent)) return;
	
	  if (isLetInitable(node) && file.transformers["es6.spec.blockScoping"].canTransform()) {
	    var nodes = [node];
	
	    for (var i = 0; i < node.declarations.length; i++) {
	      var decl = node.declarations[i];
	      if (decl.init) {
	        var assign = t.assignmentExpression("=", decl.id, decl.init);
	        assign._ignoreBlockScopingTDZ = true;
	        nodes.push(t.expressionStatement(assign));
	      }
	      decl.init = file.addHelper("temporal-undefined");
	    }
	
	    node._blockHoist = 2;
	
	    return nodes;
	  }
	}
	
	function Loop(node, parent, scope, file) {
	  var init = node.left || node.init;
	  if (isLet(init, node)) {
	    t.ensureBlock(node);
	    node.body._letDeclarators = [init];
	  }
	
	  var blockScoping = new BlockScoping(this, this.get("body"), parent, scope, file);
	  return blockScoping.run();
	}
	
	function BlockStatement(block, parent, scope, file) {
	  if (!t.isLoop(parent)) {
	    var blockScoping = new BlockScoping(null, this, parent, scope, file);
	    blockScoping.run();
	  }
	}
	
	exports.Program = BlockStatement;
	
	function replace(node, parent, scope, remaps) {
	  var remap = remaps[node.name];
	  if (!remap) return;
	
	  var ownBinding = scope.getBindingIdentifier(node.name);
	  if (ownBinding === remap.binding) {
	    node.name = remap.uid;
	  } else {
	    // scope already has it's own binding that doesn't
	    // match the one we have a stored replacement for
	    if (this) this.skip();
	  }
	}
	
	var replaceVisitor = {
	  ReferencedIdentifier: replace,
	
	  AssignmentExpression: function AssignmentExpression(node, parent, scope, remaps) {
	    var ids = this.getBindingIdentifiers();
	    for (var name in ids) {
	      replace(ids[name], node, scope, remaps);
	    }
	  } };
	
	function traverseReplace(node, parent, scope, remaps) {
	  if (t.isIdentifier(node)) {
	    replace(node, parent, scope, remaps);
	  }
	
	  scope.traverse(node, replaceVisitor, remaps);
	}
	
	var letReferenceBlockVisitor = {
	  Function: function Function(node, parent, scope, state) {
	    this.traverse(letReferenceFunctionVisitor, state);
	    return this.skip();
	  }
	};
	
	var letReferenceFunctionVisitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
	    var ref = state.letReferences[node.name];
	
	    // not a part of our scope
	    if (!ref) return;
	
	    // this scope has a variable with the same name so it couldn't belong
	    // to our let scope
	    if (scope.getBindingIdentifier(node.name) !== ref) return;
	
	    state.closurify = true;
	  }
	};
	
	var hoistVarDeclarationsVisitor = {
	  enter: function enter(node, parent, scope, self) {
	    if (this.isForStatement()) {
	      if (isVar(node.init, node)) {
	        var nodes = self.pushDeclar(node.init);
	        if (nodes.length === 1) {
	          node.init = nodes[0];
	        } else {
	          node.init = t.sequenceExpression(nodes);
	        }
	      }
	    } else if (this.isFor()) {
	      if (isVar(node.left, node)) {
	        node.left = node.left.declarations[0].id;
	      }
	    } else if (isVar(node, parent)) {
	      return self.pushDeclar(node).map(t.expressionStatement);
	    } else if (this.isFunction()) {
	      return this.skip();
	    }
	  }
	};
	
	var loopLabelVisitor = {
	  LabeledStatement: function LabeledStatement(node, parent, scope, state) {
	    state.innerLabels.push(node.label.name);
	  }
	};
	
	var continuationVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (this.isAssignmentExpression() || this.isUpdateExpression()) {
	      var bindings = this.getBindingIdentifiers();
	      for (var name in bindings) {
	        if (state.outsideReferences[name] !== scope.getBindingIdentifier(name)) continue;
	        state.reassignments[name] = true;
	      }
	    }
	  }
	};
	
	var loopNodeTo = function loopNodeTo(node) {
	  if (t.isBreakStatement(node)) {
	    return "break";
	  } else if (t.isContinueStatement(node)) {
	    return "continue";
	  }
	};
	
	var loopVisitor = {
	  Loop: function Loop(node, parent, scope, state) {
	    var oldIgnoreLabeless = state.ignoreLabeless;
	    state.ignoreLabeless = true;
	    this.traverse(loopVisitor, state);
	    state.ignoreLabeless = oldIgnoreLabeless;
	    this.skip();
	  },
	
	  Function: function Function() {
	    this.skip();
	  },
	
	  SwitchCase: function SwitchCase(node, parent, scope, state) {
	    var oldInSwitchCase = state.inSwitchCase;
	    state.inSwitchCase = true;
	    this.traverse(loopVisitor, state);
	    state.inSwitchCase = oldInSwitchCase;
	    this.skip();
	  },
	
	  enter: function enter(node, parent, scope, state) {
	    var replace;
	    var loopText = loopNodeTo(node);
	
	    if (loopText) {
	      if (node.label) {
	        // we shouldn't be transforming this because it exists somewhere inside
	        if (state.innerLabels.indexOf(node.label.name) >= 0) {
	          return;
	        }
	
	        loopText = "" + loopText + "|" + node.label.name;
	      } else {
	        // we shouldn't be transforming these statements because
	        // they don't refer to the actual loop we're scopifying
	        if (state.ignoreLabeless) return;
	
	        //
	        if (state.inSwitchCase) return;
	
	        // break statements mean something different in this context
	        if (t.isBreakStatement(node) && t.isSwitchCase(parent)) return;
	      }
	
	      state.hasBreakContinue = true;
	      state.map[loopText] = node;
	      replace = t.literal(loopText);
	    }
	
	    if (this.isReturnStatement()) {
	      state.hasReturn = true;
	      replace = t.objectExpression([t.property("init", t.identifier("v"), node.argument || t.identifier("undefined"))]);
	    }
	
	    if (replace) {
	      replace = t.returnStatement(replace);
	      this.skip();
	      return t.inherits(replace, node);
	    }
	  }
	};
	
	var BlockScoping = (function () {
	
	  /**
	   * Description
	   */
	
	  function BlockScoping(loopPath, blockPath, parent, scope, file) {
	    _classCallCheck(this, BlockScoping);
	
	    this.parent = parent;
	    this.scope = scope;
	    this.file = file;
	
	    this.blockPath = blockPath;
	    this.block = blockPath.node;
	
	    this.outsideLetReferences = (0, _helpersObject2["default"])();
	    this.hasLetReferences = false;
	    this.letReferences = this.block._letReferences = (0, _helpersObject2["default"])();
	    this.body = [];
	
	    if (loopPath) {
	      this.loopParent = loopPath.parent;
	      this.loopLabel = t.isLabeledStatement(this.loopParent) && this.loopParent.label;
	      this.loopPath = loopPath;
	      this.loop = loopPath.node;
	    }
	  }
	
	  /**
	   * Start the ball rolling.
	   */
	
	  BlockScoping.prototype.run = function run() {
	    var block = this.block;
	    if (block._letDone) return;
	    block._letDone = true;
	
	    var needsClosure = this.getLetReferences();
	
	    // this is a block within a `Function/Program` so we can safely leave it be
	    if (t.isFunction(this.parent) || t.isProgram(this.block)) return;
	
	    // we can skip everything
	    if (!this.hasLetReferences) return;
	
	    if (needsClosure) {
	      this.wrapClosure();
	    } else {
	      this.remap();
	    }
	
	    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {
	      return t.labeledStatement(this.loopLabel, this.loop);
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  BlockScoping.prototype.remap = function remap() {
	    var hasRemaps = false;
	    var letRefs = this.letReferences;
	    var scope = this.scope;
	
	    // alright, so since we aren't wrapping this block in a closure
	    // we have to check if any of our let variables collide with
	    // those in upper scopes and then if they do, generate a uid
	    // for them and replace all references with it
	    var remaps = (0, _helpersObject2["default"])();
	
	    for (var key in letRefs) {
	      // just an Identifier node we collected in `getLetReferences`
	      // this is the defining identifier of a declaration
	      var ref = letRefs[key];
	
	      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
	        var uid = scope.generateUidIdentifier(ref.name).name;
	        ref.name = uid;
	
	        hasRemaps = true;
	        remaps[key] = remaps[uid] = {
	          binding: ref,
	          uid: uid
	        };
	      }
	    }
	
	    if (!hasRemaps) return;
	
	    //
	
	    var loop = this.loop;
	    if (loop) {
	      traverseReplace(loop.right, loop, scope, remaps);
	      traverseReplace(loop.test, loop, scope, remaps);
	      traverseReplace(loop.update, loop, scope, remaps);
	    }
	
	    this.blockPath.traverse(replaceVisitor, remaps);
	  };
	
	  /**
	   * Description
	   */
	
	  BlockScoping.prototype.wrapClosure = function wrapClosure() {
	    var block = this.block;
	
	    var outsideRefs = this.outsideLetReferences;
	
	    // remap loop heads with colliding variables
	    if (this.loop) {
	      for (var name in outsideRefs) {
	        var id = outsideRefs[name];
	
	        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
	          delete outsideRefs[id.name];
	          delete this.letReferences[id.name];
	
	          this.scope.rename(id.name);
	
	          this.letReferences[id.name] = id;
	          outsideRefs[id.name] = id;
	        }
	      }
	    }
	
	    // if we're inside of a for loop then we search to see if there are any
	    // `break`s, `continue`s, `return`s etc
	    this.has = this.checkLoop();
	
	    // hoist var references to retain scope
	    this.hoistVarDeclarations();
	
	    // turn outsideLetReferences into an array
	    var params = (0, _lodashObjectValues2["default"])(outsideRefs);
	    var args = (0, _lodashObjectValues2["default"])(outsideRefs);
	
	    // build the closure that we're going to wrap the block with
	    var fn = t.functionExpression(null, params, t.blockStatement(block.body));
	    fn.shadow = true;
	
	    // continuation
	    this.addContinuations(fn);
	
	    // replace the current block body with the one we're going to build
	    block.body = this.body;
	
	    var ref = fn;
	
	    if (this.loop) {
	      ref = this.scope.generateUidIdentifier("loop");
	      this.loopPath.insertBefore(t.variableDeclaration("var", [t.variableDeclarator(ref, fn)]));
	    }
	
	    // build a call and a unique id that we can assign the return value to
	    var call = t.callExpression(ref, args);
	    var ret = this.scope.generateUidIdentifier("ret");
	
	    // handle generators
	    var hasYield = _traversal2["default"].hasType(fn.body, this.scope, "YieldExpression", t.FUNCTION_TYPES);
	    if (hasYield) {
	      fn.generator = true;
	      call = t.yieldExpression(call, true);
	    }
	
	    // handlers async functions
	    var hasAsync = _traversal2["default"].hasType(fn.body, this.scope, "AwaitExpression", t.FUNCTION_TYPES);
	    if (hasAsync) {
	      fn.async = true;
	      call = t.awaitExpression(call);
	    }
	
	    this.buildClosure(ret, call);
	  };
	
	  /**
	   * Push the closure to the body.
	   */
	
	  BlockScoping.prototype.buildClosure = function buildClosure(ret, call) {
	    var has = this.has;
	    if (has.hasReturn || has.hasBreakContinue) {
	      this.buildHas(ret, call);
	    } else {
	      this.body.push(t.expressionStatement(call));
	    }
	  };
	
	  /**
	   * If any of the outer let variables are reassigned then we need to rename them in
	   * the closure so we can get direct access to the outer variable to continue the
	   * iteration with bindings based on each iteration.
	   *
	   * Reference: https://github.com/babel/babel/issues/1078
	   */
	
	  BlockScoping.prototype.addContinuations = function addContinuations(fn) {
	    var state = {
	      reassignments: {},
	      outsideReferences: this.outsideLetReferences
	    };
	
	    this.scope.traverse(fn, continuationVisitor, state);
	
	    for (var i = 0; i < fn.params.length; i++) {
	      var param = fn.params[i];
	      if (!state.reassignments[param.name]) continue;
	
	      var newParam = this.scope.generateUidIdentifier(param.name);
	      fn.params[i] = newParam;
	
	      this.scope.rename(param.name, newParam.name, fn);
	
	      // assign outer reference as it's been modified internally and needs to be retained
	      fn.body.body.push(t.expressionStatement(t.assignmentExpression("=", param, newParam)));
	    }
	  };
	
	  /**
	   * Description
	   */
	
	  BlockScoping.prototype.getLetReferences = function getLetReferences() {
	    var block = this.block;
	
	    var declarators = block._letDeclarators || [];
	
	    //
	    for (var i = 0; i < declarators.length; i++) {
	      var declar = declarators[i];
	      (0, _lodashObjectExtend2["default"])(this.outsideLetReferences, t.getBindingIdentifiers(declar));
	    }
	
	    //
	    if (block.body) {
	      for (var i = 0; i < block.body.length; i++) {
	        var declar = block.body[i];
	        if (isLet(declar, block)) {
	          declarators = declarators.concat(declar.declarations);
	        }
	      }
	    }
	
	    //
	    for (var i = 0; i < declarators.length; i++) {
	      var declar = declarators[i];
	      var keys = t.getBindingIdentifiers(declar);
	      (0, _lodashObjectExtend2["default"])(this.letReferences, keys);
	      this.hasLetReferences = true;
	    }
	
	    // no let references so we can just quit
	    if (!this.hasLetReferences) return;
	
	    // set let references to plain var references
	    standardizeLets(declarators);
	
	    var state = {
	      letReferences: this.letReferences,
	      closurify: false
	    };
	
	    // traverse through this block, stopping on functions and checking if they
	    // contain any local let references
	    this.blockPath.traverse(letReferenceBlockVisitor, state);
	
	    return state.closurify;
	  };
	
	  /**
	   * If we're inside of a loop then traverse it and check if it has one of
	   * the following node types `ReturnStatement`, `BreakStatement`,
	   * `ContinueStatement` and replace it with a return value that we can track
	   * later on.
	   *
	   * @returns {Object}
	   */
	
	  BlockScoping.prototype.checkLoop = function checkLoop() {
	    var state = {
	      hasBreakContinue: false,
	      ignoreLabeless: false,
	      inSwitchCase: false,
	      innerLabels: [],
	      hasReturn: false,
	      isLoop: !!this.loop,
	      map: {}
	    };
	
	    this.blockPath.traverse(loopLabelVisitor, state);
	    this.blockPath.traverse(loopVisitor, state);
	
	    return state;
	  };
	
	  /**
	   * Hoist all var declarations in this block to before it so they retain scope
	   * once we wrap everything in a closure.
	   */
	
	  BlockScoping.prototype.hoistVarDeclarations = function hoistVarDeclarations() {
	    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
	  };
	
	  /**
	   * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with
	   * their declarations hoisted to before the closure wrapper.
	   */
	
	  BlockScoping.prototype.pushDeclar = function pushDeclar(node) {
	    var declars = [];
	    var names = t.getBindingIdentifiers(node);
	    for (var name in names) {
	      declars.push(t.variableDeclarator(names[name]));
	    }
	
	    this.body.push(t.variableDeclaration(node.kind, declars));
	
	    var replace = [];
	
	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	      if (!declar.init) continue;
	
	      var expr = t.assignmentExpression("=", declar.id, declar.init);
	      replace.push(t.inherits(expr, declar));
	    }
	
	    return replace;
	  };
	
	  /**
	   * Description
	   */
	
	  BlockScoping.prototype.buildHas = function buildHas(ret, call) {
	    var body = this.body;
	
	    body.push(t.variableDeclaration("var", [t.variableDeclarator(ret, call)]));
	
	    var loop = this.loop;
	    var retCheck;
	    var has = this.has;
	    var cases = [];
	
	    if (has.hasReturn) {
	      // typeof ret === "object"
	      retCheck = util.template("let-scoping-return", {
	        RETURN: ret
	      });
	    }
	
	    if (has.hasBreakContinue) {
	      for (var key in has.map) {
	        cases.push(t.switchCase(t.literal(key), [has.map[key]]));
	      }
	
	      if (has.hasReturn) {
	        cases.push(t.switchCase(null, [retCheck]));
	      }
	
	      if (cases.length === 1) {
	        var single = cases[0];
	        body.push(this.file.attachAuxiliaryComment(t.ifStatement(t.binaryExpression("===", ret, single.test), single.consequent[0])));
	      } else {
	        // https://github.com/babel/babel/issues/998
	        for (var i = 0; i < cases.length; i++) {
	          var caseConsequent = cases[i].consequent[0];
	          if (t.isBreakStatement(caseConsequent) && !caseConsequent.label) {
	            caseConsequent.label = this.loopLabel = this.loopLabel || this.file.scope.generateUidIdentifier("loop");
	          }
	        }
	
	        body.push(this.file.attachAuxiliaryComment(t.switchStatement(ret, cases)));
	      }
	    } else {
	      if (has.hasReturn) {
	        body.push(this.file.attachAuxiliaryComment(retCheck));
	      }
	    }
	  };
	
	  return BlockScoping;
	})();

/***/ },
/* 342 */
/*!**************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/spec.block-scoping.js ***!
  \**************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _traversal = __webpack_require__(/*! ../../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var visitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
	    if (t.isFor(parent) && parent.left === node) return;
	
	    var declared = state.letRefs[node.name];
	    if (!declared) return;
	
	    // declared node is different in this scope
	    if (scope.getBindingIdentifier(node.name) !== declared) return;
	
	    var assert = t.callExpression(state.file.addHelper("temporal-assert-defined"), [node, t.literal(node.name), state.file.addHelper("temporal-undefined")]);
	
	    this.skip();
	
	    if (t.isAssignmentExpression(parent) || t.isUpdateExpression(parent)) {
	      if (parent._ignoreBlockScopingTDZ) return;
	      this.parentPath.replaceWith(t.sequenceExpression([assert, parent]));
	    } else {
	      return t.logicalExpression("&&", assert, node);
	    }
	  }
	};
	
	var metadata = {
	  optional: true,
	  group: "builtin-advanced"
	};
	
	exports.metadata = metadata;
	var BlockStatement = {
	  exit: function exit(node, parent, scope, file) {
	    var letRefs = node._letReferences;
	    if (!letRefs) return;
	
	    this.traverse(visitor, {
	      letRefs: letRefs,
	      file: file
	    });
	  }
	};
	
	exports.BlockStatement = BlockStatement;
	exports.Program = BlockStatement;
	exports.Loop = BlockStatement;

/***/ },
/* 343 */
/*!**********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/react-compat.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.manipulateOptions = manipulateOptions;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _helpersReact = __webpack_require__(/*! ../../helpers/react */ 207);
	
	var react = _interopRequireWildcard(_helpersReact);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function manipulateOptions(opts) {
	  opts.blacklist.push("react");
	}
	
	var metadata = {
	  optional: true,
	  group: "builtin-advanced"
	};
	
	exports.metadata = metadata;
	__webpack_require__(/*! ../../helpers/build-react-transformer */ 344)(exports, {
	  pre: function pre(state) {
	    state.callee = state.tagExpr;
	  },
	
	  post: function post(state) {
	    if (react.isCompatTag(state.tagName)) {
	      state.call = t.callExpression(t.memberExpression(t.memberExpression(t.identifier("React"), t.identifier("DOM")), state.tagExpr, t.isLiteral(state.tagExpr)), state.args);
	    }
	  }
	});

/***/ },
/* 344 */
/*!**********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/build-react-transformer.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Based upon the excellent jsx-transpiler by Ingvar Stepanyan (RReverser)
	// https://github.com/RReverser/jsx-transpiler
	
	// jsx
	
	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangIsString = __webpack_require__(/*! lodash/lang/isString */ 148);
	
	var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
	
	var _messages = __webpack_require__(/*! ../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _esutils = __webpack_require__(/*! esutils */ 199);
	
	var _esutils2 = _interopRequireDefault(_esutils);
	
	var _react = __webpack_require__(/*! ./react */ 207);
	
	var react = _interopRequireWildcard(_react);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	exports["default"] = function (exports, opts) {
	  exports.JSXIdentifier = function (node, parent) {
	    if (node.name === "this" && this.isReferenced()) {
	      return t.thisExpression();
	    } else if (_esutils2["default"].keyword.isIdentifierNameES6(node.name)) {
	      node.type = "Identifier";
	    } else {
	      return t.literal(node.name);
	    }
	  };
	
	  exports.JSXNamespacedName = function (node, parent, scope, file) {
	    throw this.errorWithNode(messages.get("JSXNamespacedTags"));
	  };
	
	  exports.JSXMemberExpression = {
	    exit: function exit(node) {
	      node.computed = t.isLiteral(node.property);
	      node.type = "MemberExpression";
	    }
	  };
	
	  exports.JSXExpressionContainer = function (node) {
	    return node.expression;
	  };
	
	  exports.JSXAttribute = {
	    enter: function enter(node) {
	      var value = node.value;
	      if (t.isLiteral(value) && (0, _lodashLangIsString2["default"])(value.value)) {
	        value.value = value.value.replace(/\n\s+/g, " ");
	      }
	    },
	
	    exit: function exit(node) {
	      var value = node.value || t.literal(true);
	      return t.inherits(t.property("init", node.name, value), node);
	    }
	  };
	
	  exports.JSXOpeningElement = {
	    exit: function exit(node, parent, scope, file) {
	      parent.children = react.buildChildren(parent);
	
	      var tagExpr = node.name;
	      var args = [];
	
	      var tagName;
	      if (t.isIdentifier(tagExpr)) {
	        tagName = tagExpr.name;
	      } else if (t.isLiteral(tagExpr)) {
	        tagName = tagExpr.value;
	      }
	
	      var state = {
	        tagExpr: tagExpr,
	        tagName: tagName,
	        args: args
	      };
	
	      if (opts.pre) {
	        opts.pre(state, file);
	      }
	
	      var attribs = node.attributes;
	      if (attribs.length) {
	        attribs = buildJSXOpeningElementAttributes(attribs, file);
	      } else {
	        attribs = t.literal(null);
	      }
	
	      args.push(attribs);
	
	      if (opts.post) {
	        opts.post(state, file);
	      }
	
	      return state.call || t.callExpression(state.callee, args);
	    }
	  };
	
	  /**
	   * The logic for this is quite terse. It's because we need to
	   * support spread elements. We loop over all attributes,
	   * breaking on spreads, we then push a new object containg
	   * all prior attributes to an array for later processing.
	   */
	
	  var buildJSXOpeningElementAttributes = function buildJSXOpeningElementAttributes(attribs, file) {
	    var _props = [];
	    var objs = [];
	
	    var pushProps = function pushProps() {
	      if (!_props.length) return;
	
	      objs.push(t.objectExpression(_props));
	      _props = [];
	    };
	
	    while (attribs.length) {
	      var prop = attribs.shift();
	      if (t.isJSXSpreadAttribute(prop)) {
	        pushProps();
	        objs.push(prop.argument);
	      } else {
	        _props.push(prop);
	      }
	    }
	
	    pushProps();
	
	    if (objs.length === 1) {
	      // only one object
	      attribs = objs[0];
	    } else {
	      // looks like we have multiple objects
	      if (!t.isObjectExpression(objs[0])) {
	        objs.unshift(t.objectExpression([]));
	      }
	
	      // spread it
	      attribs = t.callExpression(file.addHelper("extends"), objs);
	    }
	
	    return attribs;
	  };
	
	  exports.JSXElement = {
	    exit: function exit(node) {
	      var callExpr = node.openingElement;
	
	      callExpr.arguments = callExpr.arguments.concat(node.children);
	
	      if (callExpr.arguments.length >= 3) {
	        callExpr._prettyCall = true;
	      }
	
	      return t.inherits(callExpr, node);
	    }
	  };
	
	  // display names
	
	  var addDisplayName = function addDisplayName(id, call) {
	    var props = call.arguments[0].properties;
	    var safe = true;
	
	    for (var i = 0; i < props.length; i++) {
	      var prop = props[i];
	      if (t.isIdentifier(prop.key, { name: "displayName" })) {
	        safe = false;
	        break;
	      }
	    }
	
	    if (safe) {
	      props.unshift(t.property("init", t.identifier("displayName"), t.literal(id)));
	    }
	  };
	
	  exports.ExportDefaultDeclaration = function (node, parent, scope, file) {
	    if (react.isCreateClass(node.declaration)) {
	      addDisplayName(file.opts.basename, node.declaration);
	    }
	  };
	
	  exports.AssignmentExpression = exports.Property = exports.VariableDeclarator = function (node) {
	    var left, right;
	
	    if (t.isAssignmentExpression(node)) {
	      left = node.left;
	      right = node.right;
	    } else if (t.isProperty(node)) {
	      left = node.key;
	      right = node.value;
	    } else if (t.isVariableDeclarator(node)) {
	      left = node.id;
	      right = node.init;
	    }
	
	    if (t.isMemberExpression(left)) {
	      left = left.property;
	    }
	
	    if (t.isIdentifier(left) && react.isCreateClass(right)) {
	      addDisplayName(left.name, right);
	    }
	  };
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 345 */
/*!***************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/react.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Program = Program;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _helpersReact = __webpack_require__(/*! ../../helpers/react */ 207);
	
	var react = _interopRequireWildcard(_helpersReact);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var JSX_ANNOTATION_REGEX = /^\*\s*@jsx\s+([^\s]+)/;
	
	var metadata = {
	  group: "builtin-advanced"
	};
	
	exports.metadata = metadata;
	
	function Program(node, parent, scope, file) {
	  var id = file.opts.jsxPragma;
	
	  for (var i = 0; i < file.ast.comments.length; i++) {
	    var comment = file.ast.comments[i];
	    var matches = JSX_ANNOTATION_REGEX.exec(comment.value);
	    if (matches) {
	      id = matches[1];
	      if (id === "React.DOM") {
	        throw file.errorWithNode(comment, "The @jsx React.DOM pragma has been deprecated as of React 0.12");
	      } else {
	        break;
	      }
	    }
	  }
	
	  file.set("jsxIdentifier", id.split(".").map(t.identifier).reduce(function (object, property) {
	    return t.memberExpression(object, property);
	  }));
	}
	
	__webpack_require__(/*! ../../helpers/build-react-transformer */ 344)(exports, {
	  pre: function pre(state) {
	    var tagName = state.tagName;
	    var args = state.args;
	    if (react.isCompatTag(tagName)) {
	      args.push(t.literal(tagName));
	    } else {
	      args.push(state.tagExpr);
	    }
	  },
	
	  post: function post(state, file) {
	    state.callee = file.get("jsxIdentifier");
	  }
	});

/***/ },
/* 346 */
/*!*********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/regenerator.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Func /*tion*/ = Func;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _regenerator = __webpack_require__(/*! regenerator */ 347);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var _astTypes = __webpack_require__(/*! ast-types */ 253);
	
	var metadata = {
	  group: "regenerator"
	};
	
	exports.metadata = metadata;
	
	function Func(node) {
	  if (node.async || node.generator) {
	    // Although this code transforms only the subtree rooted at the given
	    // Function node, that node might contain other generator functions
	    // that will also be transformed. It might help performance to ignore
	    // nested functions, and rely on the traversal to visit them later,
	    // but that's a small optimization. Starting here instead of at the
	    // root of the AST is the key optimization, since huge async/generator
	    // functions are relatively rare.
	    _regenerator2["default"].transform(convertTraversalPathToNodePath(this));
	  }
	}
	
	// Given a TraversalPath, return a NodePath that includes full ancestry
	// information (up to and including the Program node). This is complicated
	// by having to include intermediate objects like blockStatement.body
	// arrays, in addition to Node objects.
	function convertTraversalPathToNodePath(path) {
	  var programNode;
	  var keysAlongPath = [];
	
	  while (path) {
	    var pp = path.parentPath;
	    var parentNode = pp && pp.node;
	    if (parentNode) {
	      keysAlongPath.push(path.key);
	
	      if (parentNode !== path.container) {
	        var found = Object.keys(parentNode).some(function (containerKey) {
	          if (parentNode[containerKey] === path.container) {
	            keysAlongPath.push(containerKey);
	            return true;
	          }
	        });
	
	        if (!found) {
	          throw new Error("Failed to find container object in parent node");
	        }
	      }
	
	      if (t.isProgram(parentNode)) {
	        programNode = parentNode;
	        break;
	      }
	    }
	
	    path = pp;
	  }
	
	  if (!programNode) {
	    throw new Error("Failed to find root Program node");
	  }
	
	  var nodePath = new _astTypes.NodePath(programNode);
	
	  while (keysAlongPath.length > 0) {
	    nodePath = nodePath.get(keysAlongPath.pop());
	  }
	
	  return nodePath;
	}

/***/ },
/* 347 */
/*!******************************!*\
  !*** external "regenerator" ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("regenerator");

/***/ },
/* 348 */
/*!***********************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/other/runtime/index.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.pre = pre;
	exports.ReferencedIdentifier = ReferencedIdentifier;
	exports.CallExpression = CallExpression;
	exports.BinaryExpression = BinaryExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _traversal = __webpack_require__(/*! ../../../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _util = __webpack_require__(/*! ../../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _lodashObjectHas = __webpack_require__(/*! lodash/object/has */ 264);
	
	var _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);
	
	var _types = __webpack_require__(/*! ../../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var _definitions = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./definitions\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	var _definitions2 = _interopRequireDefault(_definitions);
	
	var isSymbolIterator = t.buildMatchMemberExpression("Symbol.iterator");
	
	var RUNTIME_MODULE_NAME = "babel-runtime";
	
	var metadata = {
	  optional: true,
	  group: "builtin-post-modules"
	};
	
	exports.metadata = metadata;
	
	function pre(file) {
	  file.set("helperGenerator", function (name) {
	    return file.addImport("" + RUNTIME_MODULE_NAME + "/helpers/" + name, name, "absoluteDefault");
	  });
	
	  file.setDynamic("regeneratorIdentifier", function () {
	    return file.addImport("" + RUNTIME_MODULE_NAME + "/regenerator", "regeneratorRuntime", "absoluteDefault");
	  });
	}
	
	function ReferencedIdentifier(node, parent, scope, file) {
	  if (node.name === "regeneratorRuntime") {
	    return file.get("regeneratorIdentifier");
	  }
	
	  if (t.isMemberExpression(parent)) return;
	  if (!(0, _lodashObjectHas2["default"])(_definitions2["default"].builtins, node.name)) return;
	  if (scope.getBindingIdentifier(node.name)) return;
	
	  // Symbol() -> _core.Symbol(); new Promise -> new _core.Promise
	  var modulePath = _definitions2["default"].builtins[node.name];
	  return file.addImport("" + RUNTIME_MODULE_NAME + "/core-js/" + modulePath, node.name, "absoluteDefault");
	}
	
	function CallExpression(node, parent, scope, file) {
	  // arr[Symbol.iterator]() -> _core.$for.getIterator(arr)
	
	  if (node.arguments.length) return;
	
	  var callee = node.callee;
	  if (!t.isMemberExpression(callee)) return;
	  if (!callee.computed) return;
	  if (!this.get("callee.property").matchesPattern("Symbol.iterator")) return;
	
	  return t.callExpression(file.addImport("" + RUNTIME_MODULE_NAME + "/core-js/get-iterator", "getIterator", "absoluteDefault"), [callee.object]);
	}
	
	function BinaryExpression(node, parent, scope, file) {
	  // Symbol.iterator in arr -> core.$for.isIterable(arr)
	
	  if (node.operator !== "in") return;
	  if (!this.get("left").matchesPattern("Symbol.iterator")) return;
	
	  return t.callExpression(file.addImport("" + RUNTIME_MODULE_NAME + "/core-js/is-iterable", "isIterable", "absoluteDefault"), [node.right]);
	}
	
	var MemberExpression = {
	  enter: function enter(node, parent, scope, file) {
	    // Array.from -> _core.Array.from
	
	    if (!this.isReferenced()) return;
	
	    var obj = node.object;
	    var prop = node.property;
	
	    if (!t.isReferenced(obj, node)) return;
	
	    if (node.computed) return;
	
	    if (!(0, _lodashObjectHas2["default"])(_definitions2["default"].methods, obj.name)) return;
	
	    var methods = _definitions2["default"].methods[obj.name];
	    if (!(0, _lodashObjectHas2["default"])(methods, prop.name)) return;
	
	    if (scope.getBindingIdentifier(obj.name)) return;
	
	    var modulePath = methods[prop.name];
	    return file.addImport("" + RUNTIME_MODULE_NAME + "/core-js/" + modulePath, "" + obj.name + "$" + prop.name, "absoluteDefault");
	  },
	
	  exit: function exit(node, parent, scope, file) {
	    if (!this.isReferenced()) return;
	
	    var prop = node.property;
	    var obj = node.object;
	
	    if (!(0, _lodashObjectHas2["default"])(_definitions2["default"].builtins, obj.name)) return;
	    if (scope.getBindingIdentifier(obj.name)) return;
	
	    var modulePath = _definitions2["default"].builtins[obj.name];
	    return t.memberExpression(file.addImport("" + RUNTIME_MODULE_NAME + "/core-js/" + modulePath, "" + obj.name, "absoluteDefault"), prop);
	  }
	};
	exports.MemberExpression = MemberExpression;

/***/ },
/* 349 */,
/* 350 */
/*!***************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/modules.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ImportDeclaration = ImportDeclaration;
	exports.ExportAllDeclaration = ExportAllDeclaration;
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function keepBlockHoist(node, nodes) {
	  if (node._blockHoist) {
	    for (var i = 0; i < nodes.length; i++) {
	      nodes[i]._blockHoist = node._blockHoist;
	    }
	  }
	}
	
	var metadata = {
	  group: "builtin-modules"
	};
	
	exports.metadata = metadata;
	
	function ImportDeclaration(node, parent, scope, file) {
	  // flow type
	  if (node.isType) return;
	
	  var nodes = [];
	
	  if (node.specifiers.length) {
	    for (var i = 0; i < node.specifiers.length; i++) {
	      file.moduleFormatter.importSpecifier(node.specifiers[i], node, nodes, parent);
	    }
	  } else {
	    file.moduleFormatter.importDeclaration(node, nodes, parent);
	  }
	
	  if (nodes.length === 1) {
	    // inherit `_blockHoist` - this is for `_blockHoist` in File.prototype.addImport
	    nodes[0]._blockHoist = node._blockHoist;
	  }
	
	  return nodes;
	}
	
	function ExportAllDeclaration(node, parent, scope, file) {
	  var nodes = [];
	  file.moduleFormatter.exportAllDeclaration(node, nodes, parent);
	  keepBlockHoist(node, nodes);
	  return nodes;
	}
	
	function ExportDefaultDeclaration(node, parent, scope, file) {
	  var nodes = [];
	  file.moduleFormatter.exportDeclaration(node, nodes, parent);
	  keepBlockHoist(node, nodes);
	  return nodes;
	}
	
	function ExportNamedDeclaration(node, parent, scope, file) {
	  // flow type
	  if (this.get("declaration").isTypeAlias()) return;
	
	  var nodes = [];
	
	  if (node.declaration) {
	    // make sure variable exports have an initializer
	    // this is done here to avoid duplicating it in the module formatters
	    if (t.isVariableDeclaration(node.declaration)) {
	      var declar = node.declaration.declarations[0];
	      declar.init = declar.init || t.identifier("undefined");
	    }
	
	    file.moduleFormatter.exportDeclaration(node, nodes, parent);
	  } else if (node.specifiers) {
	    for (var i = 0; i < node.specifiers.length; i++) {
	      file.moduleFormatter.exportSpecifier(node.specifiers[i], node, nodes, parent);
	    }
	  }
	
	  keepBlockHoist(node, nodes);
	
	  return nodes;
	}

/***/ },
/* 351 */
/*!*****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/internal/module-formatter.js ***!
  \*****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _helpersStrict = __webpack_require__(/*! ../../helpers/strict */ 352);
	
	var strict = _interopRequireWildcard(_helpersStrict);
	
	var metadata = {
	  group: "builtin-modules"
	};
	
	exports.metadata = metadata;
	var Program = {
	  exit: function exit(program, parent, scope, file) {
	    strict.wrap(program, function () {
	      // ensure that these are at the top, just like normal imports
	      var _arr = file.dynamicImports;
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var node = _arr[_i];
	        node._blockHoist = 3;
	      }
	
	      program.body = file.dynamicImports.concat(program.body);
	    });
	
	    if (!file.transformers["es6.modules"].canTransform()) return;
	
	    if (file.moduleFormatter.transform) {
	      file.moduleFormatter.transform(program);
	    }
	  }
	};
	exports.Program = Program;

/***/ },
/* 352 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/strict.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.has = has;
	exports.wrap = wrap;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function has(node) {
	  var first = node.body[0];
	  return t.isExpressionStatement(first) && t.isLiteral(first.expression, { value: "use strict" });
	}
	
	function wrap(node, callback) {
	  var useStrictNode;
	  if (has(node)) {
	    useStrictNode = node.body.shift();
	  }
	
	  callback();
	
	  if (useStrictNode) {
	    node.body.unshift(useStrictNode);
	  }
	}

/***/ },
/* 353 */
/*!*****************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es6/tail-call.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Func /*tion*/ = Func;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _lodashCollectionReduceRight = __webpack_require__(/*! lodash/collection/reduceRight */ 354);
	
	var _lodashCollectionReduceRight2 = _interopRequireDefault(_lodashCollectionReduceRight);
	
	var _messages = __webpack_require__(/*! ../../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _lodashArrayFlatten = __webpack_require__(/*! lodash/array/flatten */ 241);
	
	var _lodashArrayFlatten2 = _interopRequireDefault(_lodashArrayFlatten);
	
	var _traversal = __webpack_require__(/*! ../../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _util = __webpack_require__(/*! ../../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _lodashCollectionMap = __webpack_require__(/*! lodash/collection/map */ 361);
	
	var _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-trailing"
	};
	
	exports.metadata = metadata;
	
	function Func(node, parent, scope, file) {
	  if (node.generator || node.async) return;
	  var tailCall = new TailCallTransformer(this, scope, file);
	  tailCall.run();
	}
	
	function returnBlock(expr) {
	  return t.blockStatement([t.returnStatement(expr)]);
	}
	
	var visitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (t.isTryStatement(parent)) {
	      if (node === parent.block) {
	        this.skip();
	      } else if (parent.finalizer && node !== parent.finalizer) {
	        this.skip();
	      }
	    }
	  },
	
	  ReturnStatement: function ReturnStatement(node, parent, scope, state) {
	    return state.subTransform(node.argument);
	  },
	
	  Function: function Function(node, parent, scope, state) {
	    this.skip();
	  },
	
	  VariableDeclaration: function VariableDeclaration(node, parent, scope, state) {
	    state.vars.push(node);
	  },
	
	  ThisExpression: function ThisExpression(node, parent, scope, state) {
	    if (!state.isShadowed) {
	      state.needsThis = true;
	      state.thisPaths.push(this);
	    }
	  },
	
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {
	    if (node.name === "arguments" && (!state.isShadowed || node._shadowedFunctionLiteral)) {
	      state.needsArguments = true;
	      state.argumentsPaths.push(this);
	    }
	  }
	};
	
	var TailCallTransformer = (function () {
	  function TailCallTransformer(path, scope, file) {
	    _classCallCheck(this, TailCallTransformer);
	
	    this.hasTailRecursion = false;
	
	    this.needsArguments = false;
	    this.argumentsPaths = [];
	    this.setsArguments = false;
	
	    this.needsThis = false;
	    this.thisPaths = [];
	
	    this.isShadowed = path.isArrowFunctionExpression() || path.is("shadow");
	    this.ownerId = path.node.id;
	    this.vars = [];
	
	    this.scope = scope;
	    this.path = path;
	    this.file = file;
	    this.node = path.node;
	  }
	
	  TailCallTransformer.prototype.getArgumentsId = function getArgumentsId() {
	    return this.argumentsId = this.argumentsId || this.scope.generateUidIdentifier("arguments");
	  };
	
	  TailCallTransformer.prototype.getThisId = function getThisId() {
	    return this.thisId = this.thisId || this.scope.generateUidIdentifier("this");
	  };
	
	  TailCallTransformer.prototype.getLeftId = function getLeftId() {
	    return this.leftId = this.leftId || this.scope.generateUidIdentifier("left");
	  };
	
	  TailCallTransformer.prototype.getFunctionId = function getFunctionId() {
	    return this.functionId = this.functionId || this.scope.generateUidIdentifier("function");
	  };
	
	  TailCallTransformer.prototype.getAgainId = function getAgainId() {
	    return this.againId = this.againId || this.scope.generateUidIdentifier("again");
	  };
	
	  TailCallTransformer.prototype.getParams = function getParams() {
	    var params = this.params;
	
	    if (!params) {
	      params = this.node.params;
	      this.paramDecls = [];
	
	      for (var i = 0; i < params.length; i++) {
	        var param = params[i];
	        if (!param._isDefaultPlaceholder) {
	          this.paramDecls.push(t.variableDeclarator(param, params[i] = this.scope.generateUidIdentifier("x")));
	        }
	      }
	    }
	
	    return this.params = params;
	  };
	
	  TailCallTransformer.prototype.hasDeopt = function hasDeopt() {
	    // check if the ownerId has been reassigned, if it has then it's not safe to
	    // perform optimisations
	    var ownerIdInfo = this.scope.getBinding(this.ownerId.name);
	    return ownerIdInfo && !ownerIdInfo.constant;
	  };
	
	  TailCallTransformer.prototype.run = function run() {
	    var scope = this.scope;
	    var node = this.node;
	
	    // only tail recursion can be optimized as for now, so we can skip anonymous
	    // functions entirely
	    var ownerId = this.ownerId;
	    if (!ownerId) return;
	
	    // traverse the function and look for tail recursion
	    this.path.traverse(visitor, this);
	
	    // has no tail call recursion
	    if (!this.hasTailRecursion) return;
	
	    // the function binding isn't constant so we can't be sure that it's the same function :(
	    if (this.hasDeopt()) {
	      this.file.log.deopt(node, messages.get("tailCallReassignmentDeopt"));
	      return;
	    }
	
	    //
	
	    var body = t.ensureBlock(node).body;
	
	    for (var i = 0; i < body.length; i++) {
	      var bodyNode = body[i];
	      if (!t.isFunctionDeclaration(bodyNode)) continue;
	
	      bodyNode = body[i] = t.variableDeclaration("var", [t.variableDeclarator(bodyNode.id, t.toExpression(bodyNode))]);
	      bodyNode._blockHoist = 2;
	    }
	
	    if (this.vars.length > 0) {
	      var declarations = (0, _lodashArrayFlatten2["default"])((0, _lodashCollectionMap2["default"])(this.vars, function (decl) {
	        return decl.declarations;
	      }));
	
	      var assignment = (0, _lodashCollectionReduceRight2["default"])(declarations, function (expr, decl) {
	        return t.assignmentExpression("=", decl.id, expr);
	      }, t.identifier("undefined"));
	
	      var statement = t.expressionStatement(assignment);
	      statement._blockHoist = Infinity;
	      body.unshift(statement);
	    }
	
	    var paramDecls = this.paramDecls;
	    if (paramDecls.length > 0) {
	      var paramDecl = t.variableDeclaration("var", paramDecls);
	      paramDecl._blockHoist = Infinity;
	      body.unshift(paramDecl);
	    }
	
	    body.unshift(t.expressionStatement(t.assignmentExpression("=", this.getAgainId(), t.literal(false))));
	
	    node.body = util.template("tail-call-body", {
	      FUNCTION_ID: this.getFunctionId(),
	      AGAIN_ID: this.getAgainId(),
	      BLOCK: node.body
	    });
	
	    var topVars = [];
	
	    if (this.needsThis) {
	      var _arr = this.thisPaths;
	
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var path = _arr[_i];
	        path.replaceWith(this.getThisId());
	      }
	
	      topVars.push(t.variableDeclarator(this.getThisId(), t.thisExpression()));
	    }
	
	    if (this.needsArguments || this.setsArguments) {
	      var _arr2 = this.argumentsPaths;
	
	      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	        var path = _arr2[_i2];
	        path.replaceWith(this.argumentsId);
	      }
	
	      var decl = t.variableDeclarator(this.argumentsId);
	      if (this.argumentsId) {
	        decl.init = t.identifier("arguments");
	        decl.init._shadowedFunctionLiteral = true;
	      }
	      topVars.push(decl);
	    }
	
	    var leftId = this.leftId;
	    if (leftId) {
	      topVars.push(t.variableDeclarator(leftId));
	    }
	
	    if (topVars.length > 0) {
	      node.body.body.unshift(t.variableDeclaration("var", topVars));
	    }
	  };
	
	  TailCallTransformer.prototype.subTransform = function subTransform(node) {
	    if (!node) return;
	
	    var handler = this["subTransform" + node.type];
	    if (handler) return handler.call(this, node);
	  };
	
	  TailCallTransformer.prototype.subTransformConditionalExpression = function subTransformConditionalExpression(node) {
	    var callConsequent = this.subTransform(node.consequent);
	    var callAlternate = this.subTransform(node.alternate);
	    if (!callConsequent && !callAlternate) {
	      return;
	    }
	
	    // if ternary operator had tail recursion in value, convert to optimized if-statement
	    node.type = "IfStatement";
	    node.consequent = callConsequent ? t.toBlock(callConsequent) : returnBlock(node.consequent);
	
	    if (callAlternate) {
	      node.alternate = t.isIfStatement(callAlternate) ? callAlternate : t.toBlock(callAlternate);
	    } else {
	      node.alternate = returnBlock(node.alternate);
	    }
	
	    return [node];
	  };
	
	  TailCallTransformer.prototype.subTransformLogicalExpression = function subTransformLogicalExpression(node) {
	    // only call in right-value of can be optimized
	    var callRight = this.subTransform(node.right);
	    if (!callRight) return;
	
	    // cache left value as it might have side-effects
	    var leftId = this.getLeftId();
	    var testExpr = t.assignmentExpression("=", leftId, node.left);
	
	    if (node.operator === "&&") {
	      testExpr = t.unaryExpression("!", testExpr);
	    }
	
	    return [t.ifStatement(testExpr, returnBlock(leftId))].concat(callRight);
	  };
	
	  TailCallTransformer.prototype.subTransformSequenceExpression = function subTransformSequenceExpression(node) {
	    var seq = node.expressions;
	
	    // only last element can be optimized
	    var lastCall = this.subTransform(seq[seq.length - 1]);
	    if (!lastCall) {
	      return;
	    }
	
	    // remove converted expression from sequence
	    // and convert to regular expression if needed
	    if (--seq.length === 1) {
	      node = seq[0];
	    }
	
	    return [t.expressionStatement(node)].concat(lastCall);
	  };
	
	  TailCallTransformer.prototype.subTransformCallExpression = function subTransformCallExpression(node) {
	    var callee = node.callee;
	    var thisBinding, args;
	
	    if (t.isMemberExpression(callee, { computed: false }) && t.isIdentifier(callee.property)) {
	      switch (callee.property.name) {
	        case "call":
	          args = t.arrayExpression(node.arguments.slice(1));
	          break;
	
	        case "apply":
	          args = node.arguments[1] || t.identifier("undefined");
	          this.needsArguments = true;
	          break;
	
	        default:
	          return;
	      }
	
	      thisBinding = node.arguments[0];
	      callee = callee.object;
	    }
	
	    // only tail recursion can be optimized as for now
	    if (!t.isIdentifier(callee) || !this.scope.bindingIdentifierEquals(callee.name, this.ownerId)) {
	      return;
	    }
	
	    this.hasTailRecursion = true;
	
	    if (this.hasDeopt()) return;
	
	    var body = [];
	
	    if (this.needsThis && !t.isThisExpression(thisBinding)) {
	      body.push(t.expressionStatement(t.assignmentExpression("=", this.getThisId(), thisBinding || t.identifier("undefined"))));
	    }
	
	    if (!args) {
	      args = t.arrayExpression(node.arguments);
	    }
	
	    if (t.isArrayExpression(args) && args.elements.length > this.node.params.length) {
	      this.needsArguments = true;
	    }
	
	    var argumentsId = this.getArgumentsId();
	    var params = this.getParams();
	
	    if (this.needsArguments) {
	      body.push(t.expressionStatement(t.assignmentExpression("=", argumentsId, args)));
	    }
	
	    if (t.isArrayExpression(args)) {
	      var elems = args.elements;
	      for (var i = 0; i < elems.length && i < params.length; i++) {
	        var param = params[i];
	        var elem = elems[i] || (elems[i] = t.identifier("undefined"));
	        if (!param._isDefaultPlaceholder) {
	          elems[i] = t.assignmentExpression("=", param, elem);
	        }
	      }
	
	      if (!this.needsArguments) {
	        var _arr3 = elems;
	
	        for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	          var elem = _arr3[_i3];
	          body.push(t.expressionStatement(elem));
	        }
	      }
	    } else {
	      this.setsArguments = true;
	      for (var i = 0; i < params.length; i++) {
	        var param = params[i];
	        if (!param._isDefaultPlaceholder) {
	          body.push(t.expressionStatement(t.assignmentExpression("=", param, t.memberExpression(argumentsId, t.literal(i), true))));
	        }
	      }
	    }
	
	    body.push(t.expressionStatement(t.assignmentExpression("=", this.getAgainId(), t.literal(true))));
	
	    body.push(t.continueStatement(this.getFunctionId()));
	
	    return body;
	  };
	
	  return TailCallTransformer;
	})();

/***/ },
/* 354 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/reduceRight.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arrayReduceRight = __webpack_require__(/*! ../internal/arrayReduceRight */ 355),
	    baseEachRight = __webpack_require__(/*! ../internal/baseEachRight */ 356),
	    createReduce = __webpack_require__(/*! ../internal/createReduce */ 359);
	
	/**
	 * This method is like `_.reduce` except that it iterates over elements of
	 * `collection` from right to left.
	 *
	 * @static
	 * @memberOf _
	 * @alias foldr
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {*} Returns the accumulated value.
	 * @example
	 *
	 * var array = [[0, 1], [2, 3], [4, 5]];
	 *
	 * _.reduceRight(array, function(flattened, other) {
	 *   return flattened.concat(other);
	 * }, []);
	 * // => [4, 5, 2, 3, 0, 1]
	 */
	var reduceRight = createReduce(arrayReduceRight, baseEachRight);
	
	module.exports = reduceRight;


/***/ },
/* 355 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/arrayReduceRight.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `_.reduceRight` for arrays without support for
	 * callback shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initFromArray] Specify using the last element of `array`
	 *  as the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	  var length = array.length;
	  if (initFromArray && length) {
	    accumulator = array[--length];
	  }
	  while (length--) {
	    accumulator = iteratee(accumulator, array[length], length, array);
	  }
	  return accumulator;
	}
	
	module.exports = arrayReduceRight;


/***/ },
/* 356 */
/*!*********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseEachRight.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseForOwnRight = __webpack_require__(/*! ./baseForOwnRight */ 357),
	    createBaseEach = __webpack_require__(/*! ./createBaseEach */ 163);
	
	/**
	 * The base implementation of `_.forEachRight` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object|string} Returns `collection`.
	 */
	var baseEachRight = createBaseEach(baseForOwnRight, true);
	
	module.exports = baseEachRight;


/***/ },
/* 357 */
/*!***********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseForOwnRight.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseForRight = __webpack_require__(/*! ./baseForRight */ 358),
	    keys = __webpack_require__(/*! ../object/keys */ 131);
	
	/**
	 * The base implementation of `_.forOwnRight` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwnRight(object, iteratee) {
	  return baseForRight(object, iteratee, keys);
	}
	
	module.exports = baseForOwnRight;


/***/ },
/* 358 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseForRight.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(/*! ./createBaseFor */ 124);
	
	/**
	 * This function is like `baseFor` except that it iterates over properties
	 * in the opposite order.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseForRight = createBaseFor(true);
	
	module.exports = baseForRight;


/***/ },
/* 359 */
/*!********************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/createReduce.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseCallback = __webpack_require__(/*! ./baseCallback */ 166),
	    baseReduce = __webpack_require__(/*! ./baseReduce */ 360),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115);
	
	/**
	 * Creates a function for `_.reduce` or `_.reduceRight`.
	 *
	 * @private
	 * @param {Function} arrayFunc The function to iterate over an array.
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @returns {Function} Returns the new each function.
	 */
	function createReduce(arrayFunc, eachFunc) {
	  return function(collection, iteratee, accumulator, thisArg) {
	    var initFromArray = arguments.length < 3;
	    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	      ? arrayFunc(collection, iteratee, accumulator, initFromArray)
	      : baseReduce(collection, baseCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
	  };
	}
	
	module.exports = createReduce;


/***/ },
/* 360 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseReduce.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.reduce` and `_.reduceRight` without support
	 * for callback shorthands and `this` binding, which iterates over `collection`
	 * using the provided `eachFunc`.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} accumulator The initial value.
	 * @param {boolean} initFromCollection Specify using the first or last element
	 *  of `collection` as the initial value.
	 * @param {Function} eachFunc The function to iterate over `collection`.
	 * @returns {*} Returns the accumulated value.
	 */
	function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	  eachFunc(collection, function(value, index, collection) {
	    accumulator = initFromCollection
	      ? (initFromCollection = false, value)
	      : iteratee(accumulator, value, index, collection);
	  });
	  return accumulator;
	}
	
	module.exports = baseReduce;


/***/ },
/* 361 */
/*!*************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/map.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(/*! ../internal/arrayMap */ 362),
	    baseCallback = __webpack_require__(/*! ../internal/baseCallback */ 166),
	    baseMap = __webpack_require__(/*! ../internal/baseMap */ 363),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115);
	
	/**
	 * Creates an array of values by running each element in `collection` through
	 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * If a property name is provided for `iteratee` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `iteratee` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	 * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	 * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	 * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	 * `sum`, `uniq`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @alias collect
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function timesThree(n) {
	 *   return n * 3;
	 * }
	 *
	 * _.map([1, 2], timesThree);
	 * // => [3, 6]
	 *
	 * _.map({ 'a': 1, 'b': 2 }, timesThree);
	 * // => [3, 6] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // using the `_.property` callback shorthand
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee, thisArg) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  iteratee = baseCallback(iteratee, thisArg, 3);
	  return func(collection, iteratee);
	}
	
	module.exports = map;


/***/ },
/* 362 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/arrayMap.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `_.map` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	module.exports = arrayMap;


/***/ },
/* 363 */
/*!***************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseMap.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(/*! ./baseEach */ 161),
	    isArrayLike = __webpack_require__(/*! ./isArrayLike */ 110);
	
	/**
	 * The base implementation of `_.map` without support for callback shorthands
	 * and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];
	
	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}
	
	module.exports = baseMap;


/***/ },
/* 364 */
/*!*****************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/internal/shadow-functions.js ***!
  \*****************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ThisExpression = ThisExpression;
	exports.ReferencedIdentifier = ReferencedIdentifier;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-trailing"
	};
	
	exports.metadata = metadata;
	function remap(path, key, create) {
	  // ensure that we're shadowed
	  if (!path.inShadow()) return;
	
	  var fnPath = path.findParent(function (node, path) {
	    return !node.shadow && (path.isFunction() || path.isProgram());
	  });
	
	  var cached = fnPath.getData(key);
	  if (cached) return cached;
	
	  var init = create();
	  var id = path.scope.generateUidIdentifier(key);
	
	  fnPath.setData(key, id);
	  fnPath.scope.push({ id: id, init: init });
	
	  return id;
	}
	
	function ThisExpression() {
	  return remap(this, "this", function () {
	    return t.thisExpression();
	  });
	}
	
	function ReferencedIdentifier(node) {
	  if (node.name === "arguments" && !node._shadowedFunctionLiteral) {
	    return remap(this, "arguments", function () {
	      return t.identifier("arguments");
	    });
	  }
	}

/***/ },
/* 365 */
/*!*************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es3/property-literals.js ***!
  \*************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-trailing"
	};
	
	exports.metadata = metadata;
	var Property = {
	  exit: function exit(node) {
	    var key = node.key;
	    if (!node.computed && t.isIdentifier(key) && !t.isValidIdentifier(key.name)) {
	      // default: "bar" -> "default": "bar"
	      node.key = t.literal(key.name);
	    }
	  }
	};
	exports.Property = Property;

/***/ },
/* 366 */
/*!**********************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/es3/member-expression-literals.js ***!
  \**********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  group: "builtin-trailing"
	};
	
	exports.metadata = metadata;
	var MemberExpression = {
	  exit: function exit(node) {
	    var prop = node.property;
	    if (!node.computed && t.isIdentifier(prop) && !t.isValidIdentifier(prop.name)) {
	      // foo.default -> foo["default"]
	      node.property = t.literal(prop.name);
	      node.computed = true;
	    }
	  }
	};
	exports.MemberExpression = MemberExpression;

/***/ },
/* 367 */
/*!*******************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/minification/member-expression-literals.js ***!
  \*******************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  group: "builtin-trailing"
	};
	
	exports.metadata = metadata;
	var MemberExpression = {
	  exit: function exit(node) {
	    var prop = node.property;
	    if (node.computed && t.isLiteral(prop) && t.isValidIdentifier(prop.value)) {
	      // foo["bar"] => foo.bar
	      node.property = t.identifier(prop.value);
	      node.computed = false;
	    }
	  }
	};
	exports.MemberExpression = MemberExpression;

/***/ },
/* 368 */
/*!**********************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/minification/property-literals.js ***!
  \**********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var metadata = {
	  optional: true,
	  group: "builtin-trailing"
	};
	
	exports.metadata = metadata;
	var Property = {
	  exit: function exit(node) {
	    var key = node.key;
	    if (t.isLiteral(key) && t.isValidIdentifier(key.value)) {
	      // "foo": "bar" -> foo: "bar"
	      node.key = t.identifier(key.value);
	      node.computed = false;
	    }
	  }
	};
	exports.Property = Property;

/***/ },
/* 369 */
/*!************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/internal/block-hoist.js ***!
  \************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionSortBy = __webpack_require__(/*! lodash/collection/sortBy */ 370);
	
	var _lodashCollectionSortBy2 = _interopRequireDefault(_lodashCollectionSortBy);
	
	var metadata = {
	  group: "builtin-trailing"
	};
	
	exports.metadata = metadata;
	// Priority:
	//
	//  - 0 We want this to be at the **very** bottom
	//  - 1 Default node position
	//  - 2 Priority over normal nodes
	//  - 3 We want this to be at the **very** top
	
	var BlockStatement = {
	  exit: function exit(node) {
	    var hasChange = false;
	    for (var i = 0; i < node.body.length; i++) {
	      var bodyNode = node.body[i];
	      if (bodyNode && bodyNode._blockHoist != null) hasChange = true;
	    }
	    if (!hasChange) return;
	
	    node.body = (0, _lodashCollectionSortBy2["default"])(node.body, function (bodyNode) {
	      var priority = bodyNode && bodyNode._blockHoist;
	      if (priority == null) priority = 1;
	      if (priority === true) priority = 2;
	
	      // Higher priorities should move toward the top.
	      return -1 * priority;
	    });
	  }
	};
	
	exports.BlockStatement = BlockStatement;
	exports.Program = BlockStatement;

/***/ },
/* 370 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/sortBy.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseCallback = __webpack_require__(/*! ../internal/baseCallback */ 166),
	    baseMap = __webpack_require__(/*! ../internal/baseMap */ 363),
	    baseSortBy = __webpack_require__(/*! ../internal/baseSortBy */ 371),
	    compareAscending = __webpack_require__(/*! ../internal/compareAscending */ 372),
	    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ 136);
	
	/**
	 * Creates an array of elements, sorted in ascending order by the results of
	 * running each element in a collection through `iteratee`. This method performs
	 * a stable sort, that is, it preserves the original sort order of equal elements.
	 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * If a property name is provided for `iteratee` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `iteratee` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * _.sortBy([1, 2, 3], function(n) {
	 *   return Math.sin(n);
	 * });
	 * // => [3, 1, 2]
	 *
	 * _.sortBy([1, 2, 3], function(n) {
	 *   return this.sin(n);
	 * }, Math);
	 * // => [3, 1, 2]
	 *
	 * var users = [
	 *   { 'user': 'fred' },
	 *   { 'user': 'pebbles' },
	 *   { 'user': 'barney' }
	 * ];
	 *
	 * // using the `_.property` callback shorthand
	 * _.pluck(_.sortBy(users, 'user'), 'user');
	 * // => ['barney', 'fred', 'pebbles']
	 */
	function sortBy(collection, iteratee, thisArg) {
	  if (collection == null) {
	    return [];
	  }
	  if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	    iteratee = null;
	  }
	  var index = -1;
	  iteratee = baseCallback(iteratee, thisArg, 3);
	
	  var result = baseMap(collection, function(value, key, collection) {
	    return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
	  });
	  return baseSortBy(result, compareAscending);
	}
	
	module.exports = sortBy;


/***/ },
/* 371 */
/*!******************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseSortBy.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.sortBy` which uses `comparer` to define
	 * the sort order of `array` and replaces criteria objects with their
	 * corresponding values.
	 *
	 * @private
	 * @param {Array} array The array to sort.
	 * @param {Function} comparer The function to define sort order.
	 * @returns {Array} Returns `array`.
	 */
	function baseSortBy(array, comparer) {
	  var length = array.length;
	
	  array.sort(comparer);
	  while (length--) {
	    array[length] = array[length].value;
	  }
	  return array;
	}
	
	module.exports = baseSortBy;


/***/ },
/* 372 */
/*!************************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/compareAscending.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseCompareAscending = __webpack_require__(/*! ./baseCompareAscending */ 373);
	
	/**
	 * Used by `_.sortBy` to compare transformed elements of a collection and stable
	 * sort them in ascending order.
	 *
	 * @private
	 * @param {Object} object The object to compare to `other`.
	 * @param {Object} other The object to compare to `object`.
	 * @returns {number} Returns the sort order indicator for `object`.
	 */
	function compareAscending(object, other) {
	  return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	}
	
	module.exports = compareAscending;


/***/ },
/* 373 */
/*!****************************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseCompareAscending.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `compareAscending` which compares values and
	 * sorts them in ascending order without guaranteeing a stable sort.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {number} Returns the sort order indicator for `value`.
	 */
	function baseCompareAscending(value, other) {
	  if (value !== other) {
	    var valIsNull = value === null,
	        valIsUndef = value === undefined,
	        valIsReflexive = value === value;
	
	    var othIsNull = other === null,
	        othIsUndef = other === undefined,
	        othIsReflexive = other === other;
	
	    if ((value > other && !othIsNull) || !valIsReflexive ||
	        (valIsNull && !othIsUndef && othIsReflexive) ||
	        (valIsUndef && othIsReflexive)) {
	      return 1;
	    }
	    if ((value < other && !valIsNull) || !othIsReflexive ||
	        (othIsNull && !valIsUndef && valIsReflexive) ||
	        (othIsUndef && valIsReflexive)) {
	      return -1;
	    }
	  }
	  return 0;
	}
	
	module.exports = baseCompareAscending;


/***/ },
/* 374 */,
/* 375 */,
/* 376 */
/*!***********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/transformers/filters.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.internal = internal;
	exports.blacklist = blacklist;
	exports.whitelist = whitelist;
	exports.stage = stage;
	exports.optional = optional;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	function internal(transformer, opts) {
	  if (transformer.key[0] === "_") return true;
	}
	
	function blacklist(transformer, opts) {
	  var blacklist = opts.blacklist;
	  if (blacklist.length && (0, _lodashCollectionIncludes2["default"])(blacklist, transformer.key)) return false;
	}
	
	function whitelist(transformer, opts) {
	  var whitelist = opts.whitelist;
	  if (whitelist) return (0, _lodashCollectionIncludes2["default"])(whitelist, transformer.key);
	}
	
	function stage(transformer, opts) {
	  var stage = transformer.metadata.stage;
	  if (stage != null && stage >= opts.stage) return true;
	}
	
	function optional(transformer, opts) {
	  if (transformer.metadata.optional && !(0, _lodashCollectionIncludes2["default"])(opts.optional, transformer.key)) return false;
	}

/***/ },
/* 377 */,
/* 378 */,
/* 379 */
/*!********************************************************!*\
  !*** ./~/babel-core/lib/babel/api/register/browser.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	__webpack_require__(/*! ../../polyfill */ 4);
	
	// required to safely use babel/register within a browserify codebase
	
	exports["default"] = function () {};
	
	;
	
	module.exports = exports["default"];

/***/ },
/* 380 */
/*!*****************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/buffer.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _repeating = __webpack_require__(/*! repeating */ 211);
	
	var _repeating2 = _interopRequireDefault(_repeating);
	
	var _trimRight = __webpack_require__(/*! trim-right */ 381);
	
	var _trimRight2 = _interopRequireDefault(_trimRight);
	
	var _lodashLangIsBoolean = __webpack_require__(/*! lodash/lang/isBoolean */ 208);
	
	var _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _lodashLangIsNumber = __webpack_require__(/*! lodash/lang/isNumber */ 201);
	
	var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
	
	var Buffer = (function () {
	  function Buffer(position, format) {
	    _classCallCheck(this, Buffer);
	
	    this.position = position;
	    this._indent = format.indent.base;
	    this.format = format;
	    this.buf = "";
	  }
	
	  Buffer.prototype.get = function get() {
	    return (0, _trimRight2["default"])(this.buf);
	  };
	
	  Buffer.prototype.getIndent = function getIndent() {
	    if (this.format.compact || this.format.concise) {
	      return "";
	    } else {
	      return (0, _repeating2["default"])(this.format.indent.style, this._indent);
	    }
	  };
	
	  Buffer.prototype.indentSize = function indentSize() {
	    return this.getIndent().length;
	  };
	
	  Buffer.prototype.indent = function indent() {
	    this._indent++;
	  };
	
	  Buffer.prototype.dedent = function dedent() {
	    this._indent--;
	  };
	
	  Buffer.prototype.semicolon = function semicolon() {
	    this.push(";");
	  };
	
	  Buffer.prototype.ensureSemicolon = function ensureSemicolon() {
	    if (!this.isLast(";")) this.semicolon();
	  };
	
	  Buffer.prototype.rightBrace = function rightBrace() {
	    this.newline(true);
	    this.push("}");
	  };
	
	  Buffer.prototype.keyword = function keyword(name) {
	    this.push(name);
	    this.space();
	  };
	
	  Buffer.prototype.space = function space() {
	    if (this.format.compact) return;
	    if (this.buf && !this.isLast(" ") && !this.isLast("\n")) {
	      this.push(" ");
	    }
	  };
	
	  Buffer.prototype.removeLast = function removeLast(cha) {
	    if (this.format.compact) return;
	    if (!this.isLast(cha)) return;
	
	    this.buf = this.buf.substr(0, this.buf.length - 1);
	    this.position.unshift(cha);
	  };
	
	  Buffer.prototype.newline = function newline(i, removeLast) {
	    if (this.format.compact || this.format.retainLines) return;
	
	    if (this.format.concise) {
	      this.space();
	      return;
	    }
	
	    removeLast = removeLast || false;
	
	    if ((0, _lodashLangIsNumber2["default"])(i)) {
	      i = Math.min(2, i);
	
	      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
	      if (i <= 0) return;
	
	      while (i > 0) {
	        this._newline(removeLast);
	        i--;
	      }
	      return;
	    }
	
	    if ((0, _lodashLangIsBoolean2["default"])(i)) {
	      removeLast = i;
	    }
	
	    this._newline(removeLast);
	  };
	
	  Buffer.prototype._newline = function _newline(removeLast) {
	    // never allow more than two lines
	    if (this.endsWith("\n\n")) return;
	
	    // remove the last newline
	    if (removeLast && this.isLast("\n")) this.removeLast("\n");
	
	    this.removeLast(" ");
	    this._removeSpacesAfterLastNewline();
	    this._push("\n");
	  };
	
	  /**
	   * If buffer ends with a newline and some spaces after it, trim those spaces.
	   */
	
	  Buffer.prototype._removeSpacesAfterLastNewline = function _removeSpacesAfterLastNewline() {
	    var lastNewlineIndex = this.buf.lastIndexOf("\n");
	    if (lastNewlineIndex === -1) {
	      return;
	    }
	
	    var index = this.buf.length - 1;
	    while (index > lastNewlineIndex) {
	      if (this.buf[index] !== " ") {
	        break;
	      }
	
	      index--;
	    }
	
	    if (index === lastNewlineIndex) {
	      this.buf = this.buf.substring(0, index + 1);
	    }
	  };
	
	  Buffer.prototype.push = function push(str, noIndent) {
	    if (!this.format.compact && this._indent && !noIndent && str !== "\n") {
	      // we have an indent level and we aren't pushing a newline
	      var indent = this.getIndent();
	
	      // replace all newlines with newlines with the indentation
	      str = str.replace(/\n/g, "\n" + indent);
	
	      // we've got a newline before us so prepend on the indentation
	      if (this.isLast("\n")) this._push(indent);
	    }
	
	    this._push(str);
	  };
	
	  Buffer.prototype._push = function _push(str) {
	    this.position.push(str);
	    this.buf += str;
	  };
	
	  Buffer.prototype.endsWith = function endsWith(str) {
	    return this.buf.slice(-str.length) === str;
	  };
	
	  Buffer.prototype.isLast = function isLast(cha) {
	    if (this.format.compact) return false;
	
	    var buf = this.buf;
	    var last = buf[buf.length - 1];
	
	    if (Array.isArray(cha)) {
	      return (0, _lodashCollectionIncludes2["default"])(cha, last);
	    } else {
	      return cha === last;
	    }
	  };
	
	  return Buffer;
	})();
	
	exports["default"] = Buffer;
	module.exports = exports["default"];

/***/ },
/* 381 */
/*!*****************************!*\
  !*** external "trim-right" ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("trim-right");

/***/ },
/* 382 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/base.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.File = File;
	exports.Program = Program;
	exports.BlockStatement = BlockStatement;
	
	function File(node, print) {
	  print(node.program);
	}
	
	function Program(node, print) {
	  print.sequence(node.body);
	}
	
	function BlockStatement(node, print) {
	  if (node.body.length === 0) {
	    this.push("{}");
	  } else {
	    this.push("{");
	    this.newline();
	    print.sequence(node.body, { indent: true });
	    if (!this.format.retainLines) this.removeLast("\n");
	    this.rightBrace();
	  }
	}

/***/ },
/* 383 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/classes.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ClassDeclaration = ClassDeclaration;
	exports.ClassBody = ClassBody;
	exports.ClassProperty = ClassProperty;
	exports.MethodDefinition = MethodDefinition;
	
	function ClassDeclaration(node, print) {
	  print.list(node.decorators);
	  this.push("class");
	
	  if (node.id) {
	    this.push(" ");
	    print(node.id);
	  }
	
	  print(node.typeParameters);
	
	  if (node.superClass) {
	    this.push(" extends ");
	    print(node.superClass);
	    print(node.superTypeParameters);
	  }
	
	  if (node["implements"]) {
	    this.push(" implements ");
	    print.join(node["implements"], { separator: ", " });
	  }
	
	  this.space();
	  print(node.body);
	}
	
	exports.ClassExpression = ClassDeclaration;
	
	function ClassBody(node, print) {
	  if (node.body.length === 0) {
	    this.push("{}");
	  } else {
	    this.push("{");
	    this.newline();
	
	    this.indent();
	    print.sequence(node.body);
	    this.dedent();
	
	    this.rightBrace();
	  }
	}
	
	function ClassProperty(node, print) {
	  print.list(node.decorators);
	
	  if (node["static"]) this.push("static ");
	  print(node.key);
	  print(node.typeAnnotation);
	  if (node.value) {
	    this.space();
	    this.push("=");
	    this.space();
	    print(node.value);
	  }
	  this.semicolon();
	}
	
	function MethodDefinition(node, print) {
	  print.list(node.decorators);
	
	  if (node["static"]) {
	    this.push("static ");
	  }
	
	  this._method(node, print);
	}

/***/ },
/* 384 */
/*!************************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/comprehensions.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ComprehensionBlock = ComprehensionBlock;
	exports.ComprehensionExpression = ComprehensionExpression;
	
	function ComprehensionBlock(node, print) {
	  this.keyword("for");
	  this.push("(");
	  print(node.left);
	  this.push(" of ");
	  print(node.right);
	  this.push(")");
	}
	
	function ComprehensionExpression(node, print) {
	  this.push(node.generator ? "(" : "[");
	
	  print.join(node.blocks, { separator: " " });
	  this.space();
	
	  if (node.filter) {
	    this.keyword("if");
	    this.push("(");
	    print(node.filter);
	    this.push(")");
	    this.space();
	  }
	
	  print(node.body);
	
	  this.push(node.generator ? ")" : "]");
	}

/***/ },
/* 385 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/expressions.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.UnaryExpression = UnaryExpression;
	exports.DoExpression = DoExpression;
	exports.UpdateExpression = UpdateExpression;
	exports.ConditionalExpression = ConditionalExpression;
	exports.NewExpression = NewExpression;
	exports.SequenceExpression = SequenceExpression;
	exports.ThisExpression = ThisExpression;
	exports.Super = Super;
	exports.Decorator = Decorator;
	exports.CallExpression = CallExpression;
	exports.EmptyStatement = EmptyStatement;
	exports.ExpressionStatement = ExpressionStatement;
	exports.AssignmentExpression = AssignmentExpression;
	exports.BindExpression = BindExpression;
	exports.MemberExpression = MemberExpression;
	exports.MetaProperty = MetaProperty;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _isInteger = __webpack_require__(/*! is-integer */ 386);
	
	var _isInteger2 = _interopRequireDefault(_isInteger);
	
	var _lodashLangIsNumber = __webpack_require__(/*! lodash/lang/isNumber */ 201);
	
	var _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function UnaryExpression(node, print) {
	  var hasSpace = /[a-z]$/.test(node.operator);
	  var arg = node.argument;
	
	  if (t.isUpdateExpression(arg) || t.isUnaryExpression(arg)) {
	    hasSpace = true;
	  }
	
	  if (t.isUnaryExpression(arg) && arg.operator === "!") {
	    hasSpace = false;
	  }
	
	  this.push(node.operator);
	  if (hasSpace) this.push(" ");
	  print(node.argument);
	}
	
	function DoExpression(node, print) {
	  this.push("do");
	  this.space();
	  print(node.body);
	}
	
	function UpdateExpression(node, print) {
	  if (node.prefix) {
	    this.push(node.operator);
	    print(node.argument);
	  } else {
	    print(node.argument);
	    this.push(node.operator);
	  }
	}
	
	function ConditionalExpression(node, print) {
	  print(node.test);
	  this.space();
	  this.push("?");
	  this.space();
	  print(node.consequent);
	  this.space();
	  this.push(":");
	  this.space();
	  print(node.alternate);
	}
	
	function NewExpression(node, print) {
	  this.push("new ");
	  print(node.callee);
	  this.push("(");
	  print.list(node.arguments);
	  this.push(")");
	}
	
	function SequenceExpression(node, print) {
	  print.list(node.expressions);
	}
	
	function ThisExpression() {
	  this.push("this");
	}
	
	function Super() {
	  this.push("super");
	}
	
	function Decorator(node, print) {
	  this.push("@");
	  print(node.expression);
	}
	
	function CallExpression(node, print) {
	  print(node.callee);
	
	  this.push("(");
	
	  var separator = ",";
	
	  var isPrettyCall = node._prettyCall && !this.format.retainLines;
	
	  if (isPrettyCall) {
	    separator += "\n";
	    this.newline();
	    this.indent();
	  } else {
	    separator += " ";
	  }
	
	  print.list(node.arguments, { separator: separator });
	
	  if (isPrettyCall) {
	    this.newline();
	    this.dedent();
	  }
	
	  this.push(")");
	}
	
	var buildYieldAwait = function buildYieldAwait(keyword) {
	  return function (node, print) {
	    this.push(keyword);
	
	    if (node.delegate || node.all) {
	      this.push("*");
	    }
	
	    if (node.argument) {
	      this.push(" ");
	      print(node.argument);
	    }
	  };
	};
	
	var YieldExpression = buildYieldAwait("yield");
	exports.YieldExpression = YieldExpression;
	var AwaitExpression = buildYieldAwait("await");
	
	exports.AwaitExpression = AwaitExpression;
	
	function EmptyStatement() {
	  this.semicolon();
	}
	
	function ExpressionStatement(node, print) {
	  print(node.expression);
	  this.semicolon();
	}
	
	function AssignmentExpression(node, print) {
	  // todo: add cases where the spaces can be dropped when in compact mode
	  print(node.left);
	  this.push(" ");
	  this.push(node.operator);
	  this.push(" ");
	  print(node.right);
	}
	
	function BindExpression(node, print) {
	  print(node.object);
	  this.push("::");
	  print(node.callee);
	}
	
	exports.BinaryExpression = AssignmentExpression;
	exports.LogicalExpression = AssignmentExpression;
	exports.AssignmentPattern = AssignmentExpression;
	
	var SCIENTIFIC_NOTATION = /e/i;
	
	function MemberExpression(node, print) {
	  var obj = node.object;
	  print(obj);
	
	  if (!node.computed && t.isMemberExpression(node.property)) {
	    throw new TypeError("Got a MemberExpression for MemberExpression property");
	  }
	
	  var computed = node.computed;
	  if (t.isLiteral(node.property) && (0, _lodashLangIsNumber2["default"])(node.property.value)) {
	    computed = true;
	  }
	
	  if (computed) {
	    this.push("[");
	    print(node.property);
	    this.push("]");
	  } else {
	    // 5..toFixed(2);
	    if (t.isLiteral(obj) && (0, _isInteger2["default"])(obj.value) && !SCIENTIFIC_NOTATION.test(obj.value.toString())) {
	      this.push(".");
	    }
	
	    this.push(".");
	    print(node.property);
	  }
	}
	
	function MetaProperty(node, print) {
	  print(node.meta);
	  this.push(".");
	  print(node.property);
	}

/***/ },
/* 386 */
/*!*****************************!*\
  !*** external "is-integer" ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("is-integer");

/***/ },
/* 387 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/flow.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.AnyTypeAnnotation = AnyTypeAnnotation;
	exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
	exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
	exports.DeclareClass = DeclareClass;
	exports.DeclareFunction = DeclareFunction;
	exports.DeclareModule = DeclareModule;
	exports.DeclareVariable = DeclareVariable;
	exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
	exports.FunctionTypeParam = FunctionTypeParam;
	exports.InterfaceExtends = InterfaceExtends;
	exports._interfaceish = _interfaceish;
	exports.InterfaceDeclaration = InterfaceDeclaration;
	exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
	exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.NumberTypeAnnotation = NumberTypeAnnotation;
	exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
	exports.StringTypeAnnotation = StringTypeAnnotation;
	exports.TupleTypeAnnotation = TupleTypeAnnotation;
	exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
	exports.TypeAlias = TypeAlias;
	exports.TypeAnnotation = TypeAnnotation;
	exports.TypeParameterInstantiation = TypeParameterInstantiation;
	exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
	exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
	exports.ObjectTypeIndexer = ObjectTypeIndexer;
	exports.ObjectTypeProperty = ObjectTypeProperty;
	exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
	exports.UnionTypeAnnotation = UnionTypeAnnotation;
	exports.TypeCastExpression = TypeCastExpression;
	exports.VoidTypeAnnotation = VoidTypeAnnotation;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function AnyTypeAnnotation() {
	  this.push("any");
	}
	
	function ArrayTypeAnnotation(node, print) {
	  print(node.elementType);
	  this.push("[");
	  this.push("]");
	}
	
	function BooleanTypeAnnotation(node) {
	  this.push("bool");
	}
	
	function DeclareClass(node, print) {
	  this.push("declare class ");
	  this._interfaceish(node, print);
	}
	
	function DeclareFunction(node, print) {
	  this.push("declare function ");
	  print(node.id);
	  print(node.id.typeAnnotation.typeAnnotation);
	  this.semicolon();
	}
	
	function DeclareModule(node, print) {
	  this.push("declare module ");
	  print(node.id);
	  this.space();
	  print(node.body);
	}
	
	function DeclareVariable(node, print) {
	  this.push("declare var ");
	  print(node.id);
	  print(node.id.typeAnnotation);
	  this.semicolon();
	}
	
	function FunctionTypeAnnotation(node, print, parent) {
	  print(node.typeParameters);
	  this.push("(");
	  print.list(node.params);
	
	  if (node.rest) {
	    if (node.params.length) {
	      this.push(",");
	      this.space();
	    }
	    this.push("...");
	    print(node.rest);
	  }
	
	  this.push(")");
	
	  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying
	  if (parent.type === "ObjectTypeProperty" || parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction") {
	    this.push(":");
	  } else {
	    this.space();
	    this.push("=>");
	  }
	
	  this.space();
	  print(node.returnType);
	}
	
	function FunctionTypeParam(node, print) {
	  print(node.name);
	  if (node.optional) this.push("?");
	  this.push(":");
	  this.space();
	  print(node.typeAnnotation);
	}
	
	function InterfaceExtends(node, print) {
	  print(node.id);
	  print(node.typeParameters);
	}
	
	exports.ClassImplements = InterfaceExtends;
	exports.GenericTypeAnnotation = InterfaceExtends;
	
	function _interfaceish(node, print) {
	  print(node.id);
	  print(node.typeParameters);
	  if (node["extends"].length) {
	    this.push(" extends ");
	    print.join(node["extends"], { separator: ", " });
	  }
	  this.space();
	  print(node.body);
	}
	
	function InterfaceDeclaration(node, print) {
	  this.push("interface ");
	  this._interfaceish(node, print);
	}
	
	function IntersectionTypeAnnotation(node, print) {
	  print.join(node.types, { separator: " & " });
	}
	
	function NullableTypeAnnotation(node, print) {
	  this.push("?");
	  print(node.typeAnnotation);
	}
	
	function NumberTypeAnnotation() {
	  this.push("number");
	}
	
	function StringLiteralTypeAnnotation(node) {
	  this._stringLiteral(node.value);
	}
	
	function StringTypeAnnotation() {
	  this.push("string");
	}
	
	function TupleTypeAnnotation(node, print) {
	  this.push("[");
	  print.join(node.types, { separator: ", " });
	  this.push("]");
	}
	
	function TypeofTypeAnnotation(node, print) {
	  this.push("typeof ");
	  print(node.argument);
	}
	
	function TypeAlias(node, print) {
	  this.push("type ");
	  print(node.id);
	  print(node.typeParameters);
	  this.space();
	  this.push("=");
	  this.space();
	  print(node.right);
	  this.semicolon();
	}
	
	function TypeAnnotation(node, print) {
	  this.push(":");
	  this.space();
	  if (node.optional) this.push("?");
	  print(node.typeAnnotation);
	}
	
	function TypeParameterInstantiation(node, print) {
	  this.push("<");
	  print.join(node.params, { separator: ", " });
	  this.push(">");
	}
	
	exports.TypeParameterDeclaration = TypeParameterInstantiation;
	
	function ObjectTypeAnnotation(node, print) {
	  var _this = this;
	
	  this.push("{");
	  var props = node.properties.concat(node.callProperties, node.indexers);
	
	  if (props.length) {
	    this.space();
	
	    print.list(props, {
	      separator: false,
	      indent: true,
	      iterator: function iterator() {
	        if (props.length !== 1) {
	          _this.semicolon();
	          _this.space();
	        }
	      }
	    });
	
	    this.space();
	  }
	
	  this.push("}");
	}
	
	function ObjectTypeCallProperty(node, print) {
	  if (node["static"]) this.push("static ");
	  print(node.value);
	}
	
	function ObjectTypeIndexer(node, print) {
	  if (node["static"]) this.push("static ");
	  this.push("[");
	  print(node.id);
	  this.push(":");
	  this.space();
	  print(node.key);
	  this.push("]");
	  this.push(":");
	  this.space();
	  print(node.value);
	}
	
	function ObjectTypeProperty(node, print) {
	  if (node["static"]) this.push("static ");
	  print(node.key);
	  if (node.optional) this.push("?");
	  if (!t.isFunctionTypeAnnotation(node.value)) {
	    this.push(":");
	    this.space();
	  }
	  print(node.value);
	}
	
	function QualifiedTypeIdentifier(node, print) {
	  print(node.qualification);
	  this.push(".");
	  print(node.id);
	}
	
	function UnionTypeAnnotation(node, print) {
	  print.join(node.types, { separator: " | " });
	}
	
	function TypeCastExpression(node, print) {
	  this.push("(");
	  print(node.expression);
	  print(node.typeAnnotation);
	  this.push(")");
	}
	
	function VoidTypeAnnotation(node) {
	  this.push("void");
	}

/***/ },
/* 388 */
/*!*************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/jsx.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.JSXAttribute = JSXAttribute;
	exports.JSXIdentifier = JSXIdentifier;
	exports.JSXNamespacedName = JSXNamespacedName;
	exports.JSXMemberExpression = JSXMemberExpression;
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	exports.JSXExpressionContainer = JSXExpressionContainer;
	exports.JSXElement = JSXElement;
	exports.JSXOpeningElement = JSXOpeningElement;
	exports.JSXClosingElement = JSXClosingElement;
	exports.JSXEmptyExpression = JSXEmptyExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function JSXAttribute(node, print) {
	  print(node.name);
	  if (node.value) {
	    this.push("=");
	    print(node.value);
	  }
	}
	
	function JSXIdentifier(node) {
	  this.push(node.name);
	}
	
	function JSXNamespacedName(node, print) {
	  print(node.namespace);
	  this.push(":");
	  print(node.name);
	}
	
	function JSXMemberExpression(node, print) {
	  print(node.object);
	  this.push(".");
	  print(node.property);
	}
	
	function JSXSpreadAttribute(node, print) {
	  this.push("{...");
	  print(node.argument);
	  this.push("}");
	}
	
	function JSXExpressionContainer(node, print) {
	  this.push("{");
	  print(node.expression);
	  this.push("}");
	}
	
	function JSXElement(node, print) {
	  var open = node.openingElement;
	  print(open);
	  if (open.selfClosing) return;
	
	  this.indent();
	  var _arr = node.children;
	  for (var _i = 0; _i < _arr.length; _i++) {
	    var child = _arr[_i];
	    if (t.isLiteral(child)) {
	      this.push(child.value, true);
	    } else {
	      print(child);
	    }
	  }
	  this.dedent();
	
	  print(node.closingElement);
	}
	
	function JSXOpeningElement(node, print) {
	  this.push("<");
	  print(node.name);
	  if (node.attributes.length > 0) {
	    this.push(" ");
	    print.join(node.attributes, { separator: " " });
	  }
	  this.push(node.selfClosing ? " />" : ">");
	}
	
	function JSXClosingElement(node, print) {
	  this.push("</");
	  print(node.name);
	  this.push(">");
	}
	
	function JSXEmptyExpression() {}

/***/ },
/* 389 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/methods.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports._params = _params;
	exports._method = _method;
	exports.FunctionExpression = FunctionExpression;
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function _params(node, print) {
	  var _this = this;
	
	  print(node.typeParameters);
	  this.push("(");
	  print.list(node.params, {
	    iterator: function iterator(node) {
	      if (node.optional) _this.push("?");
	      print(node.typeAnnotation);
	    }
	  });
	  this.push(")");
	
	  if (node.returnType) {
	    print(node.returnType);
	  }
	}
	
	function _method(node, print) {
	  var value = node.value;
	  var kind = node.kind;
	  var key = node.key;
	
	  if (kind === "method" || kind === "init") {
	    if (value.generator) {
	      this.push("*");
	    }
	  }
	
	  if (kind === "get" || kind === "set") {
	    this.push(kind + " ");
	  }
	
	  if (value.async) this.push("async ");
	
	  if (node.computed) {
	    this.push("[");
	    print(key);
	    this.push("]");
	  } else {
	    print(key);
	  }
	
	  this._params(value, print);
	  this.push(" ");
	  print(value.body);
	}
	
	function FunctionExpression(node, print) {
	  if (node.async) this.push("async ");
	  this.push("function");
	  if (node.generator) this.push("*");
	
	  if (node.id) {
	    this.push(" ");
	    print(node.id);
	  } else {
	    this.space();
	  }
	
	  this._params(node, print);
	  this.space();
	  print(node.body);
	}
	
	exports.FunctionDeclaration = FunctionExpression;
	
	function ArrowFunctionExpression(node, print) {
	  if (node.async) this.push("async ");
	
	  if (node.params.length === 1 && t.isIdentifier(node.params[0])) {
	    print(node.params[0]);
	  } else {
	    this._params(node, print);
	  }
	
	  this.push(" => ");
	
	  var bodyNeedsParens = t.isObjectExpression(node.body);
	
	  if (bodyNeedsParens) {
	    this.push("(");
	  }
	
	  print(node.body);
	
	  if (bodyNeedsParens) {
	    this.push(")");
	  }
	}

/***/ },
/* 390 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/modules.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.ImportSpecifier = ImportSpecifier;
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
	exports.ExportSpecifier = ExportSpecifier;
	exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
	exports.ExportAllDeclaration = ExportAllDeclaration;
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.ImportDeclaration = ImportDeclaration;
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function ImportSpecifier(node, print) {
	  print(node.imported);
	  if (node.local && node.local.name !== node.imported.name) {
	    this.push(" as ");
	    print(node.local);
	  }
	}
	
	function ImportDefaultSpecifier(node, print) {
	  print(node.local);
	}
	
	function ExportDefaultSpecifier(node, print) {
	  print(node.exported);
	}
	
	function ExportSpecifier(node, print) {
	  print(node.local);
	  if (node.exported && node.local.name !== node.exported.name) {
	    this.push(" as ");
	    print(node.exported);
	  }
	}
	
	function ExportNamespaceSpecifier(node, print) {
	  this.push("* as ");
	  print(node.exported);
	}
	
	function ExportAllDeclaration(node, print) {
	  this.push("export *");
	  if (node.exported) {
	    this.push(" as ");
	    print(node.exported);
	  }
	  this.push(" from ");
	  print(node.source);
	  this.semicolon();
	}
	
	function ExportNamedDeclaration(node, print) {
	  this.push("export ");
	  ExportDeclaration.call(this, node, print);
	}
	
	function ExportDefaultDeclaration(node, print) {
	  this.push("export default ");
	  ExportDeclaration.call(this, node, print);
	}
	
	function ExportDeclaration(node, print) {
	  var specifiers = node.specifiers;
	
	  if (node.declaration) {
	    var declar = node.declaration;
	    print(declar);
	    if (t.isStatement(declar) || t.isFunction(declar) || t.isClass(declar)) return;
	  } else {
	    var first = specifiers[0];
	    var hasSpecial = false;
	    if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {
	      hasSpecial = true;
	      print(specifiers.shift());
	      if (specifiers.length) {
	        this.push(", ");
	      }
	    }
	
	    if (specifiers.length || !specifiers.length && !hasSpecial) {
	      this.push("{");
	      if (specifiers.length) {
	        this.space();
	        print.join(specifiers, { separator: ", " });
	        this.space();
	      }
	      this.push("}");
	    }
	
	    if (node.source) {
	      this.push(" from ");
	      print(node.source);
	    }
	  }
	
	  this.ensureSemicolon();
	}
	
	function ImportDeclaration(node, print) {
	  this.push("import ");
	
	  if (node.isType) {
	    this.push("type ");
	  }
	
	  var specfiers = node.specifiers;
	  if (specfiers && specfiers.length) {
	    var first = node.specifiers[0];
	    if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {
	      print(node.specifiers.shift());
	      if (node.specifiers.length) {
	        this.push(", ");
	      }
	    }
	
	    if (node.specifiers.length) {
	      this.push("{");
	      this.space();
	      print.join(node.specifiers, { separator: ", " });
	      this.space();
	      this.push("}");
	    }
	
	    this.push(" from ");
	  }
	
	  print(node.source);
	  this.semicolon();
	}
	
	function ImportNamespaceSpecifier(node, print) {
	  this.push("* as ");
	  print(node.local);
	}

/***/ },
/* 391 */
/*!********************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/statements.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.WithStatement = WithStatement;
	exports.IfStatement = IfStatement;
	exports.ForStatement = ForStatement;
	exports.WhileStatement = WhileStatement;
	exports.DoWhileStatement = DoWhileStatement;
	exports.LabeledStatement = LabeledStatement;
	exports.TryStatement = TryStatement;
	exports.CatchClause = CatchClause;
	exports.ThrowStatement = ThrowStatement;
	exports.SwitchStatement = SwitchStatement;
	exports.SwitchCase = SwitchCase;
	exports.DebuggerStatement = DebuggerStatement;
	exports.VariableDeclaration = VariableDeclaration;
	exports.VariableDeclarator = VariableDeclarator;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _repeating = __webpack_require__(/*! repeating */ 211);
	
	var _repeating2 = _interopRequireDefault(_repeating);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function WithStatement(node, print) {
	  this.keyword("with");
	  this.push("(");
	  print(node.object);
	  this.push(")");
	  print.block(node.body);
	}
	
	function IfStatement(node, print) {
	  this.keyword("if");
	  this.push("(");
	  print(node.test);
	  this.push(")");
	  this.space();
	
	  print.indentOnComments(node.consequent);
	
	  if (node.alternate) {
	    if (this.isLast("}")) this.space();
	    this.push("else ");
	    print.indentOnComments(node.alternate);
	  }
	}
	
	function ForStatement(node, print) {
	  this.keyword("for");
	  this.push("(");
	
	  print(node.init);
	  this.push(";");
	
	  if (node.test) {
	    this.push(" ");
	    print(node.test);
	  }
	  this.push(";");
	
	  if (node.update) {
	    this.push(" ");
	    print(node.update);
	  }
	
	  this.push(")");
	  print.block(node.body);
	}
	
	function WhileStatement(node, print) {
	  this.keyword("while");
	  this.push("(");
	  print(node.test);
	  this.push(")");
	  print.block(node.body);
	}
	
	var buildForXStatement = function buildForXStatement(op) {
	  return function (node, print) {
	    this.keyword("for");
	    this.push("(");
	    print(node.left);
	    this.push(" " + op + " ");
	    print(node.right);
	    this.push(")");
	    print.block(node.body);
	  };
	};
	
	var ForInStatement = buildForXStatement("in");
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = buildForXStatement("of");
	
	exports.ForOfStatement = ForOfStatement;
	
	function DoWhileStatement(node, print) {
	  this.push("do ");
	  print(node.body);
	  this.space();
	  this.keyword("while");
	  this.push("(");
	  print(node.test);
	  this.push(");");
	}
	
	var buildLabelStatement = function buildLabelStatement(prefix, key) {
	  return function (node, print) {
	    this.push(prefix);
	
	    var label = node[key || "label"];
	    if (label) {
	      this.push(" ");
	      print(label);
	    }
	
	    this.semicolon();
	  };
	};
	
	var ContinueStatement = buildLabelStatement("continue");
	exports.ContinueStatement = ContinueStatement;
	var ReturnStatement = buildLabelStatement("return", "argument");
	exports.ReturnStatement = ReturnStatement;
	var BreakStatement = buildLabelStatement("break");
	
	exports.BreakStatement = BreakStatement;
	
	function LabeledStatement(node, print) {
	  print(node.label);
	  this.push(": ");
	  print(node.body);
	}
	
	function TryStatement(node, print) {
	  this.keyword("try");
	  print(node.block);
	  this.space();
	
	  // Esprima bug puts the catch clause in a `handlers` array.
	  // see https://code.google.com/p/esprima/issues/detail?id=433
	  // We run into this from regenerator generated ast.
	  if (node.handlers) {
	    print(node.handlers[0]);
	  } else {
	    print(node.handler);
	  }
	
	  if (node.finalizer) {
	    this.space();
	    this.push("finally ");
	    print(node.finalizer);
	  }
	}
	
	function CatchClause(node, print) {
	  this.keyword("catch");
	  this.push("(");
	  print(node.param);
	  this.push(") ");
	  print(node.body);
	}
	
	function ThrowStatement(node, print) {
	  this.push("throw ");
	  print(node.argument);
	  this.semicolon();
	}
	
	function SwitchStatement(node, print) {
	  this.keyword("switch");
	  this.push("(");
	  print(node.discriminant);
	  this.push(")");
	  this.space();
	  this.push("{");
	
	  print.sequence(node.cases, {
	    indent: true,
	    addNewlines: function addNewlines(leading, cas) {
	      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
	    }
	  });
	
	  this.push("}");
	}
	
	function SwitchCase(node, print) {
	  if (node.test) {
	    this.push("case ");
	    print(node.test);
	    this.push(":");
	  } else {
	    this.push("default:");
	  }
	
	  if (node.consequent.length) {
	    this.newline();
	    print.sequence(node.consequent, { indent: true });
	  }
	}
	
	function DebuggerStatement() {
	  this.push("debugger;");
	}
	
	function VariableDeclaration(node, print, parent) {
	  this.push(node.kind + " ");
	
	  var hasInits = false;
	  // don't add whitespace to loop heads
	  if (!t.isFor(parent)) {
	    var _arr = node.declarations;
	
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var declar = _arr[_i];
	      if (declar.init) {
	        // has an init so let's split it up over multiple lines
	        hasInits = true;
	      }
	    }
	  }
	
	  var sep = ",";
	  if (!this.format.compact && !this.format.concise && hasInits && !this.format.retainLines) {
	    sep += "\n" + (0, _repeating2["default"])(" ", node.kind.length + 1);
	  } else {
	    sep += " ";
	  }
	
	  print.list(node.declarations, { separator: sep });
	
	  if (t.isFor(parent)) {
	    if (parent.left === node || parent.init === node) return;
	  }
	
	  this.semicolon();
	}
	
	function VariableDeclarator(node, print) {
	  print(node.id);
	  print(node.id.typeAnnotation);
	  if (node.init) {
	    this.space();
	    this.push("=");
	    this.space();
	    print(node.init);
	  }
	}

/***/ },
/* 392 */
/*!***************************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/template-literals.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	exports.TemplateElement = TemplateElement;
	exports.TemplateLiteral = TemplateLiteral;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	function TaggedTemplateExpression(node, print) {
	  print(node.tag);
	  print(node.quasi);
	}
	
	function TemplateElement(node) {
	  this._push(node.value.raw);
	}
	
	function TemplateLiteral(node, print) {
	  this.push("`");
	
	  var quasis = node.quasis;
	  var len = quasis.length;
	
	  for (var i = 0; i < len; i++) {
	    print(quasis[i]);
	
	    if (i + 1 < len) {
	      this.push("${ ");
	      print(node.expressions[i]);
	      this.push(" }");
	    }
	  }
	
	  this._push("`");
	}

/***/ },
/* 393 */
/*!***************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/generators/types.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.Identifier = Identifier;
	exports.RestElement = RestElement;
	exports.ObjectExpression = ObjectExpression;
	exports.Property = Property;
	exports.ArrayExpression = ArrayExpression;
	exports.Literal = Literal;
	exports._stringLiteral = _stringLiteral;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function Identifier(node) {
	  this.push(node.name);
	}
	
	function RestElement(node, print) {
	  this.push("...");
	  print(node.argument);
	}
	
	exports.SpreadElement = RestElement;
	exports.SpreadProperty = RestElement;
	
	function ObjectExpression(node, print) {
	  var props = node.properties;
	
	  if (props.length) {
	    this.push("{");
	    this.space();
	
	    print.list(props, { indent: true });
	
	    this.space();
	    this.push("}");
	  } else {
	    this.push("{}");
	  }
	}
	
	exports.ObjectPattern = ObjectExpression;
	
	function Property(node, print) {
	  if (node.method || node.kind === "get" || node.kind === "set") {
	    this._method(node, print);
	  } else {
	    if (node.computed) {
	      this.push("[");
	      print(node.key);
	      this.push("]");
	    } else {
	      // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`
	      if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {
	        print(node.value);
	        return;
	      }
	
	      print(node.key);
	
	      // shorthand!
	      if (node.shorthand && (t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name)) {
	        return;
	      }
	    }
	
	    this.push(":");
	    this.space();
	    print(node.value);
	  }
	}
	
	function ArrayExpression(node, print) {
	  var elems = node.elements;
	  var len = elems.length;
	
	  this.push("[");
	
	  for (var i = 0; i < elems.length; i++) {
	    var elem = elems[i];
	    if (!elem) {
	      // If the array expression ends with a hole, that hole
	      // will be ignored by the interpreter, but if it ends with
	      // two (or more) holes, we need to write out two (or more)
	      // commas so that the resulting code is interpreted with
	      // both (all) of the holes.
	      this.push(",");
	    } else {
	      if (i > 0) this.push(" ");
	      print(elem);
	      if (i < len - 1) this.push(",");
	    }
	  }
	
	  this.push("]");
	}
	
	exports.ArrayPattern = ArrayExpression;
	
	function Literal(node) {
	  var val = node.value;
	  var type = typeof val;
	
	  if (type === "string") {
	    this._stringLiteral(val);
	  } else if (type === "number") {
	    this.push(val + "");
	  } else if (type === "boolean") {
	    this.push(val ? "true" : "false");
	  } else if (node.regex) {
	    this.push("/" + node.regex.pattern + "/" + node.regex.flags);
	  } else if (val === null) {
	    this.push("null");
	  }
	}
	
	function _stringLiteral(val) {
	  val = JSON.stringify(val);
	
	  // escape illegal js but valid json unicode characters
	  val = val.replace(/[\u000A\u000D\u2028\u2029]/g, function (c) {
	    return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
	  });
	
	  if (this.format.quotes === "single") {
	    val = val.slice(1, -1);
	    val = val.replace(/\\"/g, "\"");
	    val = val.replace(/'/g, "\\'");
	    val = "'" + val + "'";
	  }
	
	  this.push(val);
	}

/***/ },
/* 394 */
/*!****************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/index.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _detectIndent = __webpack_require__(/*! detect-indent */ 395);
	
	var _detectIndent2 = _interopRequireDefault(_detectIndent);
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 396);
	
	var _whitespace2 = _interopRequireDefault(_whitespace);
	
	var _repeating = __webpack_require__(/*! repeating */ 211);
	
	var _repeating2 = _interopRequireDefault(_repeating);
	
	var _sourceMap = __webpack_require__(/*! ./source-map */ 397);
	
	var _sourceMap2 = _interopRequireDefault(_sourceMap);
	
	var _position = __webpack_require__(/*! ./position */ 399);
	
	var _position2 = _interopRequireDefault(_position);
	
	var _messages = __webpack_require__(/*! ../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _buffer = __webpack_require__(/*! ./buffer */ 380);
	
	var _buffer2 = _interopRequireDefault(_buffer);
	
	var _lodashObjectExtend = __webpack_require__(/*! lodash/object/extend */ 138);
	
	var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _node = __webpack_require__(/*! ./node */ 400);
	
	var _node2 = _interopRequireDefault(_node);
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var CodeGenerator = (function () {
	  function CodeGenerator(ast, opts, code) {
	    _classCallCheck(this, CodeGenerator);
	
	    opts = opts || {};
	
	    this.comments = ast.comments || [];
	    this.tokens = ast.tokens || [];
	    this.format = CodeGenerator.normalizeOptions(code, opts, this.tokens);
	    this.opts = opts;
	    this.ast = ast;
	
	    this.whitespace = new _whitespace2["default"](this.tokens, this.comments, this.format);
	    this.position = new _position2["default"]();
	    this.map = new _sourceMap2["default"](this.position, opts, code);
	    this.buffer = new _buffer2["default"](this.position, this.format);
	  }
	
	  CodeGenerator.normalizeOptions = function normalizeOptions(code, opts, tokens) {
	    var style = "  ";
	    if (code) {
	      var indent = (0, _detectIndent2["default"])(code).indent;
	      if (indent && indent !== " ") style = indent;
	    }
	
	    var format = {
	      retainLines: opts.retainLines,
	      comments: opts.comments == null || opts.comments,
	      compact: opts.compact,
	      quotes: CodeGenerator.findCommonStringDelimiter(code, tokens),
	      indent: {
	        adjustMultilineComment: true,
	        style: style,
	        base: 0
	      }
	    };
	
	    if (format.compact === "auto") {
	      format.compact = code.length > 100000; // 100KB
	
	      if (format.compact) {
	        console.error("[BABEL] " + messages.get("codeGeneratorDeopt", opts.filename, "100KB"));
	      }
	    }
	
	    return format;
	  };
	
	  CodeGenerator.findCommonStringDelimiter = function findCommonStringDelimiter(code, tokens) {
	    var occurences = {
	      single: 0,
	      double: 0
	    };
	
	    var checked = 0;
	
	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i];
	      if (token.type.label !== "string") continue;
	      if (checked >= 3) continue;
	
	      var raw = code.slice(token.start, token.end);
	      if (raw[0] === "'") {
	        occurences.single++;
	      } else {
	        occurences.double++;
	      }
	
	      checked++;
	    }
	
	    if (occurences.single > occurences.double) {
	      return "single";
	    } else {
	      return "double";
	    }
	  };
	
	  CodeGenerator.prototype.generate = function generate() {
	    var ast = this.ast;
	
	    this.print(ast);
	
	    if (ast.comments) {
	      var comments = [];
	      var _arr = ast.comments;
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var comment = _arr[_i];
	        if (!comment._displayed) comments.push(comment);
	      }
	      this._printComments(comments);
	    }
	
	    return {
	      map: this.map.get(),
	      code: this.buffer.get()
	    };
	  };
	
	  CodeGenerator.prototype.buildPrint = function buildPrint(parent) {
	    var _this = this;
	
	    var print = function print(node, opts) {
	      return _this.print(node, parent, opts);
	    };
	
	    print.sequence = function (nodes) {
	      var opts = arguments[1] === undefined ? {} : arguments[1];
	
	      opts.statement = true;
	      return _this.printJoin(print, nodes, opts);
	    };
	
	    print.join = function (nodes, opts) {
	      return _this.printJoin(print, nodes, opts);
	    };
	
	    print.list = function (items) {
	      var opts = arguments[1] === undefined ? {} : arguments[1];
	
	      if (opts.separator == null) opts.separator = ", ";
	      print.join(items, opts);
	    };
	
	    print.block = function (node) {
	      return _this.printBlock(print, node);
	    };
	
	    print.indentOnComments = function (node) {
	      return _this.printAndIndentOnComments(print, node);
	    };
	
	    return print;
	  };
	
	  CodeGenerator.prototype.catchUp = function catchUp(node, parent, leftParenPrinted) {
	    // catch up to this nodes newline if we're behind
	    if (node.loc && this.format.retainLines && this.buffer.buf) {
	      var needsParens = false;
	      if (!leftParenPrinted && parent && this.position.line < node.loc.start.line && t.isTerminatorless(parent)) {
	        needsParens = true;
	        this._push("(");
	      }
	      while (this.position.line < node.loc.start.line) {
	        this._push("\n");
	      }
	      return needsParens;
	    }
	    return false;
	  };
	
	  CodeGenerator.prototype.print = function print(node, parent) {
	    var _this2 = this;
	
	    var opts = arguments[2] === undefined ? {} : arguments[2];
	
	    if (!node) return;
	
	    if (parent && parent._compact) {
	      node._compact = true;
	    }
	
	    var oldConcise = this.format.concise;
	    if (node._compact) {
	      this.format.concise = true;
	    }
	
	    var newline = function newline(leading) {
	      if (!opts.statement && !_node2["default"].isUserWhitespacable(node, parent)) {
	        return;
	      }
	
	      var lines = 0;
	
	      if (node.start != null && !node._ignoreUserWhitespace) {
	        // user node
	        if (leading) {
	          lines = _this2.whitespace.getNewlinesBefore(node);
	        } else {
	          lines = _this2.whitespace.getNewlinesAfter(node);
	        }
	      } else {
	        // generated node
	        if (!leading) lines++; // always include at least a single line after
	        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
	
	        var needs = _node2["default"].needsWhitespaceAfter;
	        if (leading) needs = _node2["default"].needsWhitespaceBefore;
	        if (needs(node, parent)) lines++;
	
	        // generated nodes can't add starting file whitespace
	        if (!_this2.buffer.buf) lines = 0;
	      }
	
	      _this2.newline(lines);
	    };
	
	    if (this[node.type]) {
	      var needsNoLineTermParens = _node2["default"].needsParensNoLineTerminator(node, parent);
	      var needsParens = needsNoLineTermParens || _node2["default"].needsParens(node, parent);
	
	      if (needsParens) this.push("(");
	      if (needsNoLineTermParens) this.indent();
	
	      this.printLeadingComments(node, parent);
	
	      var needsParensFromCatchup = this.catchUp(node, parent, needsParens);
	
	      newline(true);
	
	      if (opts.before) opts.before();
	      this.map.mark(node, "start");
	
	      this[node.type](node, this.buildPrint(node), parent);
	
	      if (needsNoLineTermParens) {
	        this.newline();
	        this.dedent();
	      }
	      if (needsParens || needsParensFromCatchup) this.push(")");
	
	      this.map.mark(node, "end");
	      if (opts.after) opts.after();
	
	      this.format.concise = oldConcise;
	
	      newline(false);
	
	      this.printTrailingComments(node, parent);
	    } else {
	      throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
	    }
	  };
	
	  CodeGenerator.prototype.printJoin = function printJoin(print, nodes) {
	    var _this3 = this;
	
	    var opts = arguments[2] === undefined ? {} : arguments[2];
	
	    if (!nodes || !nodes.length) return;
	
	    var len = nodes.length;
	
	    if (opts.indent) this.indent();
	
	    for (var i = 0; i < nodes.length; i++) {
	      var node = nodes[i];
	      print(node, {
	        statement: opts.statement,
	        addNewlines: opts.addNewlines,
	        after: function after() {
	          if (opts.iterator) {
	            opts.iterator(node, i);
	          }
	
	          if (opts.separator && i < len - 1) {
	            _this3.push(opts.separator);
	          }
	        }
	      });
	    }
	
	    if (opts.indent) this.dedent();
	  };
	
	  CodeGenerator.prototype.printAndIndentOnComments = function printAndIndentOnComments(print, node) {
	    var indent = !!node.leadingComments;
	    if (indent) this.indent();
	    print(node);
	    if (indent) this.dedent();
	  };
	
	  CodeGenerator.prototype.printBlock = function printBlock(print, node) {
	    if (t.isEmptyStatement(node)) {
	      this.semicolon();
	    } else {
	      this.push(" ");
	      print(node);
	    }
	  };
	
	  CodeGenerator.prototype.generateComment = function generateComment(comment) {
	    var val = comment.value;
	    if (comment.type === "Line") {
	      val = "//" + val;
	    } else {
	      val = "/*" + val + "*/";
	    }
	    return val;
	  };
	
	  CodeGenerator.prototype.printTrailingComments = function printTrailingComments(node, parent) {
	    this._printComments(this.getComments("trailingComments", node, parent));
	  };
	
	  CodeGenerator.prototype.printLeadingComments = function printLeadingComments(node, parent) {
	    this._printComments(this.getComments("leadingComments", node, parent));
	  };
	
	  CodeGenerator.prototype.getComments = function getComments(key, node, parent) {
	    if (t.isExpressionStatement(parent)) {
	      return [];
	    }
	
	    var comments = [];
	    var nodes = [node];
	
	    if (t.isExpressionStatement(node)) {
	      nodes.push(node.argument);
	    }
	
	    var _arr2 = nodes;
	    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	      var node = _arr2[_i2];
	      comments = comments.concat(this._getComments(key, node));
	    }
	
	    return comments;
	  };
	
	  CodeGenerator.prototype._getComments = function _getComments(key, node) {
	    return node && node[key] || [];
	  };
	
	  CodeGenerator.prototype._printComments = function _printComments(comments) {
	    if (this.format.compact) return;
	    if (!this.format.comments) return;
	    if (!comments || !comments.length) return;
	
	    var _arr3 = comments;
	    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	      var comment = _arr3[_i3];
	      var skip = false;
	
	      if (this.ast.comments) {
	        // find the original comment in the ast and set it as displayed
	        var _arr4 = this.ast.comments;
	        for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
	          var origComment = _arr4[_i4];
	          if (origComment.start === comment.start) {
	            // comment has already been output
	            if (origComment._displayed) skip = true;
	
	            origComment._displayed = true;
	            break;
	          }
	        }
	      }
	
	      if (skip) return;
	
	      this.catchUp(comment);
	
	      // whitespace before
	      this.newline(this.whitespace.getNewlinesBefore(comment));
	
	      var column = this.position.column;
	      var val = this.generateComment(comment);
	
	      if (column && !this.isLast(["\n", " ", "[", "{"])) {
	        this._push(" ");
	        column++;
	      }
	
	      //
	      if (comment.type === "Block" && this.format.indent.adjustMultilineComment) {
	        var offset = comment.loc.start.column;
	        if (offset) {
	          var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
	          val = val.replace(newlineRegex, "\n");
	        }
	
	        var indent = Math.max(this.indentSize(), column);
	        val = val.replace(/\n/g, "\n" + (0, _repeating2["default"])(" ", indent));
	      }
	
	      if (column === 0) {
	        val = this.getIndent() + val;
	      }
	
	      // force a newline for line comments when retainLines is set in case the next printed node
	      // doesn't catch up
	      if (this.format.retainLines && comment.type === "Line") {
	        val += "\n";
	      }
	
	      //
	      this._push(val);
	
	      // whitespace after
	      this.newline(this.whitespace.getNewlinesAfter(comment));
	    }
	  };
	
	  _createClass(CodeGenerator, null, [{
	    key: "generators",
	    value: {
	      templateLiterals: __webpack_require__(/*! ./generators/template-literals */ 392),
	      comprehensions: __webpack_require__(/*! ./generators/comprehensions */ 384),
	      expressions: __webpack_require__(/*! ./generators/expressions */ 385),
	      statements: __webpack_require__(/*! ./generators/statements */ 391),
	      classes: __webpack_require__(/*! ./generators/classes */ 383),
	      methods: __webpack_require__(/*! ./generators/methods */ 389),
	      modules: __webpack_require__(/*! ./generators/modules */ 390),
	      types: __webpack_require__(/*! ./generators/types */ 393),
	      flow: __webpack_require__(/*! ./generators/flow */ 387),
	      base: __webpack_require__(/*! ./generators/base */ 382),
	      jsx: __webpack_require__(/*! ./generators/jsx */ 388)
	    },
	    enumerable: true
	  }]);
	
	  return CodeGenerator;
	})();
	
	(0, _lodashCollectionEach2["default"])(_buffer2["default"].prototype, function (fn, key) {
	  CodeGenerator.prototype[key] = function () {
	    return fn.apply(this.buffer, arguments);
	  };
	});
	
	(0, _lodashCollectionEach2["default"])(CodeGenerator.generators, function (generator) {
	  (0, _lodashObjectExtend2["default"])(CodeGenerator.prototype, generator);
	});
	
	module.exports = function (ast, opts, code) {
	  var gen = new CodeGenerator(ast, opts, code);
	  return gen.generate();
	};
	
	module.exports.CodeGenerator = CodeGenerator;

/***/ },
/* 395 */
/*!********************************!*\
  !*** external "detect-indent" ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("detect-indent");

/***/ },
/* 396 */
/*!*********************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/whitespace.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _lodashCollectionSortBy = __webpack_require__(/*! lodash/collection/sortBy */ 370);
	
	var _lodashCollectionSortBy2 = _interopRequireDefault(_lodashCollectionSortBy);
	
	/**
	 * Returns `i`th number from `base`, continuing from 0 when `max` is reached.
	 * Useful for shifting `for` loop by a fixed number but going over all items.
	 *
	 * @param {Number} i Current index in the loop
	 * @param {Number} base Start index for which to return 0
	 * @param {Number} max Array length
	 * @returns {Number} shiftedIndex
	 */
	
	function getLookupIndex(i, base, max) {
	  i += base;
	
	  if (i >= max) {
	    i -= max;
	  }
	
	  return i;
	}
	
	var Whitespace = (function () {
	  function Whitespace(tokens, comments) {
	    _classCallCheck(this, Whitespace);
	
	    this.tokens = (0, _lodashCollectionSortBy2["default"])(tokens.concat(comments), "start");
	    this.used = {};
	
	    // Profiling this code shows that while generator passes over it, indexes
	    // returned by `getNewlinesBefore` and `getNewlinesAfter` are always increasing.
	
	    // We use this implementation detail for an optimization: instead of always
	    // starting to look from `this.tokens[0]`, we will start `for` loops from the
	    // previous successful match. We will enumerate all tokens—but the common
	    // case will be much faster.
	
	    this._lastFoundIndex = 0;
	  }
	
	  Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {
	    var startToken;
	    var endToken;
	    var tokens = this.tokens;
	    var token;
	
	    for (var j = 0; j < tokens.length; j++) {
	      // optimize for forward traversal by shifting for loop index
	      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
	      token = tokens[i];
	
	      // this is the token this node starts with
	      if (node.start === token.start) {
	        startToken = tokens[i - 1];
	        endToken = token;
	
	        this._lastFoundIndex = i;
	        break;
	      }
	    }
	
	    return this.getNewlinesBetween(startToken, endToken);
	  };
	
	  Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {
	    var startToken;
	    var endToken;
	    var tokens = this.tokens;
	    var token;
	
	    for (var j = 0; j < tokens.length; j++) {
	      // optimize for forward traversal by shifting for loop index
	      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
	      token = tokens[i];
	
	      // this is the token this node ends with
	      if (node.end === token.end) {
	        startToken = token;
	        endToken = tokens[i + 1];
	
	        this._lastFoundIndex = i;
	        break;
	      }
	    }
	
	    if (endToken && endToken.type.label === "eof") {
	      return 1;
	    } else {
	      var lines = this.getNewlinesBetween(startToken, endToken);
	      if (node.type === "Line" && !lines) {
	        // line comment
	        return 1;
	      } else {
	        return lines;
	      }
	    }
	  };
	
	  Whitespace.prototype.getNewlinesBetween = function getNewlinesBetween(startToken, endToken) {
	    if (!endToken || !endToken.loc) return 0;
	
	    var start = startToken ? startToken.loc.end.line : 1;
	    var end = endToken.loc.start.line;
	    var lines = 0;
	
	    for (var line = start; line < end; line++) {
	      if (typeof this.used[line] === "undefined") {
	        this.used[line] = true;
	        lines++;
	      }
	    }
	
	    return lines;
	  };
	
	  return Whitespace;
	})();
	
	exports["default"] = Whitespace;
	module.exports = exports["default"];

/***/ },
/* 397 */
/*!*********************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/source-map.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _sourceMap = __webpack_require__(/*! source-map */ 398);
	
	var _sourceMap2 = _interopRequireDefault(_sourceMap);
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var SourceMap = (function () {
	  function SourceMap(position, opts, code) {
	    _classCallCheck(this, SourceMap);
	
	    this.position = position;
	    this.opts = opts;
	
	    if (opts.sourceMaps) {
	      this.map = new _sourceMap2["default"].SourceMapGenerator({
	        file: opts.sourceMapTarget,
	        sourceRoot: opts.sourceRoot
	      });
	
	      this.map.setSourceContent(opts.sourceFileName, code);
	    } else {
	      this.map = null;
	    }
	  }
	
	  SourceMap.prototype.get = function get() {
	    var map = this.map;
	    if (map) {
	      return map.toJSON();
	    } else {
	      return map;
	    }
	  };
	
	  SourceMap.prototype.mark = function mark(node, type) {
	    var loc = node.loc;
	    if (!loc) return; // no location info
	
	    var map = this.map;
	    if (!map) return; // no source map
	
	    if (t.isProgram(node) || t.isFile(node)) return; // illegal mapping nodes
	
	    var position = this.position;
	
	    var generated = {
	      line: position.line,
	      column: position.column
	    };
	
	    var original = loc[type];
	
	    map.addMapping({
	      source: this.opts.sourceFileName,
	      generated: generated,
	      original: original
	    });
	  };
	
	  return SourceMap;
	})();
	
	exports["default"] = SourceMap;
	module.exports = exports["default"];

/***/ },
/* 398 */
/*!*****************************!*\
  !*** external "source-map" ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("source-map");

/***/ },
/* 399 */
/*!*******************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/position.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Position = (function () {
	  function Position() {
	    _classCallCheck(this, Position);
	
	    this.line = 1;
	    this.column = 0;
	  }
	
	  Position.prototype.push = function push(str) {
	    for (var i = 0; i < str.length; i++) {
	      if (str[i] === "\n") {
	        this.line++;
	        this.column = 0;
	      } else {
	        this.column++;
	      }
	    }
	  };
	
	  Position.prototype.unshift = function unshift(str) {
	    for (var i = 0; i < str.length; i++) {
	      if (str[i] === "\n") {
	        this.line--;
	      } else {
	        this.column--;
	      }
	    }
	  };
	
	  return Position;
	})();
	
	exports["default"] = Position;
	module.exports = exports["default"];

/***/ },
/* 400 */
/*!*********************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/node/index.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _whitespace = __webpack_require__(/*! ./whitespace */ 401);
	
	var _whitespace2 = _interopRequireDefault(_whitespace);
	
	var _parentheses = __webpack_require__(/*! ./parentheses */ 402);
	
	var parens = _interopRequireWildcard(_parentheses);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _lodashCollectionSome = __webpack_require__(/*! lodash/collection/some */ 403);
	
	var _lodashCollectionSome2 = _interopRequireDefault(_lodashCollectionSome);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var find = function find(obj, node, parent) {
	  if (!obj) return;
	  var result;
	
	  var types = Object.keys(obj);
	  for (var i = 0; i < types.length; i++) {
	    var type = types[i];
	
	    if (t.is(type, node)) {
	      var fn = obj[type];
	      result = fn(node, parent);
	      if (result != null) break;
	    }
	  }
	
	  return result;
	};
	
	var Node = (function () {
	  function Node(node, parent) {
	    _classCallCheck(this, Node);
	
	    this.parent = parent;
	    this.node = node;
	  }
	
	  Node.isUserWhitespacable = function isUserWhitespacable(node) {
	    return t.isUserWhitespacable(node);
	  };
	
	  Node.needsWhitespace = function needsWhitespace(node, parent, type) {
	    if (!node) return 0;
	
	    if (t.isExpressionStatement(node)) {
	      node = node.expression;
	    }
	
	    var linesInfo = find(_whitespace2["default"].nodes, node, parent);
	
	    if (!linesInfo) {
	      var items = find(_whitespace2["default"].list, node, parent);
	      if (items) {
	        for (var i = 0; i < items.length; i++) {
	          linesInfo = Node.needsWhitespace(items[i], node, type);
	          if (linesInfo) break;
	        }
	      }
	    }
	
	    return linesInfo && linesInfo[type] || 0;
	  };
	
	  Node.needsWhitespaceBefore = function needsWhitespaceBefore(node, parent) {
	    return Node.needsWhitespace(node, parent, "before");
	  };
	
	  Node.needsWhitespaceAfter = function needsWhitespaceAfter(node, parent) {
	    return Node.needsWhitespace(node, parent, "after");
	  };
	
	  Node.needsParens = function needsParens(node, parent) {
	    if (!parent) return false;
	
	    if (t.isNewExpression(parent) && parent.callee === node) {
	      if (t.isCallExpression(node)) return true;
	
	      var hasCall = (0, _lodashCollectionSome2["default"])(node, function (val) {
	        return t.isCallExpression(val);
	      });
	      if (hasCall) return true;
	    }
	
	    return find(parens, node, parent);
	  };
	
	  Node.needsParensNoLineTerminator = function needsParensNoLineTerminator(node, parent) {
	    if (!parent) return false;
	
	    // no comments
	    if (!node.leadingComments || !node.leadingComments.length) {
	      return false;
	    }
	
	    return t.isTerminatorless(parent);
	  };
	
	  return Node;
	})();
	
	exports["default"] = Node;
	
	(0, _lodashCollectionEach2["default"])(Node, function (fn, key) {
	  Node.prototype[key] = function () {
	    // Avoid leaking arguments to prevent deoptimization
	    var args = new Array(arguments.length + 2);
	
	    args[0] = this.node;
	    args[1] = this.parent;
	
	    for (var i = 0; i < args.length; i++) {
	      args[i + 2] = arguments[i];
	    }
	
	    return Node[key].apply(null, args);
	  };
	});
	module.exports = exports["default"];

/***/ },
/* 401 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/node/whitespace.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashLangIsBoolean = __webpack_require__(/*! lodash/lang/isBoolean */ 208);
	
	var _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _lodashCollectionMap = __webpack_require__(/*! lodash/collection/map */ 361);
	
	var _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function crawl(node) {
	  var state = arguments[1] === undefined ? {} : arguments[1];
	
	  if (t.isMemberExpression(node)) {
	    crawl(node.object, state);
	    if (node.computed) crawl(node.property, state);
	  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
	    crawl(node.left, state);
	    crawl(node.right, state);
	  } else if (t.isCallExpression(node)) {
	    state.hasCall = true;
	    crawl(node.callee, state);
	  } else if (t.isFunction(node)) {
	    state.hasFunction = true;
	  } else if (t.isIdentifier(node)) {
	    state.hasHelper = state.hasHelper || isHelper(node.callee);
	  }
	
	  return state;
	}
	
	function isHelper(node) {
	  if (t.isMemberExpression(node)) {
	    return isHelper(node.object) || isHelper(node.property);
	  } else if (t.isIdentifier(node)) {
	    return node.name === "require" || node.name[0] === "_";
	  } else if (t.isCallExpression(node)) {
	    return isHelper(node.callee);
	  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
	    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
	  } else {
	    return false;
	  }
	}
	
	function isType(node) {
	  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);
	}
	
	exports.nodes = {
	  AssignmentExpression: function AssignmentExpression(node) {
	    var state = crawl(node.right);
	    if (state.hasCall && state.hasHelper || state.hasFunction) {
	      return {
	        before: state.hasFunction,
	        after: true
	      };
	    }
	  },
	
	  SwitchCase: function SwitchCase(node, parent) {
	    return {
	      before: node.consequent.length || parent.cases[0] === node
	    };
	  },
	
	  LogicalExpression: function LogicalExpression(node) {
	    if (t.isFunction(node.left) || t.isFunction(node.right)) {
	      return {
	        after: true
	      };
	    }
	  },
	
	  Literal: function Literal(node) {
	    if (node.value === "use strict") {
	      return {
	        after: true
	      };
	    }
	  },
	
	  CallExpression: function CallExpression(node) {
	    if (t.isFunction(node.callee) || isHelper(node)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  },
	
	  VariableDeclaration: function VariableDeclaration(node) {
	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	
	      var enabled = isHelper(declar.id) && !isType(declar.init);
	      if (!enabled) {
	        var state = crawl(declar.init);
	        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
	      }
	
	      if (enabled) {
	        return {
	          before: true,
	          after: true
	        };
	      }
	    }
	  },
	
	  IfStatement: function IfStatement(node) {
	    if (t.isBlockStatement(node.consequent)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  }
	};
	
	exports.nodes.Property = exports.nodes.SpreadProperty = function (node, parent) {
	  if (parent.properties[0] === node) {
	    return {
	      before: true
	    };
	  }
	};
	
	exports.list = {
	  VariableDeclaration: function VariableDeclaration(node) {
	    return (0, _lodashCollectionMap2["default"])(node.declarations, "init");
	  },
	
	  ArrayExpression: function ArrayExpression(node) {
	    return node.elements;
	  },
	
	  ObjectExpression: function ObjectExpression(node) {
	    return node.properties;
	  }
	};
	
	(0, _lodashCollectionEach2["default"])({
	  Function: true,
	  Class: true,
	  Loop: true,
	  LabeledStatement: true,
	  SwitchStatement: true,
	  TryStatement: true
	}, function (amounts, type) {
	  if ((0, _lodashLangIsBoolean2["default"])(amounts)) {
	    amounts = { after: amounts, before: amounts };
	  }
	
	  (0, _lodashCollectionEach2["default"])([type].concat(t.FLIPPED_ALIAS_KEYS[type] || []), function (type) {
	    exports.nodes[type] = function () {
	      return amounts;
	    };
	  });
	});

/***/ },
/* 402 */
/*!***************************************************************!*\
  !*** ./~/babel-core/lib/babel/generation/node/parentheses.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.UpdateExpression = UpdateExpression;
	exports.ObjectExpression = ObjectExpression;
	exports.Binary = Binary;
	exports.BinaryExpression = BinaryExpression;
	exports.SequenceExpression = SequenceExpression;
	exports.YieldExpression = YieldExpression;
	exports.ClassExpression = ClassExpression;
	exports.UnaryLike = UnaryLike;
	exports.FunctionExpression = FunctionExpression;
	exports.ConditionalExpression = ConditionalExpression;
	exports.AssignmentExpression = AssignmentExpression;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var PRECEDENCE = {};
	
	(0, _lodashCollectionEach2["default"])([["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]], function (tier, i) {
	  (0, _lodashCollectionEach2["default"])(tier, function (op) {
	    PRECEDENCE[op] = i;
	  });
	});
	
	function NullableTypeAnnotation(node, parent) {
	  return t.isArrayTypeAnnotation(parent);
	}
	
	exports.FunctionTypeAnnotation = NullableTypeAnnotation;
	
	function UpdateExpression(node, parent) {
	  if (t.isMemberExpression(parent) && parent.object === node) {
	    // (foo++).test()
	    return true;
	  }
	}
	
	function ObjectExpression(node, parent) {
	  if (t.isExpressionStatement(parent)) {
	    // ({ foo: "bar" });
	    return true;
	  }
	
	  if (t.isMemberExpression(parent) && parent.object === node) {
	    // ({ foo: "bar" }).foo
	    return true;
	  }
	
	  return false;
	}
	
	function Binary(node, parent) {
	  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node) {
	    return true;
	  }
	
	  if (t.isUnaryLike(parent)) {
	    return true;
	  }
	
	  if (t.isMemberExpression(parent) && parent.object === node) {
	    return true;
	  }
	
	  if (t.isBinary(parent)) {
	    var parentOp = parent.operator;
	    var parentPos = PRECEDENCE[parentOp];
	
	    var nodeOp = node.operator;
	    var nodePos = PRECEDENCE[nodeOp];
	
	    if (parentPos > nodePos) {
	      return true;
	    }
	
	    if (parentPos === nodePos && parent.right === node) {
	      return true;
	    }
	  }
	}
	
	function BinaryExpression(node, parent) {
	  if (node.operator === "in") {
	    // var i = (1 in []);
	    if (t.isVariableDeclarator(parent)) {
	      return true;
	    }
	
	    // for ((1 in []);;);
	    if (t.isFor(parent)) {
	      return true;
	    }
	  }
	}
	
	function SequenceExpression(node, parent) {
	  if (t.isForStatement(parent)) {
	    // Although parentheses wouldn't hurt around sequence
	    // expressions in the head of for loops, traditional style
	    // dictates that e.g. i++, j++ should not be wrapped with
	    // parentheses.
	    return false;
	  }
	
	  if (t.isExpressionStatement(parent) && parent.expression === node) {
	    return false;
	  }
	
	  // Otherwise err on the side of overparenthesization, adding
	  // explicit exceptions above if this proves overzealous.
	  return true;
	}
	
	function YieldExpression(node, parent) {
	  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) || t.isYieldExpression(parent);
	}
	
	function ClassExpression(node, parent) {
	  return t.isExpressionStatement(parent);
	}
	
	function UnaryLike(node, parent) {
	  return t.isMemberExpression(parent) && parent.object === node;
	}
	
	function FunctionExpression(node, parent) {
	  // function () {};
	  if (t.isExpressionStatement(parent)) {
	    return true;
	  }
	
	  // (function test() {}).name;
	  if (t.isMemberExpression(parent) && parent.object === node) {
	    return true;
	  }
	
	  // (function () {})();
	  if (t.isCallExpression(parent) && parent.callee === node) {
	    return true;
	  }
	}
	
	function ConditionalExpression(node, parent) {
	  if (t.isUnaryLike(parent)) {
	    return true;
	  }
	
	  if (t.isBinary(parent)) {
	    return true;
	  }
	
	  if (t.isCallExpression(parent) || t.isNewExpression(parent)) {
	    if (parent.callee === node) {
	      return true;
	    }
	  }
	
	  if (t.isConditionalExpression(parent) && parent.test === node) {
	    return true;
	  }
	
	  if (t.isMemberExpression(parent) && parent.object === node) {
	    return true;
	  }
	
	  return false;
	}
	
	function AssignmentExpression(node) {
	  if (t.isObjectPattern(node.left)) {
	    return true;
	  } else {
	    return ConditionalExpression.apply(undefined, arguments);
	  }
	}

/***/ },
/* 403 */
/*!**************************************************!*\
  !*** ./~/babel-core/~/lodash/collection/some.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var arraySome = __webpack_require__(/*! ../internal/arraySome */ 172),
	    baseCallback = __webpack_require__(/*! ../internal/baseCallback */ 166),
	    baseSome = __webpack_require__(/*! ../internal/baseSome */ 404),
	    isArray = __webpack_require__(/*! ../lang/isArray */ 115),
	    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ 136);
	
	/**
	 * Checks if `predicate` returns truthy for **any** element of `collection`.
	 * The function returns as soon as it finds a passing value and does not iterate
	 * over the entire collection. The predicate is bound to `thisArg` and invoked
	 * with three arguments: (value, index|key, collection).
	 *
	 * If a property name is provided for `predicate` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `predicate` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias any
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [predicate=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `predicate`.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 * @example
	 *
	 * _.some([null, 0, 'yes', false], Boolean);
	 * // => true
	 *
	 * var users = [
	 *   { 'user': 'barney', 'active': true },
	 *   { 'user': 'fred',   'active': false }
	 * ];
	 *
	 * // using the `_.matches` callback shorthand
	 * _.some(users, { 'user': 'barney', 'active': false });
	 * // => false
	 *
	 * // using the `_.matchesProperty` callback shorthand
	 * _.some(users, 'active', false);
	 * // => true
	 *
	 * // using the `_.property` callback shorthand
	 * _.some(users, 'active');
	 * // => true
	 */
	function some(collection, predicate, thisArg) {
	  var func = isArray(collection) ? arraySome : baseSome;
	  if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	    predicate = null;
	  }
	  if (typeof predicate != 'function' || thisArg !== undefined) {
	    predicate = baseCallback(predicate, thisArg, 3);
	  }
	  return func(collection, predicate);
	}
	
	module.exports = some;


/***/ },
/* 404 */
/*!****************************************************!*\
  !*** ./~/babel-core/~/lodash/internal/baseSome.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(/*! ./baseEach */ 161);
	
	/**
	 * The base implementation of `_.some` without support for callback shorthands
	 * and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function baseSome(collection, predicate) {
	  var result;
	
	  baseEach(collection, function(value, index, collection) {
	    result = predicate(value, index, collection);
	    return !result;
	  });
	  return !!result;
	}
	
	module.exports = baseSome;


/***/ },
/* 405 */
/*!****************************************************************!*\
  !*** ./~/babel-core/lib/babel/tools/build-external-helpers.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _generation = __webpack_require__(/*! ../generation */ 394);
	
	var _generation2 = _interopRequireDefault(_generation);
	
	var _messages = __webpack_require__(/*! ../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _util = __webpack_require__(/*! ../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _transformationFile = __webpack_require__(/*! ../transformation/file */ 247);
	
	var _transformationFile2 = _interopRequireDefault(_transformationFile);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _types = __webpack_require__(/*! ../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	function buildGlobal(namespace, builder) {
	  var body = [];
	  var container = t.functionExpression(null, [t.identifier("global")], t.blockStatement(body));
	  var tree = t.program([t.expressionStatement(t.callExpression(container, [util.template("helper-self-global")]))]);
	
	  body.push(t.variableDeclaration("var", [t.variableDeclarator(namespace, t.assignmentExpression("=", t.memberExpression(t.identifier("global"), namespace), t.objectExpression([])))]));
	
	  builder(body);
	
	  return tree;
	}
	
	function buildUmd(namespace, builder) {
	  var body = [];
	  body.push(t.variableDeclaration("var", [t.variableDeclarator(namespace, t.identifier("global"))]));
	
	  builder(body);
	
	  var container = util.template("umd-commonjs-strict", {
	    FACTORY_PARAMETERS: t.identifier("global"),
	    BROWSER_ARGUMENTS: t.assignmentExpression("=", t.memberExpression(t.identifier("root"), namespace), t.objectExpression({})),
	    COMMON_ARGUMENTS: t.identifier("exports"),
	    AMD_ARGUMENTS: t.arrayExpression([t.literal("exports")]),
	    FACTORY_BODY: body,
	    UMD_ROOT: t.identifier("this")
	  });
	  return t.program([container]);
	}
	
	function buildVar(namespace, builder) {
	  var body = [];
	  body.push(t.variableDeclaration("var", [t.variableDeclarator(namespace, t.objectExpression({}))]));
	  builder(body);
	  return t.program(body);
	}
	
	function buildHelpers(body, namespace, whitelist) {
	  (0, _lodashCollectionEach2["default"])(_transformationFile2["default"].helpers, function (name) {
	    if (whitelist && whitelist.indexOf(name) === -1) return;
	
	    var key = t.identifier(t.toIdentifier(name));
	    body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(namespace, key), util.template("helper-" + name))));
	  });
	}
	
	exports["default"] = function (whitelist) {
	  var outputType = arguments[1] === undefined ? "global" : arguments[1];
	
	  var namespace = t.identifier("babelHelpers");
	
	  var builder = function builder(body) {
	    return buildHelpers(body, namespace, whitelist);
	  };
	
	  var tree;
	
	  var build = ({
	    global: buildGlobal,
	    umd: buildUmd,
	    "var": buildVar
	  })[outputType];
	
	  if (build) {
	    tree = build(namespace, builder);
	  } else {
	    throw new Error(messages.get("unsupportedOutputType", outputType));
	  }
	
	  return (0, _generation2["default"])(tree).code;
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 406 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/file/logger.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _debugNode = __webpack_require__(/*! debug/node */ 407);
	
	var _debugNode2 = _interopRequireDefault(_debugNode);
	
	var verboseDebug = (0, _debugNode2["default"])("babel:verbose");
	var generalDebug = (0, _debugNode2["default"])("babel");
	
	var Logger = (function () {
	  function Logger(file, filename) {
	    _classCallCheck(this, Logger);
	
	    this.filename = filename;
	    this.file = file;
	  }
	
	  Logger.prototype._buildMessage = function _buildMessage(msg) {
	    var parts = "[BABEL] " + this.filename;
	    if (msg) parts += ": " + msg;
	    return parts;
	  };
	
	  Logger.prototype.error = function error(msg) {
	    var Constructor = arguments[1] === undefined ? Error : arguments[1];
	
	    throw new Constructor(this._buildMessage(msg));
	  };
	
	  Logger.prototype.deprecate = function deprecate(msg) {
	    if (!this.file.opts.suppressDeprecationMessages) {
	      console.error(this._buildMessage(msg));
	    }
	  };
	
	  Logger.prototype.verbose = function verbose(msg) {
	    if (verboseDebug.enabled) verboseDebug(this._buildMessage(msg));
	  };
	
	  Logger.prototype.debug = function debug(msg) {
	    if (generalDebug.enabled) generalDebug(this._buildMessage(msg));
	  };
	
	  Logger.prototype.deopt = function deopt(node, msg) {
	    this.debug(msg);
	  };
	
	  return Logger;
	})();
	
	exports["default"] = Logger;
	module.exports = exports["default"];

/***/ },
/* 407 */
/*!**************************************!*\
  !*** ./~/babel-core/~/debug/node.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var tty = __webpack_require__(/*! tty */ 408);
	var util = __webpack_require__(/*! util */ 204);
	
	/**
	 * This is the Node.js implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(/*! ./debug */ 409);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	
	/**
	 * Colors.
	 */
	
	exports.colors = [6, 2, 3, 4, 5, 1];
	
	/**
	 * The file descriptor to write the `debug()` calls to.
	 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
	 *
	 *   $ DEBUG_FD=3 node script.js 3>debug.log
	 */
	
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	var stream = 1 === fd ? process.stdout :
	             2 === fd ? process.stderr :
	             createWritableStdioStream(fd);
	
	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */
	
	function useColors() {
	  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
	  if (0 === debugColors.length) {
	    return tty.isatty(fd);
	  } else {
	    return '0' !== debugColors
	        && 'no' !== debugColors
	        && 'false' !== debugColors
	        && 'disabled' !== debugColors;
	  }
	}
	
	/**
	 * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
	 */
	
	var inspect = (4 === util.inspect.length ?
	  // node <= 0.8.x
	  function (v, colors) {
	    return util.inspect(v, void 0, void 0, colors);
	  } :
	  // node > 0.8.x
	  function (v, colors) {
	    return util.inspect(v, { colors: colors });
	  }
	);
	
	exports.formatters.o = function(v) {
	  return inspect(v, this.useColors)
	    .replace(/\s*\n\s*/g, ' ');
	};
	
	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	  var name = this.namespace;
	
	  if (useColors) {
	    var c = this.color;
	
	    args[0] = '  \u001b[3' + c + ';1m' + name + ' '
	      + '\u001b[0m'
	      + args[0] + '\u001b[3' + c + 'm'
	      + ' +' + exports.humanize(this.diff) + '\u001b[0m';
	  } else {
	    args[0] = new Date().toUTCString()
	      + ' ' + name + ' ' + args[0];
	  }
	  return args;
	}
	
	/**
	 * Invokes `console.error()` with the specified arguments.
	 */
	
	function log() {
	  return stream.write(util.format.apply(this, arguments) + '\n');
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  if (null == namespaces) {
	    // If you set a process.env field to null or undefined, it gets cast to the
	    // string 'null' or 'undefined'. Just delete instead.
	    delete process.env.DEBUG;
	  } else {
	    process.env.DEBUG = namespaces;
	  }
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  return process.env.DEBUG;
	}
	
	/**
	 * Copied from `node/src/node.js`.
	 *
	 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	 */
	
	function createWritableStdioStream (fd) {
	  var stream;
	  var tty_wrap = process.binding('tty_wrap');
	
	  // Note stream._type is used for test-module-load-list.js
	
	  switch (tty_wrap.guessHandleType(fd)) {
	    case 'TTY':
	      stream = new tty.WriteStream(fd);
	      stream._type = 'tty';
	
	      // Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;
	
	    case 'FILE':
	      var fs = __webpack_require__(/*! fs */ 98);
	      stream = new fs.SyncWriteStream(fd, { autoClose: false });
	      stream._type = 'fs';
	      break;
	
	    case 'PIPE':
	    case 'TCP':
	      var net = __webpack_require__(/*! net */ 411);
	      stream = new net.Socket({
	        fd: fd,
	        readable: false,
	        writable: true
	      });
	
	      // FIXME Should probably have an option in net.Socket to create a
	      // stream from an existing fd which is writable only. But for now
	      // we'll just add this hack and set the `readable` member to false.
	      // Test: ./node test/fixtures/echo.js < /etc/passwd
	      stream.readable = false;
	      stream.read = null;
	      stream._type = 'pipe';
	
	      // FIXME Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;
	
	    default:
	      // Probably an error on in uv_guess_handle()
	      throw new Error('Implement me. Unknown stream file type!');
	  }
	
	  // For supporting legacy API we put the FD here.
	  stream.fd = fd;
	
	  stream._isStdio = true;
	
	  return stream;
	}
	
	/**
	 * Enable namespaces listed in `process.env.DEBUG` initially.
	 */
	
	exports.enable(load());


/***/ },
/* 408 */
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("tty");

/***/ },
/* 409 */
/*!***************************************!*\
  !*** ./~/babel-core/~/debug/debug.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(/*! ms */ 410);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 410 */
/*!*********************!*\
  !*** external "ms" ***!
  \*********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("ms");

/***/ },
/* 411 */
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("net");

/***/ },
/* 412 */
/*!**********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/file/plugin-manager.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _apiNode = __webpack_require__(/*! ../../api/node */ 142);
	
	var node = _interopRequireWildcard(_apiNode);
	
	var _messages = __webpack_require__(/*! ../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var PluginManager = (function () {
	  function PluginManager() {
	    var _ref = arguments[0] === undefined ? { transformers: {}, before: [], after: [] } : arguments[0];
	
	    var file = _ref.file;
	    var transformers = _ref.transformers;
	    var before = _ref.before;
	    var after = _ref.after;
	
	    _classCallCheck(this, PluginManager);
	
	    this.transformers = transformers;
	    this.file = file;
	    this.before = before;
	    this.after = after;
	  }
	
	  PluginManager.memoisePluginContainer = function memoisePluginContainer(fn) {
	    for (var i = 0; i < PluginManager.memoisedPlugins.length; i++) {
	      var plugin = PluginManager.memoisedPlugins[i];
	      if (plugin.container === fn) return plugin.transformer;
	    }
	
	    var transformer = fn(node);
	    PluginManager.memoisedPlugins.push({
	      container: fn,
	      transformer: transformer
	    });
	    return transformer;
	  };
	
	  PluginManager.prototype.subnormaliseString = function subnormaliseString(name, position) {
	    // this is a plugin in the form of "foobar" or "foobar:after"
	    // where the optional colon is the delimiter for plugin position in the transformer stack
	
	    var match = name.match(/^(.*?):(after|before)$/);
	    if (match) {
	      ;
	
	      var _temp = match;
	      name = _temp[1];
	      position = _temp[2];
	      _temp;
	    }var loc = util.resolveRelative("babel-plugin-" + name) || util.resolveRelative(name);
	    if (loc) {
	      return {
	        position: position,
	        plugin: __webpack_require__(/*! . */ 413)(loc)
	      };
	    } else {
	      throw new ReferenceError(messages.get("pluginUnknown", name));
	    }
	  };
	
	  PluginManager.prototype.validate = function validate(name, plugin) {
	    // validate transformer key
	    var key = plugin.key;
	    if (this.transformers[key]) {
	      throw new ReferenceError(messages.get("pluginKeyCollision", key));
	    }
	
	    // validate Transformer instance
	    if (!plugin.buildPass || plugin.constructor.name !== "Transformer") {
	      throw new TypeError(messages.get("pluginNotTransformer", name));
	    }
	
	    // register as a plugin
	    plugin.metadata.plugin = true;
	  };
	
	  PluginManager.prototype.add = function add(name) {
	    var position;
	    var plugin;
	
	    if (name) {
	      if (typeof name === "object" && name.transformer) {
	        var _temp2 = name;
	        plugin = _temp2.transformer;
	        position = _temp2.position;
	        _temp2;
	      } else if (typeof name !== "string") {
	        // not a string so we'll just assume that it's a direct Transformer instance, if not then
	        // the checks later on will complain
	        plugin = name;
	      }
	
	      if (typeof name === "string") {
	        var _temp3 = this.subnormaliseString(name, position);
	
	        plugin = _temp3.plugin;
	        position = _temp3.position;
	        _temp3;
	      }
	    } else {
	      throw new TypeError(messages.get("pluginIllegalKind", typeof name, name));
	    }
	
	    // default position
	    position = position || "before";
	
	    // validate position
	    if (PluginManager.positions.indexOf(position) < 0) {
	      throw new TypeError(messages.get("pluginIllegalPosition", position, name));
	    }
	
	    // allow plugin containers to be specified so they don't have to manually require
	    if (typeof plugin === "function") {
	      plugin = PluginManager.memoisePluginContainer(plugin);
	    }
	
	    //
	    this.validate(name, plugin);
	
	    // build!
	    var pass = this.transformers[plugin.key] = plugin.buildPass(this.file);
	    if (pass.canTransform()) {
	      var stack = position === "before" ? this.before : this.after;
	      stack.push(pass);
	    }
	  };
	
	  _createClass(PluginManager, null, [{
	    key: "memoisedPlugins",
	    value: [],
	    enumerable: true
	  }, {
	    key: "positions",
	    value: ["before", "after"],
	    enumerable: true
	  }]);
	
	  return PluginManager;
	})();
	
	exports["default"] = PluginManager;
	module.exports = exports["default"];

/***/ },
/* 413 */
/*!*************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/file ^\.\/.*$ ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./index": 247,
		"./index.js": 247,
		"./logger": 406,
		"./logger.js": 406,
		"./option-parsers": 249,
		"./option-parsers.js": 249,
		"./plugin-manager": 412,
		"./plugin-manager.js": 412
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 413;


/***/ },
/* 414 */
/*!************************************************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/helpers/build-conditional-assignment-operator-transformer.js ***!
  \************************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _explodeAssignableExpression = __webpack_require__(/*! ./explode-assignable-expression */ 309);
	
	var _explodeAssignableExpression2 = _interopRequireDefault(_explodeAssignableExpression);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	exports["default"] = function (exports, opts) {
	  var buildAssignment = function buildAssignment(left, right) {
	    return t.assignmentExpression("=", left, right);
	  };
	
	  exports.ExpressionStatement = function (node, parent, scope, file) {
	    // hit the `AssignmentExpression` one below
	    if (this.isCompletionRecord()) return;
	
	    var expr = node.expression;
	    if (!opts.is(expr, file)) return;
	
	    var nodes = [];
	
	    var exploded = (0, _explodeAssignableExpression2["default"])(expr.left, nodes, file, scope);
	
	    nodes.push(t.ifStatement(opts.build(exploded.uid, file), t.expressionStatement(buildAssignment(exploded.ref, expr.right))));
	
	    return nodes;
	  };
	
	  exports.AssignmentExpression = function (node, parent, scope, file) {
	    if (!opts.is(node, file)) return;
	
	    var nodes = [];
	    var exploded = (0, _explodeAssignableExpression2["default"])(node.left, nodes, file, scope);
	
	    nodes.push(t.logicalExpression("&&", opts.build(exploded.uid, file), buildAssignment(exploded.ref, node.right)));
	
	    // todo: duplicate expression node
	    nodes.push(exploded.ref);
	
	    return nodes;
	  };
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 415 */
/*!*******************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/_default.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _messages = __webpack_require__(/*! ../../messages */ 203);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _traversal = __webpack_require__(/*! ../../traversal */ 151);
	
	var _traversal2 = _interopRequireDefault(_traversal);
	
	var _lodashObjectExtend = __webpack_require__(/*! lodash/object/extend */ 138);
	
	var _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);
	
	var _helpersObject = __webpack_require__(/*! ../../helpers/object */ 197);
	
	var _helpersObject2 = _interopRequireDefault(_helpersObject);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var remapVisitor = {
	  enter: function enter(node, parent, scope, formatter) {
	    if (node._skipModulesRemap) {
	      return this.skip();
	    }
	  },
	
	  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, formatter) {
	    var remap = formatter.internalRemap[node.name];
	
	    if (remap && node !== remap) {
	      if (!scope.hasBinding(node.name) || scope.bindingIdentifierEquals(node.name, formatter.localImports[node.name])) {
	        if (this.key === "callee" && this.parentPath.isCallExpression()) {
	          return t.sequenceExpression([t.literal(0), remap]);
	        } else {
	          return remap;
	        }
	      }
	    }
	  },
	
	  AssignmentExpression: {
	    exit: function exit(node, parent, scope, formatter) {
	      if (!node._ignoreModulesRemap) {
	        var exported = formatter.getExport(node.left, scope);
	        if (exported) {
	          return formatter.remapExportAssignment(node, exported);
	        }
	      }
	    }
	  },
	
	  UpdateExpression: function UpdateExpression(node, parent, scope, formatter) {
	    var exported = formatter.getExport(node.argument, scope);
	    if (!exported) return;
	
	    this.skip();
	
	    // expand to long file assignment expression
	    var assign = t.assignmentExpression(node.operator[0] + "=", node.argument, t.literal(1));
	
	    // remap this assignment expression
	    var remapped = formatter.remapExportAssignment(assign, exported);
	
	    // we don't need to change the result
	    if (t.isExpressionStatement(parent) || node.prefix) {
	      return remapped;
	    }
	
	    var nodes = [];
	    nodes.push(remapped);
	
	    var operator;
	    if (node.operator === "--") {
	      operator = "+";
	    } else {
	      // "++"
	      operator = "-";
	    }
	    nodes.push(t.binaryExpression(operator, node.argument, t.literal(1)));
	
	    return t.sequenceExpression(nodes);
	  }
	};
	
	var importsVisitor = {
	  ImportDeclaration: {
	    enter: function enter(node, parent, scope, formatter) {
	      formatter.hasLocalImports = true;
	      (0, _lodashObjectExtend2["default"])(formatter.localImports, this.getBindingIdentifiers());
	    }
	  }
	};
	
	var exportsVisitor = {
	  ExportDeclaration: {
	    enter: function enter(node, parent, scope, formatter) {
	      formatter.hasLocalExports = true;
	
	      var declar = this.get("declaration");
	      if (declar.isStatement()) {
	        var bindings = declar.getBindingIdentifiers();
	        for (var name in bindings) {
	          var binding = bindings[name];
	          formatter._addExport(name, binding);
	        }
	      }
	
	      if (this.isExportNamedDeclaration() && node.specifiers) {
	        for (var i = 0; i < node.specifiers.length; i++) {
	          var specifier = node.specifiers[i];
	          var local = specifier.local;
	          if (!local) continue;
	
	          formatter._addExport(local.name, specifier.exported);
	        }
	      }
	
	      if (!t.isExportDefaultDeclaration(node)) {
	        var onlyDefault = node.specifiers && node.specifiers.length === 1 && t.isSpecifierDefault(node.specifiers[0]);
	        if (!onlyDefault) {
	          formatter.hasNonDefaultExports = true;
	        }
	      }
	    }
	  }
	};
	
	var DefaultFormatter = (function () {
	  function DefaultFormatter(file) {
	    _classCallCheck(this, DefaultFormatter);
	
	    this.internalRemap = (0, _helpersObject2["default"])();
	    this.defaultIds = (0, _helpersObject2["default"])();
	    this.scope = file.scope;
	    this.file = file;
	    this.ids = (0, _helpersObject2["default"])();
	
	    this.hasNonDefaultExports = false;
	
	    this.hasLocalExports = false;
	    this.hasLocalImports = false;
	
	    this.localExports = (0, _helpersObject2["default"])();
	    this.localImports = (0, _helpersObject2["default"])();
	
	    this.getLocalExports();
	    this.getLocalImports();
	  }
	
	  DefaultFormatter.prototype.isModuleType = function isModuleType(node, type) {
	    var modules = this.file.dynamicImportTypes[type];
	    return modules && modules.indexOf(node) >= 0;
	  };
	
	  DefaultFormatter.prototype.transform = function transform() {
	    this.remapAssignments();
	  };
	
	  DefaultFormatter.prototype.doDefaultExportInterop = function doDefaultExportInterop(node) {
	    return (t.isExportDefaultDeclaration(node) || t.isSpecifierDefault(node)) && !this.noInteropRequireExport && !this.hasNonDefaultExports;
	  };
	
	  DefaultFormatter.prototype.getLocalExports = function getLocalExports() {
	    this.file.path.traverse(exportsVisitor, this);
	  };
	
	  DefaultFormatter.prototype.getLocalImports = function getLocalImports() {
	    this.file.path.traverse(importsVisitor, this);
	  };
	
	  DefaultFormatter.prototype.remapAssignments = function remapAssignments() {
	    if (this.hasLocalExports || this.hasLocalImports) {
	      this.file.path.traverse(remapVisitor, this);
	    }
	  };
	
	  DefaultFormatter.prototype.remapExportAssignment = function remapExportAssignment(node, exported) {
	    var assign = node;
	
	    for (var i = 0; i < exported.length; i++) {
	      assign = t.assignmentExpression("=", t.memberExpression(t.identifier("exports"), exported[i]), assign);
	    }
	
	    return assign;
	  };
	
	  DefaultFormatter.prototype._addExport = function _addExport(name, exported) {
	    var info = this.localExports[name] = this.localExports[name] || {
	      binding: this.scope.getBindingIdentifier(name),
	      exported: []
	    };
	    info.exported.push(exported);
	  };
	
	  DefaultFormatter.prototype.getExport = function getExport(node, scope) {
	    if (!t.isIdentifier(node)) return;
	
	    var local = this.localExports[node.name];
	    if (local && local.binding === scope.getBindingIdentifier(node.name)) {
	      return local.exported;
	    }
	  };
	
	  DefaultFormatter.prototype.getModuleName = function getModuleName() {
	    var opts = this.file.opts;
	    // moduleId is n/a if a `getModuleId()` is provided
	    if (opts.moduleId && !opts.getModuleId) {
	      return opts.moduleId;
	    }
	
	    var filenameRelative = opts.filenameRelative;
	    var moduleName = "";
	
	    if (opts.moduleRoot) {
	      moduleName = opts.moduleRoot + "/";
	    }
	
	    if (!opts.filenameRelative) {
	      return moduleName + opts.filename.replace(/^\//, "");
	    }
	
	    if (opts.sourceRoot) {
	      // remove sourceRoot from filename
	      var sourceRootRegEx = new RegExp("^" + opts.sourceRoot + "/?");
	      filenameRelative = filenameRelative.replace(sourceRootRegEx, "");
	    }
	
	    if (!opts.keepModuleIdExtensions) {
	      // remove extension
	      filenameRelative = filenameRelative.replace(/\.(\w*?)$/, "");
	    }
	
	    moduleName += filenameRelative;
	
	    // normalize path separators
	    moduleName = moduleName.replace(/\\/g, "/");
	
	    if (opts.getModuleId) {
	      // If return is falsy, assume they want us to use our generated default name
	      return opts.getModuleId(moduleName) || moduleName;
	    } else {
	      return moduleName;
	    }
	  };
	
	  DefaultFormatter.prototype._pushStatement = function _pushStatement(ref, nodes) {
	    if (t.isClass(ref) || t.isFunction(ref)) {
	      if (ref.id) {
	        nodes.push(t.toStatement(ref));
	        ref = ref.id;
	      }
	    }
	
	    return ref;
	  };
	
	  DefaultFormatter.prototype._hoistExport = function _hoistExport(declar, assign, priority) {
	    if (t.isFunctionDeclaration(declar)) {
	      assign._blockHoist = priority || 2;
	    }
	
	    return assign;
	  };
	
	  DefaultFormatter.prototype.getExternalReference = function getExternalReference(node, nodes) {
	    var ids = this.ids;
	    var id = node.source.value;
	
	    if (ids[id]) {
	      return ids[id];
	    } else {
	      return this.ids[id] = this._getExternalReference(node, nodes);
	    }
	  };
	
	  DefaultFormatter.prototype.checkExportIdentifier = function checkExportIdentifier(node) {
	    if (t.isIdentifier(node, { name: "__esModule" })) {
	      throw this.file.errorWithNode(node, messages.get("modulesIllegalExportName", node.name));
	    }
	  };
	
	  DefaultFormatter.prototype.exportAllDeclaration = function exportAllDeclaration(node, nodes) {
	    var ref = this.getExternalReference(node, nodes);
	    nodes.push(this.buildExportsWildcard(ref, node));
	  };
	
	  DefaultFormatter.prototype.isLoose = function isLoose() {
	    return this.file.isLoose("es6.modules");
	  };
	
	  DefaultFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {
	    if (node.source) {
	      var ref = this.getExternalReference(node, nodes);
	
	      if (specifier.local.name === "default" && !this.noInteropRequireExport) {
	        // importing a default so we need to normalize it
	        ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
	      } else {
	        ref = t.memberExpression(ref, specifier.local);
	
	        if (!this.isLoose()) {
	          nodes.push(this.buildExportsFromAssignment(specifier.exported, ref, node));
	          return;
	        }
	      }
	
	      // export { foo } from "test";
	      nodes.push(this.buildExportsAssignment(specifier.exported, ref, node));
	    } else {
	      // export { foo };
	      nodes.push(this.buildExportsAssignment(specifier.exported, specifier.local, node));
	    }
	  };
	
	  DefaultFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier) {
	    return t.expressionStatement(t.callExpression(this.file.addHelper("defaults"), [t.identifier("exports"), t.callExpression(this.file.addHelper("interop-require-wildcard"), [objectIdentifier])]));
	  };
	
	  DefaultFormatter.prototype.buildExportsFromAssignment = function buildExportsFromAssignment(id, init) {
	    this.checkExportIdentifier(id);
	    return util.template("exports-from-assign", {
	      INIT: init,
	      ID: t.literal(id.name)
	    }, true);
	  };
	
	  DefaultFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init) {
	    this.checkExportIdentifier(id);
	    return util.template("exports-assign", {
	      VALUE: init,
	      KEY: id
	    }, true);
	  };
	
	  DefaultFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
	    var declar = node.declaration;
	
	    var id = declar.id;
	
	    if (t.isExportDefaultDeclaration(node)) {
	      id = t.identifier("default");
	    }
	
	    var assign;
	
	    if (t.isVariableDeclaration(declar)) {
	      for (var i = 0; i < declar.declarations.length; i++) {
	        var decl = declar.declarations[i];
	
	        decl.init = this.buildExportsAssignment(decl.id, decl.init, node).expression;
	
	        var newDeclar = t.variableDeclaration(declar.kind, [decl]);
	        if (i === 0) t.inherits(newDeclar, declar);
	        nodes.push(newDeclar);
	      }
	    } else {
	      var ref = declar;
	
	      if (t.isFunctionDeclaration(declar) || t.isClassDeclaration(declar)) {
	        ref = declar.id;
	        nodes.push(declar);
	      }
	
	      assign = this.buildExportsAssignment(id, ref, node);
	
	      nodes.push(assign);
	
	      this._hoistExport(declar, assign);
	    }
	  };
	
	  return DefaultFormatter;
	})();
	
	exports["default"] = DefaultFormatter;
	module.exports = exports["default"];

/***/ },
/* 416 */
/*!******************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/_strict.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	exports["default"] = function (Parent) {
	  var Constructor = function Constructor() {
	    this.noInteropRequireImport = true;
	    this.noInteropRequireExport = true;
	    Parent.apply(this, arguments);
	  };
	
	  util.inherits(Constructor, Parent);
	
	  return Constructor;
	};
	
	;
	module.exports = exports["default"];

/***/ },
/* 417 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/amd.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }
	
	var _default = __webpack_require__(/*! ./_default */ 415);
	
	var _default2 = _interopRequireDefault(_default);
	
	var _common = __webpack_require__(/*! ./common */ 418);
	
	var _common2 = _interopRequireDefault(_common);
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _lodashObjectValues = __webpack_require__(/*! lodash/object/values */ 149);
	
	var _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var AMDFormatter = (function (_DefaultFormatter) {
	  function AMDFormatter() {
	    _classCallCheck(this, AMDFormatter);
	
	    if (_DefaultFormatter != null) {
	      _DefaultFormatter.apply(this, arguments);
	    }
	  }
	
	  _inherits(AMDFormatter, _DefaultFormatter);
	
	  AMDFormatter.prototype.setup = function setup() {
	    _common2["default"].prototype._setup.call(this, this.hasNonDefaultExports);
	  };
	
	  AMDFormatter.prototype.buildDependencyLiterals = function buildDependencyLiterals() {
	    var names = [];
	    for (var name in this.ids) {
	      names.push(t.literal(name));
	    }
	    return names;
	  };
	
	  /**
	   * Wrap the entire body in a `define` wrapper.
	   */
	
	  AMDFormatter.prototype.transform = function transform(program) {
	    _common2["default"].prototype.transform.apply(this, arguments);
	
	    var body = program.body;
	
	    // build an array of module names
	
	    var names = [t.literal("exports")];
	    if (this.passModuleArg) names.push(t.literal("module"));
	    names = names.concat(this.buildDependencyLiterals());
	    names = t.arrayExpression(names);
	
	    // build up define container
	
	    var params = (0, _lodashObjectValues2["default"])(this.ids);
	    if (this.passModuleArg) params.unshift(t.identifier("module"));
	    params.unshift(t.identifier("exports"));
	
	    var container = t.functionExpression(null, params, t.blockStatement(body));
	
	    var defineArgs = [names, container];
	    var moduleName = this.getModuleName();
	    if (moduleName) defineArgs.unshift(t.literal(moduleName));
	
	    var call = t.callExpression(t.identifier("define"), defineArgs);
	
	    program.body = [t.expressionStatement(call)];
	  };
	
	  /**
	   * Get the AMD module name that we'll prepend to the wrapper
	   * to define this module
	   */
	
	  AMDFormatter.prototype.getModuleName = function getModuleName() {
	    if (this.file.opts.moduleIds) {
	      return _default2["default"].prototype.getModuleName.apply(this, arguments);
	    } else {
	      return null;
	    }
	  };
	
	  AMDFormatter.prototype._getExternalReference = function _getExternalReference(node) {
	    return this.scope.generateUidIdentifier(node.source.value);
	  };
	
	  AMDFormatter.prototype.importDeclaration = function importDeclaration(node) {
	    this.getExternalReference(node);
	  };
	
	  AMDFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {
	    var key = node.source.value;
	    var ref = this.getExternalReference(node);
	
	    if (t.isImportNamespaceSpecifier(specifier) || t.isImportDefaultSpecifier(specifier)) {
	      this.defaultIds[key] = specifier.local;
	    }
	
	    if (this.isModuleType(node, "absolute")) {} else if (this.isModuleType(node, "absoluteDefault")) {
	      // prevent unnecessary renaming of dynamic imports
	      this.ids[node.source.value] = ref;
	      ref = t.memberExpression(ref, t.identifier("default"));
	    } else if (t.isImportNamespaceSpecifier(specifier)) {} else if (!(0, _lodashCollectionIncludes2["default"])(this.file.dynamicImported, node) && t.isSpecifierDefault(specifier) && !this.noInteropRequireImport) {
	      // import foo from "foo";
	      var uid = this.scope.generateUidIdentifier(specifier.local.name);
	      nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, t.callExpression(this.file.addHelper("interop-require-default"), [ref]))]));
	      ref = t.memberExpression(uid, t.identifier("default"));
	    } else {
	      // import { foo } from "foo";
	      var imported = specifier.imported;
	      if (t.isSpecifierDefault(specifier)) imported = t.identifier("default");
	      ref = t.memberExpression(ref, imported);
	    }
	
	    this.internalRemap[specifier.local.name] = ref;
	  };
	
	  AMDFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {
	    if (this.doDefaultExportInterop(specifier)) {
	      this.passModuleArg = true;
	
	      if (specifier.exported !== specifier.local && !node.source) {
	        nodes.push(util.template("exports-default-assign", {
	          VALUE: specifier.local
	        }, true));
	        return;
	      }
	    }
	
	    _common2["default"].prototype.exportSpecifier.apply(this, arguments);
	  };
	
	  AMDFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
	    if (this.doDefaultExportInterop(node)) {
	      this.passModuleArg = true;
	
	      var declar = node.declaration;
	      var assign = util.template("exports-default-assign", {
	        VALUE: this._pushStatement(declar, nodes)
	      }, true);
	
	      if (t.isFunctionDeclaration(declar)) {
	        // we can hoist this assignment to the top of the file
	        assign._blockHoist = 3;
	      }
	
	      nodes.push(assign);
	      return;
	    }
	
	    _default2["default"].prototype.exportDeclaration.apply(this, arguments);
	  };
	
	  return AMDFormatter;
	})(_default2["default"]);
	
	exports["default"] = AMDFormatter;
	module.exports = exports["default"];
	
	// absolute module reference
	
	// import * as bar from "foo";

/***/ },
/* 418 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/common.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }
	
	var _default = __webpack_require__(/*! ./_default */ 415);
	
	var _default2 = _interopRequireDefault(_default);
	
	var _lodashCollectionIncludes = __webpack_require__(/*! lodash/collection/includes */ 145);
	
	var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var CommonJSFormatter = (function (_DefaultFormatter) {
	  function CommonJSFormatter() {
	    _classCallCheck(this, CommonJSFormatter);
	
	    if (_DefaultFormatter != null) {
	      _DefaultFormatter.apply(this, arguments);
	    }
	  }
	
	  _inherits(CommonJSFormatter, _DefaultFormatter);
	
	  CommonJSFormatter.prototype.setup = function setup() {
	    this._setup(this.hasLocalExports);
	  };
	
	  CommonJSFormatter.prototype._setup = function _setup(conditional) {
	    var file = this.file;
	    var scope = file.scope;
	
	    scope.rename("module");
	    scope.rename("exports");
	
	    if (!this.noInteropRequireImport && conditional) {
	      var templateName = "exports-module-declaration";
	      if (this.file.isLoose("es6.modules")) templateName += "-loose";
	      var declar = util.template(templateName, true);
	      declar._blockHoist = 3;
	      file.path.unshiftContainer("body", [declar]);
	    }
	  };
	
	  CommonJSFormatter.prototype.transform = function transform(program) {
	    _default2["default"].prototype.transform.apply(this, arguments);
	
	    if (this.hasDefaultOnlyExport) {
	      program.body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.identifier("module"), t.identifier("exports")), t.memberExpression(t.identifier("exports"), t.identifier("default")))));
	    }
	  };
	
	  CommonJSFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {
	    var variableName = specifier.local;
	
	    var ref = this.getExternalReference(node, nodes);
	
	    // import foo from "foo";
	    if (t.isSpecifierDefault(specifier)) {
	      if (this.isModuleType(node, "absolute")) {} else if (this.isModuleType(node, "absoluteDefault")) {
	        this.internalRemap[variableName.name] = ref;
	      } else if (this.noInteropRequireImport) {
	        this.internalRemap[variableName.name] = t.memberExpression(ref, t.identifier("default"));
	      } else {
	        var uid = this.scope.generateUidIdentifierBasedOnNode(node, "import");
	
	        nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, t.callExpression(this.file.addHelper("interop-require-default"), [ref]))]));
	
	        this.internalRemap[variableName.name] = t.memberExpression(uid, t.identifier("default"));
	      }
	    } else {
	      if (t.isImportNamespaceSpecifier(specifier)) {
	        if (!this.noInteropRequireImport) {
	          ref = t.callExpression(this.file.addHelper("interop-require-wildcard"), [ref]);
	        }
	
	        // import * as bar from "foo";
	        nodes.push(t.variableDeclaration("var", [t.variableDeclarator(variableName, ref)]));
	      } else {
	        // import { foo } from "foo";
	        this.internalRemap[variableName.name] = t.memberExpression(ref, specifier.imported);
	      }
	    }
	  };
	
	  CommonJSFormatter.prototype.importDeclaration = function importDeclaration(node, nodes) {
	    // import "foo";
	    nodes.push(util.template("require", {
	      MODULE_NAME: node.source
	    }, true));
	  };
	
	  CommonJSFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {
	    if (this.doDefaultExportInterop(specifier)) {
	      this.hasDefaultOnlyExport = true;
	    }
	
	    _default2["default"].prototype.exportSpecifier.apply(this, arguments);
	  };
	
	  CommonJSFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
	    if (this.doDefaultExportInterop(node)) {
	      this.hasDefaultOnlyExport = true;
	    }
	
	    _default2["default"].prototype.exportDeclaration.apply(this, arguments);
	  };
	
	  CommonJSFormatter.prototype._getExternalReference = function _getExternalReference(node, nodes) {
	    var source = node.source.value;
	
	    var call = t.callExpression(t.identifier("require"), [node.source]);
	    var uid;
	
	    if (this.isModuleType(node, "absolute")) {} else if (this.isModuleType(node, "absoluteDefault")) {
	      call = t.memberExpression(call, t.identifier("default"));
	    } else {
	      uid = this.scope.generateUidIdentifierBasedOnNode(node, "import");
	    }
	
	    uid = uid || node.specifiers[0].local;
	
	    var declar = t.variableDeclaration("var", [t.variableDeclarator(uid, call)]);
	    nodes.push(declar);
	    return uid;
	  };
	
	  return CommonJSFormatter;
	})(_default2["default"]);
	
	exports["default"] = CommonJSFormatter;
	module.exports = exports["default"];
	
	// absolute module reference
	
	// absolute module reference

/***/ },
/* 419 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/amd-strict.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _amd = __webpack_require__(/*! ./amd */ 417);
	
	var _amd2 = _interopRequireDefault(_amd);
	
	var _strict = __webpack_require__(/*! ./_strict */ 416);
	
	var _strict2 = _interopRequireDefault(_strict);
	
	exports["default"] = (0, _strict2["default"])(_amd2["default"]);
	module.exports = exports["default"];

/***/ },
/* 420 */
/*!************************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/common-strict.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _common = __webpack_require__(/*! ./common */ 418);
	
	var _common2 = _interopRequireDefault(_common);
	
	var _strict = __webpack_require__(/*! ./_strict */ 416);
	
	var _strict2 = _interopRequireDefault(_strict);
	
	exports["default"] = (0, _strict2["default"])(_common2["default"]);
	module.exports = exports["default"];

/***/ },
/* 421 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/ignore.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var IgnoreFormatter = (function () {
	  function IgnoreFormatter() {
	    _classCallCheck(this, IgnoreFormatter);
	  }
	
	  IgnoreFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
	    var declar = t.toStatement(node.declaration, true);
	    if (declar) nodes.push(t.inherits(declar, node));
	  };
	
	  IgnoreFormatter.prototype.exportAllDeclaration = function exportAllDeclaration() {};
	
	  IgnoreFormatter.prototype.importDeclaration = function importDeclaration() {};
	
	  IgnoreFormatter.prototype.importSpecifier = function importSpecifier() {};
	
	  IgnoreFormatter.prototype.exportSpecifier = function exportSpecifier() {};
	
	  return IgnoreFormatter;
	})();
	
	exports["default"] = IgnoreFormatter;
	module.exports = exports["default"];

/***/ },
/* 422 */
/*!****************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/index.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = {
	  commonStrict: __webpack_require__(/*! ./common-strict */ 420),
	  amdStrict: __webpack_require__(/*! ./amd-strict */ 419),
	  umdStrict: __webpack_require__(/*! ./umd-strict */ 424),
	  common: __webpack_require__(/*! ./common */ 418),
	  system: __webpack_require__(/*! ./system */ 423),
	  ignore: __webpack_require__(/*! ./ignore */ 421),
	  amd: __webpack_require__(/*! ./amd */ 417),
	  umd: __webpack_require__(/*! ./umd */ 425)
	};
	module.exports = exports["default"];

/***/ },
/* 423 */
/*!*****************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/system.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }
	
	var _default = __webpack_require__(/*! ./_default */ 415);
	
	var _default2 = _interopRequireDefault(_default);
	
	var _amd = __webpack_require__(/*! ./amd */ 417);
	
	var _amd2 = _interopRequireDefault(_amd);
	
	var _helpersObject = __webpack_require__(/*! ../../helpers/object */ 197);
	
	var _helpersObject2 = _interopRequireDefault(_helpersObject);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _lodashArrayLast = __webpack_require__(/*! lodash/array/last */ 182);
	
	var _lodashArrayLast2 = _interopRequireDefault(_lodashArrayLast);
	
	var _lodashCollectionEach = __webpack_require__(/*! lodash/collection/each */ 159);
	
	var _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);
	
	var _lodashCollectionMap = __webpack_require__(/*! lodash/collection/map */ 361);
	
	var _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var hoistVariablesVisitor = {
	  Function: function Function() {
	    // nothing inside is accessible
	    this.skip();
	  },
	
	  VariableDeclaration: function VariableDeclaration(node, parent, scope, state) {
	    if (node.kind !== "var" && !t.isProgram(parent)) {
	      // let, const
	      // can't be accessed
	      return;
	    }
	
	    // ignore block hoisted nodes as these can be left in
	    if (state.formatter._canHoist(node)) return;
	
	    var nodes = [];
	
	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	      state.hoistDeclarators.push(t.variableDeclarator(declar.id));
	      if (declar.init) {
	        // no initializer so we can just hoist it as-is
	        var assign = t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init));
	        nodes.push(assign);
	      }
	    }
	
	    // for (var i in test)
	    // for (var i = 0;;)
	    if (t.isFor(parent) && (parent.left === node || parent.init === node)) {
	      return node.declarations[0].id;
	    }
	
	    return nodes;
	  }
	};
	
	var hoistFunctionsVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (t.isFunction(node)) this.skip();
	
	    if (t.isFunctionDeclaration(node) || state.formatter._canHoist(node)) {
	      state.handlerBody.push(node);
	      this.remove();
	    }
	  }
	};
	
	var runnerSettersVisitor = {
	  enter: function enter(node, parent, scope, state) {
	    if (node._importSource === state.source) {
	      if (t.isVariableDeclaration(node)) {
	        var _arr = node.declarations;
	
	        for (var _i = 0; _i < _arr.length; _i++) {
	          var declar = _arr[_i];
	          state.hoistDeclarators.push(t.variableDeclarator(declar.id));
	          state.nodes.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
	        }
	      } else {
	        state.nodes.push(node);
	      }
	
	      this.remove();
	    }
	  }
	};
	
	var SystemFormatter = (function (_AMDFormatter) {
	  function SystemFormatter(file) {
	    _classCallCheck(this, SystemFormatter);
	
	    _AMDFormatter.call(this, file);
	
	    this.exportIdentifier = file.scope.generateUidIdentifier("export");
	    this.noInteropRequireExport = true;
	    this.noInteropRequireImport = true;
	  }
	
	  _inherits(SystemFormatter, _AMDFormatter);
	
	  SystemFormatter.prototype._addImportSource = function _addImportSource(node, exportNode) {
	    if (node) node._importSource = exportNode.source && exportNode.source.value;
	    return node;
	  };
	
	  SystemFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier, node) {
	    var leftIdentifier = this.scope.generateUidIdentifier("key");
	    var valIdentifier = t.memberExpression(objectIdentifier, leftIdentifier, true);
	
	    var left = t.variableDeclaration("var", [t.variableDeclarator(leftIdentifier)]);
	
	    var right = objectIdentifier;
	
	    var block = t.blockStatement([t.expressionStatement(this._buildExportCall(leftIdentifier, valIdentifier))]);
	
	    return this._addImportSource(t.forInStatement(left, right, block), node);
	  };
	
	  SystemFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init, node) {
	    var call = this._buildExportCall(t.literal(id.name), init, true);
	    return this._addImportSource(call, node);
	  };
	
	  SystemFormatter.prototype.buildExportsFromAssignment = function buildExportsFromAssignment() {
	    return this.buildExportsAssignment.apply(this, arguments);
	  };
	
	  SystemFormatter.prototype.remapExportAssignment = function remapExportAssignment(node, exported) {
	    var assign = node;
	
	    for (var i = 0; i < exported.length; i++) {
	      assign = this._buildExportCall(t.literal(exported[i].name), assign);
	    }
	
	    return assign;
	  };
	
	  SystemFormatter.prototype._buildExportCall = function _buildExportCall(id, init, isStatement) {
	    var call = t.callExpression(this.exportIdentifier, [id, init]);
	    if (isStatement) {
	      return t.expressionStatement(call);
	    } else {
	      return call;
	    }
	  };
	
	  SystemFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {
	    _amd2["default"].prototype.importSpecifier.apply(this, arguments);
	
	    for (var name in this.internalRemap) {
	      nodes.push(t.variableDeclaration("var", [t.variableDeclarator(t.identifier(name), this.internalRemap[name])]));
	    }
	
	    this.internalRemap = (0, _helpersObject2["default"])();
	
	    this._addImportSource((0, _lodashArrayLast2["default"])(nodes), node);
	  };
	
	  SystemFormatter.prototype._buildRunnerSetters = function _buildRunnerSetters(block, hoistDeclarators) {
	    var scope = this.file.scope;
	
	    return t.arrayExpression((0, _lodashCollectionMap2["default"])(this.ids, function (uid, source) {
	      var state = {
	        hoistDeclarators: hoistDeclarators,
	        source: source,
	        nodes: []
	      };
	
	      scope.traverse(block, runnerSettersVisitor, state);
	
	      return t.functionExpression(null, [uid], t.blockStatement(state.nodes));
	    }));
	  };
	
	  SystemFormatter.prototype._canHoist = function _canHoist(node) {
	    return node._blockHoist && !this.file.dynamicImports.length;
	  };
	
	  SystemFormatter.prototype.transform = function transform(program) {
	    _default2["default"].prototype.transform.apply(this, arguments);
	
	    var hoistDeclarators = [];
	    var moduleName = this.getModuleName();
	    var moduleNameLiteral = t.literal(moduleName);
	
	    var block = t.blockStatement(program.body);
	
	    var runner = util.template("system", {
	      MODULE_DEPENDENCIES: t.arrayExpression(this.buildDependencyLiterals()),
	      EXPORT_IDENTIFIER: this.exportIdentifier,
	      MODULE_NAME: moduleNameLiteral,
	      SETTERS: this._buildRunnerSetters(block, hoistDeclarators),
	      EXECUTE: t.functionExpression(null, [], block)
	    }, true);
	
	    var handlerBody = runner.expression.arguments[2].body.body;
	    if (!moduleName) runner.expression.arguments.shift();
	
	    var returnStatement = handlerBody.pop();
	
	    // hoist up all variable declarations
	    this.file.scope.traverse(block, hoistVariablesVisitor, {
	      formatter: this,
	      hoistDeclarators: hoistDeclarators
	    });
	
	    if (hoistDeclarators.length) {
	      var hoistDeclar = t.variableDeclaration("var", hoistDeclarators);
	      hoistDeclar._blockHoist = true;
	      handlerBody.unshift(hoistDeclar);
	    }
	
	    // hoist up function declarations for circular references
	    this.file.scope.traverse(block, hoistFunctionsVisitor, {
	      formatter: this,
	      handlerBody: handlerBody
	    });
	
	    handlerBody.push(returnStatement);
	
	    program.body = [runner];
	  };
	
	  return SystemFormatter;
	})(_amd2["default"]);
	
	exports["default"] = SystemFormatter;
	module.exports = exports["default"];

/***/ },
/* 424 */
/*!*********************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/umd-strict.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _umd = __webpack_require__(/*! ./umd */ 425);
	
	var _umd2 = _interopRequireDefault(_umd);
	
	var _strict = __webpack_require__(/*! ./_strict */ 416);
	
	var _strict2 = _interopRequireDefault(_strict);
	
	exports["default"] = (0, _strict2["default"])(_umd2["default"]);
	module.exports = exports["default"];

/***/ },
/* 425 */
/*!**************************************************************!*\
  !*** ./~/babel-core/lib/babel/transformation/modules/umd.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }
	
	var _default = __webpack_require__(/*! ./_default */ 415);
	
	var _default2 = _interopRequireDefault(_default);
	
	var _amd = __webpack_require__(/*! ./amd */ 417);
	
	var _amd2 = _interopRequireDefault(_amd);
	
	var _lodashObjectValues = __webpack_require__(/*! lodash/object/values */ 149);
	
	var _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);
	
	var _path = __webpack_require__(/*! path */ 96);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _util = __webpack_require__(/*! ../../util */ 250);
	
	var util = _interopRequireWildcard(_util);
	
	var _types = __webpack_require__(/*! ../../types */ 156);
	
	var t = _interopRequireWildcard(_types);
	
	var UMDFormatter = (function (_AMDFormatter) {
	  function UMDFormatter() {
	    _classCallCheck(this, UMDFormatter);
	
	    if (_AMDFormatter != null) {
	      _AMDFormatter.apply(this, arguments);
	    }
	  }
	
	  _inherits(UMDFormatter, _AMDFormatter);
	
	  UMDFormatter.prototype.transform = function transform(program) {
	    _default2["default"].prototype.transform.apply(this, arguments);
	
	    var body = program.body;
	
	    // build an array of module names
	
	    var names = [];
	    for (var _name in this.ids) {
	      names.push(t.literal(_name));
	    }
	
	    // factory
	
	    var ids = (0, _lodashObjectValues2["default"])(this.ids);
	    var args = [t.identifier("exports")];
	    if (this.passModuleArg) args.push(t.identifier("module"));
	    args = args.concat(ids);
	
	    var factory = t.functionExpression(null, args, t.blockStatement(body));
	
	    // amd
	
	    var defineArgs = [t.literal("exports")];
	    if (this.passModuleArg) defineArgs.push(t.literal("module"));
	    defineArgs = defineArgs.concat(names);
	    defineArgs = [t.arrayExpression(defineArgs)];
	
	    // common
	
	    var testExports = util.template("test-exports");
	    var testModule = util.template("test-module");
	    var commonTests = this.passModuleArg ? t.logicalExpression("&&", testExports, testModule) : testExports;
	
	    var commonArgs = [t.identifier("exports")];
	    if (this.passModuleArg) commonArgs.push(t.identifier("module"));
	    commonArgs = commonArgs.concat(names.map(function (name) {
	      return t.callExpression(t.identifier("require"), [name]);
	    }));
	
	    // globals
	
	    var browserArgs = [];
	    if (this.passModuleArg) browserArgs.push(t.identifier("mod"));
	
	    for (var _name2 in this.ids) {
	      var id = this.defaultIds[_name2] || t.identifier(t.toIdentifier(_path2["default"].basename(_name2, _path2["default"].extname(_name2))));
	      browserArgs.push(t.memberExpression(t.identifier("global"), id));
	    }
	
	    //
	
	    var moduleName = this.getModuleName();
	    if (moduleName) defineArgs.unshift(t.literal(moduleName));
	
	    //
	    var globalArg = this.file.opts.basename;
	    if (moduleName) globalArg = moduleName;
	    globalArg = t.identifier(t.toIdentifier(globalArg));
	
	    var runner = util.template("umd-runner-body", {
	      AMD_ARGUMENTS: defineArgs,
	      COMMON_TEST: commonTests,
	      COMMON_ARGUMENTS: commonArgs,
	      BROWSER_ARGUMENTS: browserArgs,
	      GLOBAL_ARG: globalArg
	    });
	
	    //
	
	    program.body = [t.expressionStatement(t.callExpression(runner, [t.thisExpression(), factory]))];
	  };
	
	  return UMDFormatter;
	})(_amd2["default"]);
	
	exports["default"] = UMDFormatter;
	module.exports = exports["default"];

/***/ },
/* 426 */,
/* 427 */
/*!********************************!*\
  !*** external "shebang-regex" ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("shebang-regex");

/***/ },
/* 428 */
/*!***********************************!*\
  !*** external "path-is-absolute" ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("path-is-absolute");

/***/ },
/* 429 */
/*!***************************!*\
  !*** external "newrelic" ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("newrelic");

/***/ },
/* 430 */
/*!********************************************!*\
  !*** ../dbc_config/react-search.config.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	  opensearch: {
	    wsdl: 'http://opensearch.addi.dk/3.2/opensearch.wsdl',
	    agency: 150013,
	    profile: 'opac'
	  },
	  openholdingstatus: {
	    wsdl: 'http://openholdingstatus.addi.dk/1.0/openholdingstatus.wsdl',
	    agencyId: 'DK-870970',
	    mergePids: false
	  },
	  moreinfo: {
	    wsdl: 'http://moreinfo.addi.dk/2.1/moreinfo.wsdl',
	    user: 'netpunkt',
	    group: '010100',
	    password: '20Koster'
	  },
	  openuserinfo: {
	    wsdl: 'http://bibdk-prod-ws.dbc.dk/openuserinfo/openuserinfo.wsdl',
	    endpoint: 'http://bibdk-prod-ws.dbc.dk/openuserinfo/',
	    securityCode: 'testhest'
	  },
	  dsx: {
	    endpoint: 'http://ml-p01.dbc.dk:8019/'
	  },
	  session: {
	    name: 'something',
	    secret: 'secret sauce'
	  }
	};

/***/ },
/* 431 */
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		"name": "pallesgavebod",
		"version": "0.0.25",
		"description": "Next generation pallesgavebod.dk",
		"main": "src/app.js",
		"scripts": {
			"test": "karma start --single-run=true",
			"test:watch": "karma start",
			"lint:checkstyle": "eslint ./src  -o report.xml -f checkstyle",
			"lint": "eslint ./src",
			"serve": "supervisor --harmony -w src/views,src/app.js, node_modules/dbc-node-serviceprovider server.js",
			"build": "webpack --progress --colors -p",
			"start:watch": "webpack --progress --colors --watch -d",
			"dev": "parallelshell \"npm run serve -s\" \"npm run start:watch -s\""
		},
		"repository": {
			"type": "git",
			"url": "git+https://github.com/DBCDK/pallesgavebod.git"
		},
		"keywords": [
			"pallesgavebod",
			"dbc"
		],
		"author": "DBCDK",
		"license": "ISC",
		"bugs": {
			"url": "https://github.com/DBCDK/pallesgavebod/issues"
		},
		"homepage": "https://github.com/DBCDK/pallesgavebod#readme",
		"dependencies": {
			"babel": "^5.2.9",
			"babel-core": "^5.2.9",
			"babel-loader": "^5.0.0",
			"dbc-node-serviceprovider": "git://github.com/DBCDK/dbc-node-serviceprovider#develop",
			"dbc-react-autocomplete": "git://github.com/DBCDK/dbc-react-autocomplete#develop",
			"dbc-react-querystring": "git://github.com/DBCDK/dbc-react-querystring#develop",
			"express": "^4.12.3",
			"jade": "^1.9.2",
			"newrelic": "^1.18.5",
			"react": "^0.13.2",
			"socket.io": "^1.3.5",
			"socket.io-client": "^1.3.5",
			"webpack": "^1.9.10",
			"winston": "^1.0.0",
			"winston-syslog": "^1.1.0"
		},
		"devDependencies": {
			"babel-eslint": "^3.1.1",
			"chai": "^2.3.0",
			"css-loader": "^0.14.4",
			"eslint": "^0.21.0",
			"eslint-loader": "^0.11.2",
			"eslint-plugin-react": "^2.2.0",
			"extract-text-webpack-plugin": "^0.8.1",
			"json-loader": "^0.5.2",
			"karma": "^0.12.35",
			"karma-cli": "0.0.4",
			"karma-junit-reporter": "^0.2.2",
			"karma-mocha": "^0.1.10",
			"karma-mocha-reporter": "^1.0.2",
			"karma-phantomjs-launcher": "^0.2.0",
			"karma-webpack": "^1.5.1",
			"mocha": "^2.2.4",
			"mocha-jenkins-reporter": "^0.1.8",
			"node-libs-browser": "^0.5.2",
			"node-sass": "^3.1.2",
			"parallelshell": "^1.1.1",
			"phantomjs": "^1.9.17",
			"react-tools": "^0.13.2",
			"sass-loader": "^1.0.2",
			"wallaby-webpack": "0.0.4"
		}
	}

/***/ },
/* 432 */
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("express");

/***/ },
/* 433 */
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("http");

/***/ },
/* 434 */
/*!******************************!*\
  !*** ./~/socket.io/index.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(/*! ./lib */ 435);


/***/ },
/* 435 */
/*!**********************************!*\
  !*** ./~/socket.io/lib/index.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var http = __webpack_require__(/*! http */ 433);
	var read = __webpack_require__(/*! fs */ 98).readFileSync;
	var parse = __webpack_require__(/*! url */ 444).parse;
	var engine = __webpack_require__(/*! engine.io */ 445);
	var client = __webpack_require__(/*! socket.io-client */ 464);
	var clientVersion = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"socket.io-client/package\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
	var Client = __webpack_require__(/*! ./client */ 436);
	var Namespace = __webpack_require__(/*! ./namespace */ 497);
	var Adapter = __webpack_require__(/*! socket.io-adapter */ 500);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io:server');
	var url = __webpack_require__(/*! url */ 444);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Server;
	
	/**
	 * Socket.IO client source.
	 */
	
	var clientSource = read(/*require.resolve*/(/*! socket.io-client/socket.io.js */ 505), 'utf-8');
	
	/**
	 * Server constructor.
	 *
	 * @param {http.Server|Number|Object} http server, port or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Server(srv, opts){
	  if (!(this instanceof Server)) return new Server(srv, opts);
	  if ('object' == typeof srv && !srv.listen) {
	    opts = srv;
	    srv = null;
	  }
	  opts = opts || {};
	  this.nsps = {};
	  this.path(opts.path || '/socket.io');
	  this.serveClient(false !== opts.serveClient);
	  this.adapter(opts.adapter || Adapter);
	  this.origins(opts.origins || '*:*');
	  this.sockets = this.of('/');
	  if (srv) this.attach(srv, opts);
	}
	
	/**
	 * Server request verification function, that checks for allowed origins
	 *
	 * @param {http.IncomingMessage} request
	 * @param {Function} callback to be called with the result: `fn(err, success)`
	 */
	
	Server.prototype.checkRequest = function(req, fn) {
	  var origin = req.headers.origin || req.headers.referer;
	
	  // file:// URLs produce a null Origin which can't be authorized via echo-back
	  if ('null' == origin || null == origin) origin = '*';
	
	  if (!!origin && typeof(this._origins) == 'function') return this._origins(origin, fn);
	  if (this._origins.indexOf('*:*') !== -1) return fn(null, true);
	  if (origin) {
	    try {
	      var parts = url.parse(origin);
	      parts.port = parts.port || 80;
	      var ok =
	        ~this._origins.indexOf(parts.hostname + ':' + parts.port) ||
	        ~this._origins.indexOf(parts.hostname + ':*') ||
	        ~this._origins.indexOf('*:' + parts.port);
	      return fn(null, !!ok);
	    } catch (ex) {
	    }
	  }
	  fn(null, false);
	};
	
	/**
	 * Sets/gets whether client code is being served.
	 *
	 * @param {Boolean} whether to serve client code
	 * @return {Server|Boolean} self when setting or value when getting
	 * @api public
	 */
	
	Server.prototype.serveClient = function(v){
	  if (!arguments.length) return this._serveClient;
	  this._serveClient = v;
	  return this;
	};
	
	/**
	 * Old settings for backwards compatibility
	 */
	
	var oldSettings = {
	  "transports": "transports",
	  "heartbeat timeout": "pingTimeout",
	  "heartbeat interval": "pingInterval",
	  "destroy buffer size": "maxHttpBufferSize"
	};
	
	/**
	 * Backwards compatiblity.
	 *
	 * @api public
	 */
	
	Server.prototype.set = function(key, val){
	  if ('authorization' == key && val) {
	    this.use(function(socket, next) {
	      val(socket.request, function(err, authorized) {
	        if (err) return next(new Error(err));
	        if (!authorized) return next(new Error('Not authorized'));
	        next();
	      });
	    });
	  } else if ('origins' == key && val) {
	    this.origins(val);
	  } else if ('resource' == key) {
	    this.path(val);
	  } else if (oldSettings[key] && this.eio[oldSettings[key]]) {
	    this.eio[oldSettings[key]] = val;
	  } else {
	    console.error('Option %s is not valid. Please refer to the README.', key);
	  }
	
	  return this;
	};
	
	/**
	 * Sets the client serving path.
	 *
	 * @param {String} pathname
	 * @return {Server|String} self when setting or value when getting
	 * @api public
	 */
	
	Server.prototype.path = function(v){
	  if (!arguments.length) return this._path;
	  this._path = v.replace(/\/$/, '');
	  return this;
	};
	
	/**
	 * Sets the adapter for rooms.
	 *
	 * @param {Adapter} pathname
	 * @return {Server|Adapter} self when setting or value when getting
	 * @api public
	 */
	
	Server.prototype.adapter = function(v){
	  if (!arguments.length) return this._adapter;
	  this._adapter = v;
	  for (var i in this.nsps) {
	    if (this.nsps.hasOwnProperty(i)) {
	      this.nsps[i].initAdapter();
	    }
	  }
	  return this;
	};
	
	/**
	 * Sets the allowed origins for requests.
	 *
	 * @param {String} origins
	 * @return {Server|Adapter} self when setting or value when getting
	 * @api public
	 */
	
	Server.prototype.origins = function(v){
	  if (!arguments.length) return this._origins;
	
	  this._origins = v;
	  return this;
	};
	
	/**
	 * Attaches socket.io to a server or port.
	 *
	 * @param {http.Server|Number} server or port
	 * @param {Object} options passed to engine.io
	 * @return {Server} self
	 * @api public
	 */
	
	Server.prototype.listen =
	Server.prototype.attach = function(srv, opts){
	  if ('function' == typeof srv) {
	    var msg = 'You are trying to attach socket.io to an express ' +
	    'request handler function. Please pass a http.Server instance.';
	    throw new Error(msg);
	  }
	
	  // handle a port as a string
	  if (Number(srv) == srv) {
	    srv = Number(srv);
	  }
	
	  if ('number' == typeof srv) {
	    debug('creating http server and binding to %d', srv);
	    var port = srv;
	    srv = http.Server(function(req, res){
	      res.writeHead(404);
	      res.end();
	    });
	    srv.listen(port);
	
	  }
	
	  // set engine.io path to `/socket.io`
	  opts = opts || {};
	  opts.path = opts.path || this.path();
	  // set origins verification
	  opts.allowRequest = this.checkRequest.bind(this);
	
	  // initialize engine
	  debug('creating engine.io instance with opts %j', opts);
	  this.eio = engine.attach(srv, opts);
	
	  // attach static file serving
	  if (this._serveClient) this.attachServe(srv);
	
	  // Export http server
	  this.httpServer = srv;
	
	  // bind to engine events
	  this.bind(this.eio);
	
	  return this;
	};
	
	/**
	 * Attaches the static file serving.
	 *
	 * @param {Function|http.Server} http server
	 * @api private
	 */
	
	Server.prototype.attachServe = function(srv){
	  debug('attaching client serving req handler');
	  var url = this._path + '/socket.io.js';
	  var evs = srv.listeners('request').slice(0);
	  var self = this;
	  srv.removeAllListeners('request');
	  srv.on('request', function(req, res) {
	    if (0 == req.url.indexOf(url)) {
	      self.serve(req, res);
	    } else {
	      for (var i = 0; i < evs.length; i++) {
	        evs[i].call(srv, req, res);
	      }
	    }
	  });
	};
	
	/**
	 * Handles a request serving `/socket.io.js`
	 *
	 * @param {http.Request} req
	 * @param {http.Response} res
	 * @api private
	 */
	
	Server.prototype.serve = function(req, res){
	  var etag = req.headers['if-none-match'];
	  if (etag) {
	    if (clientVersion == etag) {
	      debug('serve client 304');
	      res.writeHead(304);
	      res.end();
	      return;
	    }
	  }
	
	  debug('serve client source');
	  res.setHeader('Content-Type', 'application/javascript');
	  res.setHeader('ETag', clientVersion);
	  res.writeHead(200);
	  res.end(clientSource);
	};
	
	/**
	 * Binds socket.io to an engine.io instance.
	 *
	 * @param {engine.Server} engine.io (or compatible) server
	 * @return {Server} self
	 * @api public
	 */
	
	Server.prototype.bind = function(engine){
	  this.engine = engine;
	  this.engine.on('connection', this.onconnection.bind(this));
	  return this;
	};
	
	/**
	 * Called with each incoming transport connection.
	 *
	 * @param {engine.Socket} socket
	 * @return {Server} self
	 * @api public
	 */
	
	Server.prototype.onconnection = function(conn){
	  debug('incoming connection with id %s', conn.id);
	  var client = new Client(this, conn);
	  client.connect('/');
	  return this;
	};
	
	/**
	 * Looks up a namespace.
	 *
	 * @param {String} nsp name
	 * @param {Function} optional, nsp `connection` ev handler
	 * @api public
	 */
	
	Server.prototype.of = function(name, fn){
	  if (String(name)[0] !== '/') name = '/' + name;
	  
	  if (!this.nsps[name]) {
	    debug('initializing namespace %s', name);
	    var nsp = new Namespace(this, name);
	    this.nsps[name] = nsp;
	  }
	  if (fn) this.nsps[name].on('connect', fn);
	  return this.nsps[name];
	};
	
	/**
	 * Closes server connection
	 *
	 * @api public
	 */
	
	Server.prototype.close = function(){
	  this.nsps['/'].sockets.forEach(function(socket){
	    socket.onclose();
	  });
	
	  this.engine.close();
	
	  if(this.httpServer){
	    this.httpServer.close();
	  }
	};
	
	/**
	 * Expose main namespace (/).
	 */
	
	['on', 'to', 'in', 'use', 'emit', 'send', 'write'].forEach(function(fn){
	  Server.prototype[fn] = function(){
	    var nsp = this.sockets[fn];
	    return nsp.apply(this.sockets, arguments);
	  };
	});
	
	Namespace.flags.forEach(function(flag){
	  Server.prototype.__defineGetter__(flag, function(name){
	    this.flags.push(name);
	    return this;
	  });
	});
	
	/**
	 * BC with `io.listen`
	 */
	
	Server.listen = Server;


/***/ },
/* 436 */
/*!***********************************!*\
  !*** ./~/socket.io/lib/client.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(/*! socket.io-parser */ 437);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io:client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Client;
	
	/**
	 * Client constructor.
	 *
	 * @param {Server} server instance
	 * @param {Socket} connection
	 * @api private
	 */
	
	function Client(server, conn){
	  this.server = server;
	  this.conn = conn;
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.id = conn.id;
	  this.request = conn.request;
	  this.setup();
	  this.sockets = [];
	  this.nsps = {};
	  this.connectBuffer = [];
	}
	
	/**
	 * Sets up event listeners.
	 *
	 * @api private
	 */
	
	Client.prototype.setup = function(){
	  this.onclose = this.onclose.bind(this);
	  this.ondata = this.ondata.bind(this);
	  this.onerror = this.onerror.bind(this);
	  this.ondecoded = this.ondecoded.bind(this);
	
	  this.decoder.on('decoded', this.ondecoded);
	  this.conn.on('data', this.ondata);
	  this.conn.on('error', this.onerror);
	  this.conn.on('close', this.onclose);
	};
	
	/**
	 * Connects a client to a namespace.
	 *
	 * @param {String} namespace name
	 * @api private
	 */
	
	Client.prototype.connect = function(name){
	  debug('connecting to namespace %s', name);
	  if (!this.server.nsps[name]) {
	    this.packet({ type: parser.ERROR, nsp: name, data : 'Invalid namespace'});
	    return;
	  }
	  var nsp = this.server.of(name);
	  if ('/' != name && !this.nsps['/']) {
	    this.connectBuffer.push(name);
	    return;
	  }
	
	  var self = this;
	  var socket = nsp.add(this, function(){
	    self.sockets.push(socket);
	    self.nsps[nsp.name] = socket;
	
	    if ('/' == nsp.name && self.connectBuffer.length > 0) {
	      self.connectBuffer.forEach(self.connect, self);
	      self.connectBuffer = [];
	    }
	  });
	};
	
	/**
	 * Disconnects from all namespaces and closes transport.
	 *
	 * @api private
	 */
	
	Client.prototype.disconnect = function(){
	  var socket;
	  // we don't use a for loop because the length of
	  // `sockets` changes upon each iteration
	  while (socket = this.sockets.shift()) {
	    socket.disconnect();
	  }
	  this.close();
	};
	
	/**
	 * Removes a socket. Called by each `Socket`.
	 *
	 * @api private
	 */
	
	Client.prototype.remove = function(socket){
	  var i = this.sockets.indexOf(socket);
	  if (~i) {
	    var nsp = this.sockets[i].nsp.name;
	    this.sockets.splice(i, 1);
	    delete this.nsps[nsp];
	  } else {
	    debug('ignoring remove for %s', socket.id);
	  }
	};
	
	/**
	 * Closes the underlying connection.
	 *
	 * @api private
	 */
	
	Client.prototype.close = function(){
	  if ('open' == this.conn.readyState) {
	    debug('forcing transport close');
	    this.conn.close();
	    this.onclose('forced server close');
	  }
	};
	
	/**
	 * Writes a packet to the transport.
	 *
	 * @param {Object} packet object
	 * @param {Boolean} whether packet is already encoded
	 * @param {Boolean} whether packet is volatile
	 * @api private
	 */
	
	Client.prototype.packet = function(packet, preEncoded, volatile){
	  var self = this;
	
	  // this writes to the actual connection
	  function writeToEngine(encodedPackets) {
	    if (volatile && !self.conn.transport.writable) return;
	    for (var i = 0; i < encodedPackets.length; i++) {
	      self.conn.write(encodedPackets[i]);
	    }
	  }
	
	  if ('open' == this.conn.readyState) {
	    debug('writing packet %j', packet);
	    if(!preEncoded) { // not broadcasting, need to encode
	      this.encoder.encode(packet, function (encodedPackets) { // encode, then write results to engine
	        writeToEngine(encodedPackets);
	      });
	    } else { // a broadcast pre-encodes a packet
	      writeToEngine(packet);
	    }
	  } else {
	    debug('ignoring packet write %j', packet);
	  }
	};
	
	/**
	 * Called with incoming transport data.
	 *
	 * @api private
	 */
	
	Client.prototype.ondata = function(data){
	  // try/catch is needed for protocol violations (GH-1880)
	  try {
	    this.decoder.add(data);
	  } catch(e) {
	    this.onerror(e);
	  }
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Client.prototype.ondecoded = function(packet) {
	  if (parser.CONNECT == packet.type) {
	    this.connect(packet.nsp);
	  } else {
	    var socket = this.nsps[packet.nsp];
	    if (socket) {
	      socket.onpacket(packet);
	    } else {
	      debug('no socket for namespace %s', packet.nsp);
	    }
	  }
	};
	
	/**
	 * Handles an error.
	 *
	 * @param {Objcet} error object
	 * @api private
	 */
	
	Client.prototype.onerror = function(err){
	  this.sockets.forEach(function(socket){
	    socket.onerror(err);
	  });
	  this.onclose('client error');
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Client.prototype.onclose = function(reason){
	  debug('client close with reason %s', reason);
	
	  // ignore a potential subsequent `close` event
	  this.destroy();
	
	  // `nsps` and `sockets` are cleaned up seamlessly
	  var socket;
	  while (socket = this.sockets.shift()) {
	    socket.onclose(reason);
	  }
	
	  this.decoder.destroy(); // clean up decoder
	};
	
	/**
	 * Cleans up event listeners.
	 *
	 * @api private
	 */
	
	Client.prototype.destroy = function(){
	  this.conn.removeListener('data', this.ondata);
	  this.conn.removeListener('error', this.onerror);
	  this.conn.removeListener('close', this.onclose);
	  this.decoder.removeListener('decoded', this.ondecoded);
	};


/***/ },
/* 437 */
/*!*************************************************!*\
  !*** ./~/socket.io/~/socket.io-parser/index.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(/*! debug */ 439)('socket.io-parser');
	var json = __webpack_require__(/*! json3 */ 440);
	var isArray = __webpack_require__(/*! isarray */ 441);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	var binary = __webpack_require__(/*! ./binary */ 442);
	var isBuf = __webpack_require__(/*! ./is-buffer */ 443);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'BINARY_EVENT',
	  'ACK',
	  'BINARY_ACK',
	  'ERROR'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 438 */
/*!************************************!*\
  !*** external "component-emitter" ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("component-emitter");

/***/ },
/* 439 */
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("debug");

/***/ },
/* 440 */
/*!************************!*\
  !*** external "json3" ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("json3");

/***/ },
/* 441 */
/*!**************************!*\
  !*** external "isarray" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("isarray");

/***/ },
/* 442 */
/*!**************************************************!*\
  !*** ./~/socket.io/~/socket.io-parser/binary.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(/*! isarray */ 441);
	var isBuf = __webpack_require__(/*! ./is-buffer */ 443);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};


/***/ },
/* 443 */
/*!*****************************************************!*\
  !*** ./~/socket.io/~/socket.io-parser/is-buffer.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}


/***/ },
/* 444 */
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("url");

/***/ },
/* 445 */
/*!**************************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/engine.io.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var http = __webpack_require__(/*! http */ 433);
	
	/**
	 * Invoking the library as a function delegates to attach if the first argument
	 * is an `http.Server`.
	 *
	 * If there are no arguments or the first argument is an options object, then
	 * a new Server instance is returned.
	 *
	 * @param {http.Server} server (if specified, will be attached to by the new Server instance)
	 * @param {Object} options
	 * @return {Server} engine server
	 * @api public
	 */
	
	exports = module.exports = function() {
	  // backwards compatible use as `.attach`
	  // if first argument is an http server
	  if (arguments.length && arguments[0] instanceof http.Server) {
	    return attach.apply(this, arguments);
	  }
	
	  // if first argument is not an http server, then just make a regular eio server
	  return exports.Server.apply(null, arguments);
	};
	
	/**
	 * Protocol revision number.
	 *
	 * @api public
	 */
	
	exports.protocol = 1;
	
	/**
	 * Expose Server constructor.
	 *
	 * @api public
	 */
	
	exports.Server = __webpack_require__(/*! ./server */ 453);
	
	/**
	 * Expose Server constructor.
	 *
	 * @api public
	 */
	
	exports.Socket = __webpack_require__(/*! ./socket */ 462);
	
	/**
	 * Expose Transport constructor.
	 *
	 * @api public
	 */
	
	exports.Transport = __webpack_require__(/*! ./transport */ 446);
	
	/**
	 * Expose mutable list of available transports.
	 *
	 * @api public
	 */
	
	exports.transports = __webpack_require__(/*! ./transports */ 454);
	
	/**
	 * Exports parser.
	 *
	 * @api public
	 */
	
	exports.parser = __webpack_require__(/*! engine.io-parser */ 448);
	
	/**
	 * Creates an http.Server exclusively used for WS upgrades.
	 *
	 * @param {Number} port
	 * @param {Function} callback
	 * @param {Object} options
	 * @return {Server} websocket.io server
	 * @api public
	 */
	
	exports.listen = listen;
	
	function listen(port, options, fn) {
	  if ('function' == typeof options) {
	    fn = options;
	    options = {};
	  }
	
	  var server = http.createServer(function (req, res) {
	    res.writeHead(501);
	    res.end('Not Implemented');
	  });
	
	  server.listen(port, fn);
	
	  // create engine server
	  var engine = exports.attach(server, options);
	  engine.httpServer = server;
	
	  return engine;
	};
	
	/**
	 * Captures upgrade requests for a http.Server.
	 *
	 * @param {http.Server} server
	 * @param {Object} options
	 * @return {Server} engine server
	 * @api public
	 */
	
	exports.attach = attach;
	
	function attach(server, options) {
	  var engine = new exports.Server(options);
	  engine.attach(server, options);
	  return engine;
	};


/***/ },
/* 446 */
/*!**************************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/transport.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(/*! events */ 447).EventEmitter
	  , parser = __webpack_require__(/*! engine.io-parser */ 448)
	  , debug = __webpack_require__(/*! debug */ 439)('engine:transport');
	
	/**
	 * Expose the constructor.
	 */
	
	module.exports = Transport;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop () {};
	
	/**
	 * Transport constructor.
	 *
	 * @param {http.ServerRequest} request
	 * @api public
	 */
	
	function Transport (req) {
	  this.readyState = 'opening';
	};
	
	/**
	 * Inherits from EventEmitter.
	 */
	
	Transport.prototype.__proto__ = EventEmitter.prototype;
	
	/**
	 * Called with an incoming HTTP request.
	 *
	 * @param {http.ServerRequest} request
	 * @api private
	 */
	
	Transport.prototype.onRequest = function (req) {
	  debug('setting request');
	  this.req = req;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function (fn) {
	  this.readyState = 'closing';
	  this.doClose(fn || noop);
	};
	
	/**
	 * Called with a transport error.
	 *
	 * @param {String} message error
	 * @param {Object} error description
	 * @api private
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  if (this.listeners('error').length) {
	    var err = new Error(msg);
	    err.type = 'TransportError';
	    err.description = desc;
	    this.emit('error', err);
	  } else {
	    debug('ignored transport error %s (%s)', msg, desc);
	  }
	};
	
	/**
	 * Called with parsed out a packets from the data stream.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called with the encoded packet data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function (data) {
	  this.onPacket(parser.decodePacket(data));
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 447 */
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("events");

/***/ },
/* 448 */
/*!*************************************************************!*\
  !*** ./~/socket.io/~/engine.io/~/engine.io-parser/index.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(/*! ./lib/ */ 449);


/***/ },
/* 449 */
/*!*****************************************************************!*\
  !*** ./~/socket.io/~/engine.io/~/engine.io-parser/lib/index.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var utf8 = __webpack_require__(/*! utf8 */ 450);
	var after = __webpack_require__(/*! after */ 451);
	var keys = __webpack_require__(/*! ./keys */ 452);
	
	/**
	 * Current protocol version.
	 */
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  if ('function' == typeof utf8encode ) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (Buffer.isBuffer(data)) {
	    return encodeBuffer(packet, supportsBinary, callback);
	  } else if (data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	};
	
	/**
	 * Encode Buffer data
	 */
	
	function encodeBuffer(packet, supportsBinary, callback) {
	  var data = packet.data;
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var typeBuffer = new Buffer(1);
	  typeBuffer[0] = packets[packet.type];
	  return callback(Buffer.concat([typeBuffer, data]));
	}
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Buffer(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++){
	    resultBuffer[i+1] = contentArray[i];
	  }
	  return callback(resultBuffer);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback){
	  var data = packet.data.buffer || packet.data;
	  if (data instanceof ArrayBuffer) {
	    var buf = new Buffer(data.byteLength);
	    for (var i = 0; i < buf.length; i++) {
	      buf[i] = data[i];
	    }
	    packet.data = buf;
	  }
	
	  var message = 'b' + packets[packet.type];
	  message += packet.data.toString('base64');
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Data also available as an ArrayBuffer if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    var type = data.charAt(0);
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  // Binary data
	  if (binaryType === 'arraybuffer') {
	    var type = data[0];
	    var intArray = new Uint8Array(data.length - 1);
	    for (var i = 1; i < data.length; i++) {
	      intArray[i - 1] = data[i];
	    }
	    return { type: packetslist[type], data: intArray.buffer };
	  }
	  var type = data[0];
	  return { type: packetslist[type], data: data.slice(1) };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string.
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  var data = new Buffer(msg.substr(1), 'base64');
	  if (binaryType === 'arraybuffer') {
	    var abv = new Uint8Array(data.length);
	    for (var i = 0; i < abv.length; i++){
	      abv[i] = data[i];
	    }
	    data = abv.buffer;
	  }
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  if (supportsBinary) {
	    return exports.encodePayloadAsBinary(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if ('string' != typeof data) {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = ''
	    , n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 *
	 * Converts a buffer to a utf8.js encoded string
	 *
	 * @api private
	 */
	
	function bufferToString(buffer) {
	  var str = '';
	  for (var i = 0; i < buffer.length; i++) {
	    str += String.fromCharCode(buffer[i]);
	  }
	  return str;
	}
	
	/**
	 *
	 * Converts a utf8.js encoded string to a buffer
	 *
	 * @api private
	 */
	
	function stringToBuffer(string) {
	  var buf = new Buffer(string.length);
	  for (var i = 0; i < string.length; i++) {
	    buf.writeUInt8(string.charCodeAt(i), i);
	  }
	  return buf;
	}
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {Buffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsBinary = function (packets, callback) {
	  if (!packets.length) {
	    return callback(new Buffer(0));
	  }
	
	  function encodeOne(p, doneCallback) {
	    exports.encodePacket(p, true, true, function(packet) {
	
	      if (typeof packet === 'string') {
	        var encodingLength = '' + packet.length;
	        var sizeBuffer = new Buffer(encodingLength.length + 2);
	        sizeBuffer[0] = 0; // is a string (not true binary = 0)
	        for (var i = 0; i < encodingLength.length; i++) {
	          sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
	        }
	        sizeBuffer[sizeBuffer.length - 1] = 255;
	        return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
	      }
	
	      var encodingLength = '' + packet.length;
	      var sizeBuffer = new Buffer(encodingLength.length + 2);
	      sizeBuffer[0] = 1; // is binary (true binary = 1)
	      for (var i = 0; i < encodingLength.length; i++) {
	        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
	      }
	      sizeBuffer[sizeBuffer.length - 1] = 255;
	      doneCallback(null, Buffer.concat([sizeBuffer, packet]));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(Buffer.concat(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	
	 * @param {Buffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  while (bufferTail.length > 0) {
	    var strLen = '';
	    var isString = bufferTail[0] === 0;
	    var numberTooLong = false;
	    for (var i = 1; ; i++) {
	      if (bufferTail[i] == 255)  break;
	      // 310 = char length of Number.MAX_VALUE
	      if (strLen.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	      strLen += '' + bufferTail[i];
	    }
	    if(numberTooLong) return callback(err, 0, 1);
	    bufferTail = bufferTail.slice(strLen.length + 1);
	
	    var msgLength = parseInt(strLen, 10);
	
	    var msg = bufferTail.slice(1, msgLength + 1);
	    if (isString) msg = bufferToString(msg);
	    buffers.push(msg);
	    bufferTail = bufferTail.slice(msgLength + 1);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};


/***/ },
/* 450 */
/*!***********************!*\
  !*** external "utf8" ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("utf8");

/***/ },
/* 451 */
/*!************************!*\
  !*** external "after" ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("after");

/***/ },
/* 452 */
/*!****************************************************************!*\
  !*** ./~/socket.io/~/engine.io/~/engine.io-parser/lib/keys.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 453 */
/*!***********************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/server.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var qs = __webpack_require__(/*! querystring */ 458)
	  , parse = __webpack_require__(/*! url */ 444).parse
	  , readFileSync = __webpack_require__(/*! fs */ 98).readFileSync
	  , crypto = __webpack_require__(/*! crypto */ 460)
	  , base64id = __webpack_require__(/*! base64id */ 461)
	  , transports = __webpack_require__(/*! ./transports */ 454)
	  , EventEmitter = __webpack_require__(/*! events */ 447).EventEmitter
	  , Socket = __webpack_require__(/*! ./socket */ 462)
	  , WebSocketServer = __webpack_require__(/*! ws */ 463).Server
	  , debug = __webpack_require__(/*! debug */ 439)('engine');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Server;
	
	/**
	 * Server constructor.
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Server(opts){
	  if (!(this instanceof Server)) {
	    return new Server(opts);
	  }
	
	  this.clients = {};
	  this.clientsCount = 0;
	
	  opts = opts || {};
	  this.pingTimeout = opts.pingTimeout || 60000;
	  this.pingInterval = opts.pingInterval || 25000;
	  this.upgradeTimeout = opts.upgradeTimeout || 10000;
	  this.maxHttpBufferSize = opts.maxHttpBufferSize || 10E7;
	  this.transports = opts.transports || Object.keys(transports);
	  this.allowUpgrades = false !== opts.allowUpgrades;
	  this.allowRequest = opts.allowRequest;
	  this.cookie = false !== opts.cookie ? (opts.cookie || 'io') : false;
	
	  // initialize websocket server
	  if (~this.transports.indexOf('websocket')) {
	    this.ws = new WebSocketServer({ noServer: true, clientTracking: false });
	  }
	}
	
	/**
	 * Protocol errors mappings.
	 */
	
	Server.errors = {
	  UNKNOWN_TRANSPORT: 0,
	  UNKNOWN_SID: 1,
	  BAD_HANDSHAKE_METHOD: 2,
	  BAD_REQUEST: 3
	};
	
	Server.errorMessages = {
	  0: 'Transport unknown',
	  1: 'Session ID unknown',
	  2: 'Bad handshake method',
	  3: 'Bad request'
	};
	
	/**
	 * Inherits from EventEmitter.
	 */
	
	Server.prototype.__proto__ = EventEmitter.prototype;
	
	/**
	 * Hash of open clients.
	 *
	 * @api public
	 */
	
	Server.prototype.clients;
	
	/**
	 * Returns a list of available transports for upgrade given a certain transport.
	 *
	 * @return {Array}
	 * @api public
	 */
	
	Server.prototype.upgrades = function(transport){
	  if (!this.allowUpgrades) return [];
	  return transports[transport].upgradesTo || [];
	};
	
	/**
	 * Verifies a request.
	 *
	 * @param {http.ServerRequest}
	 * @return {Boolean} whether the request is valid
	 * @api private
	 */
	
	Server.prototype.verify = function(req, upgrade, fn){
	  // transport check
	  var transport = req._query.transport;
	  if (!~this.transports.indexOf(transport)) {
	    debug('unknown transport "%s"', transport);
	    return fn(Server.errors.UNKNOWN_TRANSPORT, false);
	  }
	
	  // sid check
	  var sid = req._query.sid;
	  if (sid) {
	    if (!this.clients.hasOwnProperty(sid))
	      return fn(Server.errors.UNKNOWN_SID, false);
	    if (!upgrade && this.clients[sid].transport.name !== transport) {
	      debug('bad request: unexpected transport without upgrade');
	      return fn(Server.errors.BAD_REQUEST, false);
	    }
	  } else {
	    // handshake is GET only
	    if ('GET' != req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);
	    if (!this.allowRequest) return fn(null, true);
	    return this.allowRequest(req, fn);
	  }
	
	  fn(null, true);
	};
	
	/**
	 * Prepares a request by processing the query string.
	 *
	 * @api private
	 */
	
	Server.prototype.prepare = function(req){
	  // try to leverage pre-existing `req._query` (e.g: from connect)
	  if (!req._query) {
	    req._query = ~req.url.indexOf('?') ? qs.parse(parse(req.url).query) : {};
	  }
	};
	
	/**
	 * Closes all clients.
	 *
	 * @api public
	 */
	
	Server.prototype.close = function(){
	  debug('closing all open clients');
	  for (var i in this.clients) {
	    this.clients[i].close();
	  }
	  return this;
	};
	
	/**
	 * Handles an Engine.IO HTTP request.
	 *
	 * @param {http.ServerRequest} request
	 * @param {http.ServerResponse|http.OutgoingMessage} response
	 * @api public
	 */
	
	Server.prototype.handleRequest = function(req, res){
	  debug('handling "%s" http request "%s"', req.method, req.url);
	  this.prepare(req);
	  req.res = res;
	
	  var self = this;
	  this.verify(req, false, function(err, success) {
	    if (!success) {
	      sendErrorMessage(req, res, err);
	      return;
	    }
	
	    if (req._query.sid) {
	      debug('setting new request for existing client');
	      self.clients[req._query.sid].transport.onRequest(req);
	    } else {
	      self.handshake(req._query.transport, req);
	    }
	  });
	};
	
	/**
	 * Sends an Engine.IO Error Message
	 *
	 * @param {http.ServerResponse} response
	 * @param {code} error code
	 * @api private
	 */
	
	 function sendErrorMessage(req, res, code) {
	    var headers = { 'Content-Type': 'application/json' };
	
	    if (req.headers.origin) {
	      headers['Access-Control-Allow-Credentials'] = 'true';
	      headers['Access-Control-Allow-Origin'] = req.headers.origin;
	    } else {
	      headers['Access-Control-Allow-Origin'] = '*';
	    }
	    res.writeHead(400, headers);
	    res.end(JSON.stringify({
	      code: code,
	      message: Server.errorMessages[code]
	    }));
	 }
	
	/**
	 * Handshakes a new client.
	 *
	 * @param {String} transport name
	 * @param {Object} request object
	 * @api private
	 */
	
	Server.prototype.handshake = function(transport, req){
	  var id = base64id.generateId();
	
	  debug('handshaking client "%s"', id);
	
	  var transportName = transport;
	  try {
	    var transport = new transports[transport](req);
	    if ('polling' == transportName) {
	      transport.maxHttpBufferSize = this.maxHttpBufferSize;
	    }
	
	    if (req._query && req._query.b64) {
	      transport.supportsBinary = false;
	    } else {
	      transport.supportsBinary = true;
	    }
	  }
	  catch (e) {
	    sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);
	    return;
	  }
	  var socket = new Socket(id, this, transport, req);
	  var self = this;
	
	  if (false !== this.cookie) {
	    transport.on('headers', function(headers){
	      headers['Set-Cookie'] = self.cookie + '=' + id;
	    });
	  }
	
	  transport.onRequest(req);
	
	  this.clients[id] = socket;
	  this.clientsCount++;
	
	  socket.once('close', function(){
	    delete self.clients[id];
	    self.clientsCount--;
	  });
	
	  this.emit('connection', socket);
	};
	
	/**
	 * Handles an Engine.IO HTTP Upgrade.
	 *
	 * @api public
	 */
	
	Server.prototype.handleUpgrade = function(req, socket, upgradeHead){
	  this.prepare(req);
	
	  var self = this;
	  this.verify(req, true, function(err, success) {
	    if (!success) {
	      socket.end();
	      return;
	    }
	
	    var head = new Buffer(upgradeHead.length);
	    upgradeHead.copy(head);
	    upgradeHead = null;
	
	    // delegate to ws
	    self.ws.handleUpgrade(req, socket, head, function(conn){
	      self.onWebSocket(req, conn);
	    });
	  });
	};
	
	/**
	 * Called upon a ws.io connection.
	 *
	 * @param {ws.Socket} websocket
	 * @api private
	 */
	
	Server.prototype.onWebSocket = function(req, socket){
	  if (!transports[req._query.transport].prototype.handlesUpgrades) {
	    debug('transport doesnt handle upgraded requests');
	    socket.close();
	    return;
	  }
	
	  // get client id
	  var id = req._query.sid;
	
	  // keep a reference to the ws.Socket
	  req.websocket = socket;
	
	  if (id) {
	    if (!this.clients[id]) {
	      debug('upgrade attempt for closed client');
	      socket.close();
	    } else if (this.clients[id].upgraded) {
	      debug('transport had already been upgraded');
	      socket.close();
	    } else {
	      debug('upgrading existing transport');
	      var transport = new transports[req._query.transport](req);
	      if (req._query && req._query.b64) {
	        transport.supportsBinary = false;
	      } else {
	        transport.supportsBinary = true;
	      }
	      this.clients[id].maybeUpgrade(transport);
	    }
	  } else {
	    this.handshake(req._query.transport, req);
	  }
	};
	
	/**
	 * Captures upgrade requests for a http.Server.
	 *
	 * @param {http.Server} server
	 * @param {Object} options
	 * @api public
	 */
	
	Server.prototype.attach = function(server, options){
	  var self = this;
	  var options = options || {};
	  var path = (options.path || '/engine.io').replace(/\/$/, '');
	
	  var destroyUpgrade = (options.destroyUpgrade !== undefined) ? options.destroyUpgrade : true;
	  var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;
	
	  // normalize path
	  path += '/';
	
	  function check (req) {
	    return path == req.url.substr(0, path.length);
	  }
	
	  // cache and clean up listeners
	  var listeners = server.listeners('request').slice(0);
	  server.removeAllListeners('request');
	  server.on('close', self.close.bind(self));
	
	  // add request handler
	  server.on('request', function(req, res){
	    if (check(req)) {
	      debug('intercepting request for path "%s"', path);
	      self.handleRequest(req, res);
	    } else {
	      for (var i = 0, l = listeners.length; i < l; i++) {
	        listeners[i].call(server, req, res);
	      }
	    }
	  });
	
	  if(~self.transports.indexOf('websocket')) {
	    server.on('upgrade', function (req, socket, head) {
	      if (check(req)) {
	        self.handleUpgrade(req, socket, head);
	      } else if (false !== options.destroyUpgrade) {
	        // default node behavior is to disconnect when no handlers
	        // but by adding a handler, we prevent that
	        // and if no eio thing handles the upgrade
	        // then the socket needs to die!
	        setTimeout(function() {
	           if (socket.writable && socket.bytesWritten <= 0) {
	             return socket.end();
	           }
	        }, options.destroyUpgradeTimeout);
	      }
	    });
	  }
	};


/***/ },
/* 454 */
/*!*********************************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/transports/index.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var XHR = __webpack_require__(/*! ./polling-xhr */ 455);
	var JSONP = __webpack_require__(/*! ./polling-jsonp */ 457);
	
	/**
	 * Export transports.
	 */
	
	module.exports = exports = {
	  polling: polling,
	  websocket: __webpack_require__(/*! ./websocket */ 459)
	};
	
	/**
	 * Export upgrades map.
	 */
	
	exports.polling.upgradesTo = ['websocket'];
	
	/**
	 * Polling polimorphic constructor.
	 *
	 * @api private
	 */
	
	function polling (req) {
	  if ('string' == typeof req._query.j) {
	    return new JSONP(req);
	  } else {
	    return new XHR(req);
	  }
	}


/***/ },
/* 455 */
/*!***************************************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/transports/polling-xhr.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Polling = __webpack_require__(/*! ./polling */ 456);
	var Transport = __webpack_require__(/*! ../transport */ 446);
	var debug = __webpack_require__(/*! debug */ 439)('engine:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	
	/**
	 * Ajax polling transport.
	 *
	 * @api public
	 */
	
	function XHR(req){
	  Polling.call(this, req);
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	XHR.prototype.__proto__ = Polling.prototype;
	
	/**
	 * Overrides `onRequest` to handle `OPTIONS`..
	 *
	 * @param {http.ServerRequest}
	 * @api private
	 */
	
	XHR.prototype.onRequest = function (req) {
	  if ('OPTIONS' == req.method) {
	    var res = req.res;
	    var headers = this.headers(req);
	    headers['Access-Control-Allow-Headers'] = 'Content-Type';
	    res.writeHead(200, headers);
	    res.end();
	  } else {
	    Polling.prototype.onRequest.call(this, req);
	  }
	};
	
	/**
	 * Frames data prior to write.
	 *
	 * @api private
	 */
	
	XHR.prototype.doWrite = function(data){
	  // explicit UTF-8 is required for pages not served under utf
	  var isString = typeof data == 'string';
	  var contentType = isString
	    ? 'text/plain; charset=UTF-8'
	    : 'application/octet-stream';
	  var contentLength = '' + (isString ? Buffer.byteLength(data) : data.length);
	
	  var headers = {
	    'Content-Type': contentType,
	    'Content-Length': contentLength
	  };
	
	  // prevent XSS warnings on IE
	  // https://github.com/LearnBoost/socket.io/pull/1333
	  var ua = this.req.headers['user-agent'];
	  if (ua && (~ua.indexOf(';MSIE') || ~ua.indexOf('Trident/'))) {
	    headers['X-XSS-Protection'] = '0';
	  }
	
	  this.res.writeHead(200, this.headers(this.req, headers));
	  this.res.end(data);
	};
	
	/**
	 * Returns headers for a response.
	 *
	 * @param {http.ServerRequest} request
	 * @param {Object} extra headers
	 * @api private
	 */
	
	XHR.prototype.headers = function(req, headers){
	  headers = headers || {};
	
	  if (req.headers.origin) {
	    headers['Access-Control-Allow-Credentials'] = 'true';
	    headers['Access-Control-Allow-Origin'] = req.headers.origin;
	  } else {
	    headers['Access-Control-Allow-Origin'] = '*';
	  }
	
	  this.emit('headers', headers);
	  return headers;
	};


/***/ },
/* 456 */
/*!***********************************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/transports/polling.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module requirements.
	 */
	
	var Transport = __webpack_require__(/*! ../transport */ 446)
	  , parser = __webpack_require__(/*! engine.io-parser */ 448)
	  , debug = __webpack_require__(/*! debug */ 439)('engine:polling');
	
	/**
	 * Exports the constructor.
	 */
	
	module.exports = Polling;
	
	/**
	 * HTTP polling constructor.
	 *
	 * @api public.
	 */
	
	function Polling (req) {
	  Transport.call(this, req);
	}
	
	/**
	 * Inherits from Transport.
	 *
	 * @api public.
	 */
	
	Polling.prototype.__proto__ = Transport.prototype;
	
	/**
	 * Transport name
	 *
	 * @api public
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Overrides onRequest.
	 *
	 * @param {http.ServerRequest}
	 * @api private
	 */
	
	Polling.prototype.onRequest = function (req) {
	  var res = req.res;
	
	  if ('GET' == req.method) {
	    this.onPollRequest(req, res);
	  } else if ('POST' == req.method) {
	    this.onDataRequest(req, res);
	  } else {
	    res.writeHead(500);
	    res.end();
	  }
	};
	
	/**
	 * The client sends a request awaiting for us to send data.
	 *
	 * @api private
	 */
	
	Polling.prototype.onPollRequest = function (req, res) {
	  if (this.req) {
	    debug('request overlap');
	    // assert: this.res, '.req and .res should be (un)set together'
	    this.onError('overlap from client');
	    res.writeHead(500);
	    return;
	  }
	
	  debug('setting request');
	
	  this.req = req;
	  this.res = res;
	
	  var self = this;
	
	  function onClose () {
	    self.onError('poll connection closed prematurely');
	  }
	
	  function cleanup () {
	    req.removeListener('close', onClose);
	    self.req = self.res = null;
	  }
	
	  req.cleanup = cleanup;
	  req.on('close', onClose);
	
	  this.writable = true;
	  this.emit('drain');
	
	  // if we're still writable but had a pending close, trigger an empty send
	  if (this.writable && this.shouldClose) {
	    debug('triggering empty send to append close packet');
	    this.send([{ type: 'noop' }]);
	  }
	};
	
	/**
	 * The client sends a request with data.
	 *
	 * @api private
	 */
	
	Polling.prototype.onDataRequest = function (req, res) {
	  if (this.dataReq) {
	    // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
	    this.onError('data request overlap from client');
	    res.writeHead(500);
	    return;
	  }
	
	  var isBinary = 'application/octet-stream' == req.headers['content-type'];
	
	  this.dataReq = req;
	  this.dataRes = res;
	
	  var chunks = isBinary ? new Buffer(0) : '';
	  var self = this;
	
	  function cleanup () {
	    chunks = isBinary ? new Buffer(0) : '';
	    req.removeListener('data', onData);
	    req.removeListener('end', onEnd);
	    req.removeListener('close', onClose);
	    self.dataReq = self.dataRes = null;
	  }
	
	  function onClose () {
	    cleanup();
	    self.onError('data request connection closed prematurely');
	  }
	
	  function onData (data) {
	    var contentLength;
	    if (typeof data == 'string') {
	      chunks += data;
	      contentLength = Buffer.byteLength(chunks);
	    } else {
	      chunks = Buffer.concat([chunks, data]);
	      contentLength = chunks.length;
	    }
	
	    if (contentLength > self.maxHttpBufferSize) {
	      chunks = '';
	      req.connection.destroy();
	    }
	  }
	
	  function onEnd () {
	    self.onData(chunks);
	
	    var headers = {
	      // text/html is required instead of text/plain to avoid an
	      // unwanted download dialog on certain user-agents (GH-43)
	      'Content-Type': 'text/html',
	      'Content-Length': 2
	    };
	
	    // prevent XSS warnings on IE
	    // https://github.com/LearnBoost/socket.io/pull/1333
	    var ua = req.headers['user-agent'];
	    if (ua && (~ua.indexOf(';MSIE') || ~ua.indexOf('Trident/'))) {
	      headers['X-XSS-Protection'] = '0';
	    }
	
	    res.writeHead(200, self.headers(req, headers));
	    res.end('ok');
	    cleanup();
	  }
	
	  req.on('close', onClose);
	  req.on('data', onData);
	  req.on('end', onEnd);
	  if (!isBinary) req.setEncoding('utf8');
	};
	
	/**
	 * Processes the incoming data payload.
	 *
	 * @param {String} encoded payload
	 * @api private
	 */
	
	Polling.prototype.onData = function (data) {
	  debug('received "%s"', data);
	  var self = this;
	  var callback = function(packet) {
	    if ('close' == packet.type) {
	      debug('got xhr close packet');
	      self.onClose();
	      return false;
	    }
	
	    self.onPacket(packet);
	  };
	
	  parser.decodePayload(data, callback);
	};
	
	/**
	 * Overrides onClose.
	 *
	 * @api private
	 */
	
	Polling.prototype.onClose = function () {
	  if (this.writable) {
	    // close pending poll request
	    this.send([{ type: 'noop' }]);
	  }
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Writes a packet payload.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Polling.prototype.send = function (packets) {
	  if (this.shouldClose) {
	    debug('appending close packet to payload');
	    packets.push({ type: 'close' });
	    this.shouldClose();
	    this.shouldClose = null;
	  }
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.write(data);
	  });
	};
	
	/**
	 * Writes data as response to poll request.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Polling.prototype.write = function (data) {
	  debug('writing "%s"', data);
	  this.doWrite(data);
	  this.req.cleanup();
	  this.writable = false;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function (fn) {
	  debug('closing');
	
	  if (this.dataReq) {
	    debug('aborting ongoing data request');
	    this.dataReq.destroy();
	  }
	
	  if (this.writable) {
	    debug('transport writable - closing right away');
	    this.send([{ type: 'close' }]);
	    fn();
	  } else {
	    debug('transport not writable - buffering orderly close');
	    this.shouldClose = fn;
	  }
	};


/***/ },
/* 457 */
/*!*****************************************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/transports/polling-jsonp.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Polling = __webpack_require__(/*! ./polling */ 456);
	var qs = __webpack_require__(/*! querystring */ 458);
	var rDoubleSlashes = /\\\\n/g;
	var rSlashes = /(\\)?\\n/g;
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONP;
	
	/**
	 * JSON-P polling transport.
	 *
	 * @api public
	 */
	
	function JSONP (req) {
	  Polling.call(this, req);
	
	  this.head = '___eio[' + (req._query.j || '').replace(/[^0-9]/g, '') + '](';
	  this.foot = ');';
	};
	
	/**
	 * Inherits from Polling.
	 */
	
	JSONP.prototype.__proto__ = Polling.prototype;
	
	/**
	 * Handles incoming data.
	 * Due to a bug in \n handling by browsers, we expect a escaped string.
	 *
	 * @api private
	 */
	
	JSONP.prototype.onData = function (data) {
	  // we leverage the qs module so that we get built-in DoS protection
	  // and the fast alternative to decodeURIComponent
	  data = qs.parse(data).d;
	  if ('string' == typeof data) {
	    //client will send already escaped newlines as \\\\n and newlines as \\n
	    // \\n must be replaced with \n and \\\\n with \\n
	    data = data.replace(rSlashes, function(match, slashes) {
	      return slashes ? match : '\n';
	    });
	    Polling.prototype.onData.call(this, data.replace(rDoubleSlashes, '\\n'));
	  }
	};
	
	/**
	 * Performs the write.
	 *
	 * @api private
	 */
	
	JSONP.prototype.doWrite = function (data) {
	  // we must output valid javascript, not valid json
	  // see: http://timelessrepo.com/json-isnt-a-javascript-subset
	  var js = JSON.stringify(data)
	    .replace(/\u2028/g, '\\u2028')
	    .replace(/\u2029/g, '\\u2029');
	
	  // prepare response
	  data = this.head + js + this.foot;
	
	  // explicit UTF-8 is required for pages not served under utf
	  var headers = {
	    'Content-Type': 'text/javascript; charset=UTF-8',
	    'Content-Length': Buffer.byteLength(data)
	  };
	
	  // prevent XSS warnings on IE
	  // https://github.com/LearnBoost/socket.io/pull/1333
	  var ua = this.req.headers['user-agent'];
	  if (ua && (~ua.indexOf(';MSIE') || ~ua.indexOf('Trident/'))) {
	    headers['X-XSS-Protection'] = '0';
	  }
	
	  this.res.writeHead(200, this.headers(this.req, headers));
	  this.res.end(data);
	};
	
	/**
	 * Returns headers for a response.
	 *
	 * @param {http.ServerRequest} request
	 * @param {Object} extra headers
	 * @api private
	 */
	
	JSONP.prototype.headers = function (req, headers) {
	  headers = headers || {};
	
	  // disable XSS protection for IE
	  if (/MSIE 8\.0/.test(req.headers['user-agent'])) {
	    headers['X-XSS-Protection'] = '0';
	  }
	
	  this.emit('headers', headers);
	  return headers;
	};


/***/ },
/* 458 */
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("querystring");

/***/ },
/* 459 */
/*!*************************************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/transports/websocket.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(/*! ../transport */ 446)
	  , parser = __webpack_require__(/*! engine.io-parser */ 448)
	  , debug = __webpack_require__(/*! debug */ 439)('engine:ws')
	
	/**
	 * Export the constructor.
	 */
	
	module.exports = WebSocket;
	
	/**
	 * WebSocket transport 
	 *
	 * @param {http.ServerRequest}
	 * @api public
	 */
	
	function WebSocket (req) {
	  Transport.call(this, req);
	  var self = this;
	  this.socket = req.websocket;
	  this.socket.on('message', this.onData.bind(this));
	  this.socket.once('close', this.onClose.bind(this));
	  this.socket.on('error', this.onError.bind(this));
	  this.socket.on('headers', function (headers) {
	    self.emit('headers', headers);
	  });
	  this.writable = true;
	};
	
	/**
	 * Inherits from Transport.
	 */
	
	WebSocket.prototype.__proto__ = Transport.prototype;
	
	/**
	 * Transport name
	 *
	 * @api public
	 */
	
	WebSocket.prototype.name = 'websocket';
	
	/**
	 * Advertise upgrade support.
	 *
	 * @api public
	 */
	
	WebSocket.prototype.handlesUpgrades = true;
	
	/**
	 * Advertise framing support.
	 *
	 * @api public
	 */
	
	WebSocket.prototype.supportsFraming = true;
	
	/**
	 * Processes the incoming data.
	 *
	 * @param {String} encoded packet
	 * @api private
	 */
	
	WebSocket.prototype.onData = function (data) {
	  debug('received "%s"', data);
	  Transport.prototype.onData.call(this, data);
	};
	
	/**
	 * Writes a packet payload.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	WebSocket.prototype.send = function (packets) {
	  var self = this;
	  for (var i = 0, l = packets.length; i < l; i++) {
	    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
	      debug('writing "%s"', data);
	      self.writable = false;
	      self.socket.send(data, function (err){
	        if (err) return self.onError('write error', err.stack);
	        self.writable = true;
	        self.emit('drain');
	      });
	    });
	  }
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	WebSocket.prototype.doClose = function (fn) {
	  debug('closing');
	  this.socket.close();
	  fn && fn();
	};


/***/ },
/* 460 */
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("crypto");

/***/ },
/* 461 */
/*!***************************!*\
  !*** external "base64id" ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("base64id");

/***/ },
/* 462 */
/*!***********************************************!*\
  !*** ./~/socket.io/~/engine.io/lib/socket.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(/*! events */ 447).EventEmitter;
	var debug = __webpack_require__(/*! debug */ 439)('engine:socket');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Client class (abstract).
	 *
	 * @api private
	 */
	
	function Socket (id, server, transport, req) {
	  this.id = id;
	  this.server = server;
	  this.upgraded = false;
	  this.readyState = 'opening';
	  this.writeBuffer = [];
	  this.packetsFn = [];
	  this.sentCallbackFn = [];
	  this.request = req;
	
	  // Cache IP since it might not be in the req later
	  this.remoteAddress = req.connection.remoteAddress;
	
	  this.checkIntervalTimer = null;
	  this.upgradeTimeoutTimer = null;
	  this.pingTimeoutTimer = null;
	
	  this.setTransport(transport);
	  this.onOpen();
	}
	
	/**
	 * Inherits from EventEmitter.
	 */
	
	Socket.prototype.__proto__ = EventEmitter.prototype;
	
	/**
	 * Called upon transport considered open.
	 *
	 * @api private
	 */
	
	Socket.prototype.onOpen = function () {
	  this.readyState = 'open';
	
	  // sends an `open` packet
	  this.transport.sid = this.id;
	  this.sendPacket('open', JSON.stringify({
	      sid: this.id
	    , upgrades: this.getAvailableUpgrades()
	    , pingInterval: this.server.pingInterval
	    , pingTimeout: this.server.pingTimeout
	  }));
	
	  this.emit('open');
	  this.setPingTimeout();
	};
	
	/**
	 * Called upon transport packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('open' == this.readyState) {
	    // export packet event
	    debug('packet');
	    this.emit('packet', packet);
	
	    // Reset ping timeout on any packet, incoming data is a good sign of
	    // other side's liveness
	    this.setPingTimeout();
	
	    switch (packet.type) {
	
	      case 'ping':
	        debug('got ping');
	        this.sendPacket('pong');
	        this.emit('heartbeat');
	        break;
	
	      case 'error':
	        this.onClose('parse error');
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with closed socket');
	  }
	};
	
	/**
	 * Called upon transport error.
	 *
	 * @param {Error} error object
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('transport error');
	  this.onClose('transport error', err);
	};
	
	/**
	 * Sets and resets ping timeout timer based on client pings.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPingTimeout = function () {
	  var self = this;
	  clearTimeout(self.pingTimeoutTimer);
	  self.pingTimeoutTimer = setTimeout(function () {
	    self.onClose('ping timeout');
	  }, self.server.pingInterval + self.server.pingTimeout);
	};
	
	/**
	 * Attaches handlers for the given transport.
	 *
	 * @param {Transport} transport
	 * @api private
	 */
	
	Socket.prototype.setTransport = function (transport) {
	  this.transport = transport;
	  this.transport.once('error', this.onError.bind(this));
	  this.transport.on('packet', this.onPacket.bind(this));
	  this.transport.on('drain', this.flush.bind(this));
	  this.transport.once('close', this.onClose.bind(this, 'transport close'));
	  //this function will manage packet events (also message callbacks)
	  this.setupSendCallback();
	};
	
	/**
	 * Upgrades socket to the given transport
	 *
	 * @param {Transport} transport
	 * @api private
	 */
	
	Socket.prototype.maybeUpgrade = function (transport) {
	  debug('might upgrade socket transport from "%s" to "%s"'
	    , this.transport.name, transport.name);
	
	  var self = this;
	
	  // set transport upgrade timer
	  self.upgradeTimeoutTimer = setTimeout(function () {
	    debug('client did not complete upgrade - closing transport');
	    clearInterval(self.checkIntervalTimer);
	    self.checkIntervalTimer = null;
	    if ('open' == transport.readyState) {
	      transport.close();
	    }
	  }, this.server.upgradeTimeout);
	
	  function onPacket(packet){
	    if ('ping' == packet.type && 'probe' == packet.data) {
	      transport.send([{ type: 'pong', data: 'probe' }]);
	      clearInterval(self.checkIntervalTimer);
	      self.checkIntervalTimer = setInterval(check, 100);
	    } else if ('upgrade' == packet.type && self.readyState != 'closed') {
	      debug('got upgrade packet - upgrading');
	      self.upgraded = true;
	      self.clearTransport();
	      self.setTransport(transport);
	      self.emit('upgrade', transport);
	      self.setPingTimeout();
	      self.flush();
	      clearInterval(self.checkIntervalTimer);
	      self.checkIntervalTimer = null;
	      clearTimeout(self.upgradeTimeoutTimer);
	      transport.removeListener('packet', onPacket);
	      if (self.readyState == 'closing') {
	        transport.close(function () {
	          self.onClose('forced close');
	        });
	      }
	    } else {
	      transport.close();
	    }
	  }
	
	  // we force a polling cycle to ensure a fast upgrade
	  function check(){
	    if ('polling' == self.transport.name && self.transport.writable) {
	      debug('writing a noop packet to polling for fast upgrade');
	      self.transport.send([{ type: 'noop' }]);
	    }
	  }
	
	  transport.on('packet', onPacket);
	};
	
	/**
	 * Clears listeners and timers associated with current transport.
	 *
	 * @api private
	 */
	
	Socket.prototype.clearTransport = function () {
	  // silence further transport errors and prevent uncaught exceptions
	  this.transport.on('error', function(){
	    debug('error triggered by discarded transport');
	  });
	  clearTimeout(this.pingTimeoutTimer);
	};
	
	/**
	 * Called upon transport considered closed.
	 * Possible reasons: `ping timeout`, `client error`, `parse error`,
	 * `transport error`, `server close`, `transport close`
	 */
	
	Socket.prototype.onClose = function (reason, description) {
	  if ('closed' != this.readyState) {
	    clearTimeout(this.pingTimeoutTimer);
	    clearInterval(this.checkIntervalTimer);
	    this.checkIntervalTimer = null;
	    clearTimeout(this.upgradeTimeoutTimer);
	    var self = this;
	    // clean writeBuffer in next tick, so developers can still
	    // grab the writeBuffer on 'close' event
	    process.nextTick(function() {
	      self.writeBuffer = [];
	    });
	    this.packetsFn = [];
	    this.sentCallbackFn = [];
	    this.clearTransport();
	    this.readyState = 'closed';
	    this.emit('close', reason, description);
	  }
	};
	
	/**
	 * Setup and manage send callback
	 *
	 * @api private
	 */
	
	Socket.prototype.setupSendCallback = function () {
	  var self = this;
	  //the message was sent successfully, execute the callback
	  this.transport.on('drain', function() {
	    if (self.sentCallbackFn.length > 0) {
	      var seqFn = self.sentCallbackFn.splice(0,1)[0];
	      if ('function' == typeof seqFn) {
	        debug('executing send callback');
	        seqFn(self.transport);
	      } else if (Array.isArray(seqFn)) {
	        debug('executing batch send callback');
	        for (var l = seqFn.length, i = 0; i < l; i++) {
	          if ('function' == typeof seqFn[i]) {
	            seqFn[i](self.transport);
	          }
	        }
	      }
	    }
	  });
	};
	
	/**
	 * Sends a message packet.
	 *
	 * @param {String} message
	 * @param {Function} callback
	 * @return {Socket} for chaining
	 * @api public
	 */
	
	Socket.prototype.send =
	Socket.prototype.write = function(data, callback){
	  this.sendPacket('message', data, callback);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type
	 * @param {String} optional, data
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, callback) {
	  if ('closing' != this.readyState) {
	    debug('sending packet "%s" (%s)', type, data);
	
	    var packet = { type: type };
	    if (data) packet.data = data;
	
	    // exports packetCreate event
	    this.emit('packetCreate', packet);
	
	    this.writeBuffer.push(packet);
	
	    //add send callback to object
	    this.packetsFn.push(callback);
	
	    this.flush();
	  }
	};
	
	/**
	 * Attempts to flush the packets buffer.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable
	    && this.writeBuffer.length) {
	    debug('flushing buffer to transport');
	    this.emit('flush', this.writeBuffer);
	    this.server.emit('flush', this, this.writeBuffer);
	    var wbuf = this.writeBuffer;
	    this.writeBuffer = [];
	    if (!this.transport.supportsFraming) {
	      this.sentCallbackFn.push(this.packetsFn);
	    } else {
	      this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
	    }
	    this.packetsFn = [];
	    this.transport.send(wbuf);
	    this.emit('drain');
	    this.server.emit('drain', this);
	  }
	};
	
	/**
	 * Get available upgrades for this socket.
	 *
	 * @api private
	 */
	
	Socket.prototype.getAvailableUpgrades = function () {
	  var availableUpgrades = [];
	  var allUpgrades = this.server.upgrades(this.transport.name);
	  for (var i = 0, l = allUpgrades.length; i < l; ++i) {
	    var upg = allUpgrades[i];
	    if (this.server.transports.indexOf(upg) != -1) {
	      availableUpgrades.push(upg);
	    }
	  }
	  return availableUpgrades;
	};
	
	/**
	 * Closes the socket and underlying transport.
	 *
	 * @return {Socket} for chaining
	 * @api public
	 */
	
	Socket.prototype.close = function () {
	  if ('open' != this.readyState) return;
	
	  this.readyState = 'closing';
	
	  if (this.writeBuffer.length) {
	    this.once('drain', this.closeTransport.bind(this));
	    return;
	  }
	
	  this.closeTransport();
	};
	
	/**
	 * Closes the underlying transport.
	 *
	 * @api private
	 */
	
	Socket.prototype.closeTransport = function () {
	  this.transport.close(this.onClose.bind(this, 'forced close'));
	};


/***/ },
/* 463 */
/*!*********************!*\
  !*** external "ws" ***!
  \*********************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("ws");

/***/ },
/* 464 */
/*!*************************************!*\
  !*** ./~/socket.io-client/index.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(/*! ./lib/ */ 465);


/***/ },
/* 465 */
/*!*****************************************!*\
  !*** ./~/socket.io-client/lib/index.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(/*! ./url */ 466);
	var parser = __webpack_require__(/*! socket.io-parser */ 468);
	var Manager = __webpack_require__(/*! ./manager */ 471);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if (typeof uri == 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var io;
	
	  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	
	  return io.socket(parsed.path);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(/*! ./manager */ 471);
	exports.Socket = __webpack_require__(/*! ./socket */ 489);


/***/ },
/* 466 */
/*!***************************************!*\
  !*** ./~/socket.io-client/lib/url.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(/*! parseuri */ 467);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc){
	  var obj = uri;
	
	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.hostname + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    }
	    else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  // define unique id
	  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
	
	  return obj;
	}


/***/ },
/* 467 */
/*!***************************!*\
  !*** external "parseuri" ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("parseuri");

/***/ },
/* 468 */
/*!********************************************************!*\
  !*** ./~/socket.io-client/~/socket.io-parser/index.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(/*! debug */ 439)('socket.io-parser');
	var json = __webpack_require__(/*! json3 */ 440);
	var isArray = __webpack_require__(/*! isarray */ 441);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	var binary = __webpack_require__(/*! ./binary */ 469);
	var isBuf = __webpack_require__(/*! ./is-buffer */ 470);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'BINARY_EVENT',
	  'ACK',
	  'BINARY_ACK',
	  'ERROR'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 469 */
/*!*********************************************************!*\
  !*** ./~/socket.io-client/~/socket.io-parser/binary.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(/*! isarray */ 441);
	var isBuf = __webpack_require__(/*! ./is-buffer */ 470);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};


/***/ },
/* 470 */
/*!************************************************************!*\
  !*** ./~/socket.io-client/~/socket.io-parser/is-buffer.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}


/***/ },
/* 471 */
/*!*******************************************!*\
  !*** ./~/socket.io-client/lib/manager.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(/*! ./url */ 466);
	var eio = __webpack_require__(/*! engine.io-client */ 472);
	var Socket = __webpack_require__(/*! ./socket */ 489);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	var parser = __webpack_require__(/*! socket.io-parser */ 468);
	var on = __webpack_require__(/*! ./on */ 491);
	var bind = __webpack_require__(/*! component-bind */ 492);
	var object = __webpack_require__(/*! object-component */ 494);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io-client:manager');
	var indexOf = __webpack_require__(/*! indexof */ 487);
	var Backoff = __webpack_require__(/*! backo2 */ 495);
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts){
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' == typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connected = [];
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function() {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function(){
	  for (var nsp in this.nsps) {
	    this.nsps[nsp].id = this.engine.id;
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function(v){
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function(v){
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function(v){
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function(v){
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function(v){
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function(v){
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function() {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open =
	Manager.prototype.connect = function(fn){
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function() {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function(data){
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function(){
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function(){
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function(data){
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function(packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function(err){
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function(nsp){
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connect', function(){
	      socket.id = self.engine.id;
	      if (!~indexOf(self.connected, socket)) {
	        self.connected.push(socket);
	      }
	    });
	  }
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function(socket){
	  var index = indexOf(this.connected, socket);
	  if (~index) this.connected.splice(index, 1);
	  if (this.connected.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function(packet){
	  debug('writing packet %j', packet);
	  var self = this;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function(encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i]);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function() {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function(){
	  var sub;
	  while (sub = this.subs.shift()) sub.destroy();
	
	  this.packetBuffer = [];
	  this.encoding = false;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close =
	Manager.prototype.disconnect = function(){
	  this.skipReconnect = true;
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.engine && this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function(reason){
	  debug('close');
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function(){
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function(){
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function(err){
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function(){
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};


/***/ },
/* 472 */
/*!********************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/index.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports =  __webpack_require__(/*! ./lib/ */ 473);


/***/ },
/* 473 */
/*!************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/index.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(/*! ./socket */ 474);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(/*! engine.io-parser */ 481);


/***/ },
/* 474 */
/*!*************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/socket.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(/*! ./transports */ 475);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	var debug = __webpack_require__(/*! debug */ 439)('engine.io-client:socket');
	var index = __webpack_require__(/*! indexof */ 487);
	var parser = __webpack_require__(/*! engine.io-parser */ 481);
	var parseuri = __webpack_require__(/*! parseuri */ 467);
	var parsejson = __webpack_require__(/*! parsejson */ 488);
	var parseqs = __webpack_require__(/*! parseqs */ 484);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop(){}
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.host = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  }
	
	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);
	
	  if (opts.host) {
	    var pieces = opts.host.split(':');
	    opts.hostname = pieces.shift();
	    if (pieces.length) {
	      opts.port = pieces.pop();
	    } else if (!opts.port) {
	      // if no port is specified manually, use the protocol default
	      opts.port = this.secure ? '443' : '80';
	    }
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.callbackBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized || null;
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(/*! ./transport */ 480);
	Socket.transports = __webpack_require__(/*! ./transports */ 475);
	Socket.parser = __webpack_require__(/*! engine.io-parser */ 481);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized
	  });
	
	  return transport;
	};
	
	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 == this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  var transport;
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport() {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose(){
	    onerror("transport closed");
	  }
	
	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }
	
	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.emit('error', err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api public
	*/
	
	Socket.prototype.ping = function () {
	  this.sendPacket('ping');
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function() {
	  for (var i = 0; i < this.prevBufferLen; i++) {
	    if (this.callbackBuffer[i]) {
	      this.callbackBuffer[i]();
	    }
	  }
	
	  this.writeBuffer.splice(0, this.prevBufferLen);
	  this.callbackBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (this.writeBuffer.length == 0) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write =
	Socket.prototype.send = function (msg, fn) {
	  this.sendPacket('message', msg, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, fn) {
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }
	
	  var packet = { type: type, data: data };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  this.callbackBuffer.push(fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    function close() {
	      self.onClose('forced close');
	      debug('socket closing - telling transport to close');
	      self.transport.close();
	    }
	
	    function cleanupAndClose() {
	      self.removeListener('upgrade', cleanupAndClose);
	      self.removeListener('upgradeError', cleanupAndClose);
	      close();
	    }
	
	    function waitForUpgrade() {
	      // wait for upgrade to finish since we can't send packets while pausing a transport
	      self.once('upgrade', cleanupAndClose);
	      self.once('upgradeError', cleanupAndClose);
	    }
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // clean buffers in next tick, so developers can still
	    // grab the buffers on `close` event
	    setTimeout(function() {
	      self.writeBuffer = [];
	      self.callbackBuffer = [];
	      self.prevBufferLen = 0;
	    }, 0);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};


/***/ },
/* 475 */
/*!***********************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/transports/index.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest */ 476);
	var XHR = __webpack_require__(/*! ./polling-xhr */ 477);
	var JSONP = __webpack_require__(/*! ./polling-jsonp */ 485);
	var websocket = __webpack_require__(/*! ./websocket */ 486);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}


/***/ },
/* 476 */
/*!*********************************!*\
  !*** external "xmlhttprequest" ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("xmlhttprequest");

/***/ },
/* 477 */
/*!*****************************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/transports/polling-xhr.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest */ 476);
	var Polling = __webpack_require__(/*! ./polling */ 478);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	var inherit = __webpack_require__(/*! component-inherit */ 479);
	var debug = __webpack_require__(/*! debug */ 439)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty(){}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR(opts){
	  Polling.call(this, opts);
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        data = 'ok';
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function(){
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}


/***/ },
/* 478 */
/*!*************************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/transports/polling.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(/*! ../transport */ 480);
	var parseqs = __webpack_require__(/*! parseqs */ 484);
	var parser = __webpack_require__(/*! engine.io-parser */ 481);
	var inherit = __webpack_require__(/*! component-inherit */ 479);
	var debug = __webpack_require__(/*! debug */ 439)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest */ 476);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function(){
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function(){
	  var self = this;
	
	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  return schema + '://' + this.hostname + port + this.path + query;
	};


/***/ },
/* 479 */
/*!************************************!*\
  !*** external "component-inherit" ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("component-inherit");

/***/ },
/* 480 */
/*!****************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/transport.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(/*! engine.io-parser */ 481);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * A counter used to prevent collisions in the timestamps used
	 * for cache busting.
	 */
	
	Transport.timestamps = 0;
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 481 */
/*!***************************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/~/engine.io-parser/index.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(/*! ./lib/ */ 482);


/***/ },
/* 482 */
/*!*******************************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/~/engine.io-parser/lib/index.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var utf8 = __webpack_require__(/*! utf8 */ 450);
	var after = __webpack_require__(/*! after */ 451);
	var keys = __webpack_require__(/*! ./keys */ 483);
	
	/**
	 * Current protocol version.
	 */
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  if ('function' == typeof utf8encode ) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (Buffer.isBuffer(data)) {
	    return encodeBuffer(packet, supportsBinary, callback);
	  } else if (data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	};
	
	/**
	 * Encode Buffer data
	 */
	
	function encodeBuffer(packet, supportsBinary, callback) {
	  var data = packet.data;
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var typeBuffer = new Buffer(1);
	  typeBuffer[0] = packets[packet.type];
	  return callback(Buffer.concat([typeBuffer, data]));
	}
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Buffer(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++){
	    resultBuffer[i+1] = contentArray[i];
	  }
	  return callback(resultBuffer);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback){
	  var data = packet.data.buffer || packet.data;
	  if (data instanceof ArrayBuffer) {
	    var buf = new Buffer(data.byteLength);
	    for (var i = 0; i < buf.length; i++) {
	      buf[i] = data[i];
	    }
	    packet.data = buf;
	  }
	
	  var message = 'b' + packets[packet.type];
	  message += packet.data.toString('base64');
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Data also available as an ArrayBuffer if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    var type = data.charAt(0);
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  // Binary data
	  if (binaryType === 'arraybuffer') {
	    var type = data[0];
	    var intArray = new Uint8Array(data.length - 1);
	    for (var i = 1; i < data.length; i++) {
	      intArray[i - 1] = data[i];
	    }
	    return { type: packetslist[type], data: intArray.buffer };
	  }
	  var type = data[0];
	  return { type: packetslist[type], data: data.slice(1) };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string.
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  var data = new Buffer(msg.substr(1), 'base64');
	  if (binaryType === 'arraybuffer') {
	    var abv = new Uint8Array(data.length);
	    for (var i = 0; i < abv.length; i++){
	      abv[i] = data[i];
	    }
	    data = abv.buffer;
	  }
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  if (supportsBinary) {
	    return exports.encodePayloadAsBinary(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if ('string' != typeof data) {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = ''
	    , n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 *
	 * Converts a buffer to a utf8.js encoded string
	 *
	 * @api private
	 */
	
	function bufferToString(buffer) {
	  var str = '';
	  for (var i = 0; i < buffer.length; i++) {
	    str += String.fromCharCode(buffer[i]);
	  }
	  return str;
	}
	
	/**
	 *
	 * Converts a utf8.js encoded string to a buffer
	 *
	 * @api private
	 */
	
	function stringToBuffer(string) {
	  var buf = new Buffer(string.length);
	  for (var i = 0; i < string.length; i++) {
	    buf.writeUInt8(string.charCodeAt(i), i);
	  }
	  return buf;
	}
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {Buffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsBinary = function (packets, callback) {
	  if (!packets.length) {
	    return callback(new Buffer(0));
	  }
	
	  function encodeOne(p, doneCallback) {
	    exports.encodePacket(p, true, true, function(packet) {
	
	      if (typeof packet === 'string') {
	        var encodingLength = '' + packet.length;
	        var sizeBuffer = new Buffer(encodingLength.length + 2);
	        sizeBuffer[0] = 0; // is a string (not true binary = 0)
	        for (var i = 0; i < encodingLength.length; i++) {
	          sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
	        }
	        sizeBuffer[sizeBuffer.length - 1] = 255;
	        return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
	      }
	
	      var encodingLength = '' + packet.length;
	      var sizeBuffer = new Buffer(encodingLength.length + 2);
	      sizeBuffer[0] = 1; // is binary (true binary = 1)
	      for (var i = 0; i < encodingLength.length; i++) {
	        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
	      }
	      sizeBuffer[sizeBuffer.length - 1] = 255;
	      doneCallback(null, Buffer.concat([sizeBuffer, packet]));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(Buffer.concat(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	
	 * @param {Buffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  while (bufferTail.length > 0) {
	    var strLen = '';
	    var isString = bufferTail[0] === 0;
	    var numberTooLong = false;
	    for (var i = 1; ; i++) {
	      if (bufferTail[i] == 255)  break;
	      // 310 = char length of Number.MAX_VALUE
	      if (strLen.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	      strLen += '' + bufferTail[i];
	    }
	    if(numberTooLong) return callback(err, 0, 1);
	    bufferTail = bufferTail.slice(strLen.length + 1);
	
	    var msgLength = parseInt(strLen, 10);
	
	    var msg = bufferTail.slice(1, msgLength + 1);
	    if (isString) msg = bufferToString(msg);
	    buffers.push(msg);
	    bufferTail = bufferTail.slice(msgLength + 1);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};


/***/ },
/* 483 */
/*!******************************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/~/engine.io-parser/lib/keys.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 484 */
/*!**************************!*\
  !*** external "parseqs" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("parseqs");

/***/ },
/* 485 */
/*!*******************************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/transports/polling-jsonp.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(/*! ./polling */ 478);
	var inherit = __webpack_require__(/*! component-inherit */ 479);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Callbacks count.
	 */
	
	var index = 0;
	
	/**
	 * Noop.
	 */
	
	function empty () { }
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling (opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  insertAt.parentNode.insertBefore(script, insertAt);
	  this.script = script;
	
	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete () {
	    initIframe();
	    fn();
	  }
	
	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch(e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};


/***/ },
/* 486 */
/*!***************************************************************************!*\
  !*** ./~/socket.io-client/~/engine.io-client/lib/transports/websocket.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(/*! ../transport */ 480);
	var parser = __webpack_require__(/*! engine.io-parser */ 481);
	var parseqs = __webpack_require__(/*! parseqs */ 484);
	var inherit = __webpack_require__(/*! component-inherit */ 479);
	var debug = __webpack_require__(/*! debug */ 439)('engine.io-client:websocket');
	
	/**
	 * `ws` exposes a WebSocket-compatible interface in
	 * Node, or the `WebSocket` or `MozWebSocket` globals
	 * in the browser.
	 */
	
	var WebSocket = __webpack_require__(/*! ws */ 463);
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = { agent: this.agent };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  this.ws = new WebSocket(uri, protocols, opts);
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  this.ws.binaryType = 'arraybuffer';
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function(){
	  var self = this;
	
	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */
	
	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  for (var i = 0, l = packets.length; i < l; i++) {
	    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
	      //Sometimes the websocket has already been closed but the browser didn't
	      //have a chance of informing us about it yet, in that case send will
	      //throw an error
	      try {
	        self.ws.send(data);
	      } catch (e){
	        debug('websocket closed before onclose event');
	      }
	    });
	  }
	
	  function ondrain() {
	    self.writable = true;
	    self.emit('drain');
	  }
	  // fake drain
	  // defer to next tick to allow Socket to clear writeBuffer
	  setTimeout(ondrain, 0);
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = +new Date;
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  return schema + '://' + this.hostname + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};


/***/ },
/* 487 */
/*!**************************!*\
  !*** external "indexof" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("indexof");

/***/ },
/* 488 */
/*!****************************!*\
  !*** external "parsejson" ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("parsejson");

/***/ },
/* 489 */
/*!******************************************!*\
  !*** ./~/socket.io-client/lib/socket.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(/*! socket.io-parser */ 468);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	var toArray = __webpack_require__(/*! to-array */ 490);
	var on = __webpack_require__(/*! ./on */ 491);
	var bind = __webpack_require__(/*! component-bind */ 492);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io-client:socket');
	var hasBin = __webpack_require__(/*! has-binary */ 493);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp){
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  if (this.io.autoConnect) this.open();
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function() {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open =
	Socket.prototype.connect = function(){
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function(){
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function(ev){
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };
	
	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function(packet){
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function(){
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function(reason){
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function(packet){
	  if (packet.nsp != this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function(packet){
	  debug('calling ack %s with %j', packet.id, packet.data);
	  var fn = this.acks[packet.id];
	  fn.apply(this, packet.data);
	  delete this.acks[packet.id];
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function(){
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function(){
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function(){
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function(){
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close =
	Socket.prototype.disconnect = function(){
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};


/***/ },
/* 490 */
/*!***************************!*\
  !*** external "to-array" ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("to-array");

/***/ },
/* 491 */
/*!**************************************!*\
  !*** ./~/socket.io-client/lib/on.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function(){
	      obj.removeListener(ev, fn);
	    }
	  };
	}


/***/ },
/* 492 */
/*!*********************************!*\
  !*** external "component-bind" ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("component-bind");

/***/ },
/* 493 */
/*!*****************************!*\
  !*** external "has-binary" ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("has-binary");

/***/ },
/* 494 */
/*!***********************************!*\
  !*** external "object-component" ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("object-component");

/***/ },
/* 495 */
/*!*************************!*\
  !*** external "backo2" ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("backo2");

/***/ },
/* 496 */,
/* 497 */
/*!**************************************!*\
  !*** ./~/socket.io/lib/namespace.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Socket = __webpack_require__(/*! ./socket */ 498);
	var Emitter = __webpack_require__(/*! events */ 447).EventEmitter;
	var parser = __webpack_require__(/*! socket.io-parser */ 437);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io:namespace');
	var hasBin = __webpack_require__(/*! has-binary-data */ 499);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Namespace;
	
	/**
	 * Blacklisted events.
	 */
	
	exports.events = [
	  'connect',    // for symmetry with client
	  'connection',
	  'newListener'
	];
	
	/**
	 * Flags.
	 */
	
	exports.flags = ['json'];
	
	/**
	 * `EventEmitter#emit` reference.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * Namespace constructor.
	 *
	 * @param {Server} server instance
	 * @param {Socket} name
	 * @api private
	 */
	
	function Namespace(server, name){
	  this.name = name;
	  this.server = server;
	  this.sockets = [];
	  this.connected = {};
	  this.fns = [];
	  this.ids = 0;
	  this.acks = {};
	  this.initAdapter();
	}
	
	/**
	 * Inherits from `EventEmitter`.
	 */
	
	Namespace.prototype.__proto__ = Emitter.prototype;
	
	/**
	 * Apply flags from `Socket`.
	 */
	
	exports.flags.forEach(function(flag){
	  Namespace.prototype.__defineGetter__(flag, function(){
	    this.flags = this.flags || {};
	    this.flags[flag] = true;
	    return this;
	  });
	});
	
	/**
	 * Initializes the `Adapter` for this nsp.
	 * Run upon changing adapter by `Server#adapter`
	 * in addition to the constructor.
	 *
	 * @api private
	 */
	
	Namespace.prototype.initAdapter = function(){
	  this.adapter = new (this.server.adapter())(this);
	};
	
	/**
	 * Sets up namespace middleware.
	 *
	 * @return {Namespace} self
	 * @api public
	 */
	
	Namespace.prototype.use = function(fn){
	  this.fns.push(fn);
	  return this;
	};
	
	/**
	 * Executes the middleware for an incoming client.
	 *
	 * @param {Socket} socket that will get added
	 * @param {Function} last fn call in the middleware
	 * @api private
	 */
	
	Namespace.prototype.run = function(socket, fn){
	  var fns = this.fns.slice(0);
	  if (!fns.length) return fn(null);
	
	  function run(i){
	    fns[i](socket, function(err){
	      // upon error, short-circuit
	      if (err) return fn(err);
	
	      // if no middleware left, summon callback
	      if (!fns[i + 1]) return fn(null);
	
	      // go on to next
	      run(i + 1);
	    });
	  }
	
	  run(0);
	};
	
	/**
	 * Targets a room when emitting.
	 *
	 * @param {String} name
	 * @return {Namespace} self
	 * @api public
	 */
	
	Namespace.prototype.to =
	Namespace.prototype['in'] = function(name){
	  this.rooms = this.rooms || [];
	  if (!~this.rooms.indexOf(name)) this.rooms.push(name);
	  return this;
	};
	
	/**
	 * Adds a new client.
	 *
	 * @return {Socket}
	 * @api private
	 */
	
	Namespace.prototype.add = function(client, fn){
	  debug('adding socket to nsp %s', this.name);
	  var socket = new Socket(this, client);
	  var self = this;
	  this.run(socket, function(err){
	    process.nextTick(function(){
	      if ('open' == client.conn.readyState) {
	        if (err) return socket.error(err.data || err.message);
	
	        // track socket
	        self.sockets.push(socket);
	
	        // it's paramount that the internal `onconnect` logic
	        // fires before user-set events to prevent state order
	        // violations (such as a disconnection before the connection
	        // logic is complete)
	        socket.onconnect();
	        if (fn) fn();
	
	        // fire user-set events
	        self.emit('connect', socket);
	        self.emit('connection', socket);
	      } else {
	        debug('next called after client was closed - ignoring socket');
	      }
	    });
	  });
	  return socket;
	};
	
	/**
	 * Removes a client. Called by each `Socket`.
	 *
	 * @api private
	 */
	
	Namespace.prototype.remove = function(socket){
	  var i = this.sockets.indexOf(socket);
	  if (~i) {
	    this.sockets.splice(i, 1);
	  } else {
	    debug('ignoring remove for %s', socket.id);
	  }
	};
	
	/**
	 * Emits to all clients.
	 *
	 * @return {Namespace} self
	 * @api public
	 */
	
	Namespace.prototype.emit = function(ev){
	  if (~exports.events.indexOf(ev)) {
	    emit.apply(this, arguments);
	  } else {
	    // set up packet object
	    var args = Array.prototype.slice.call(arguments);
	    var parserType = parser.EVENT; // default
	    if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	
	    var packet = { type: parserType, data: args };
	
	    if ('function' == typeof args[args.length - 1]) {
	      throw new Error('Callbacks are not supported when broadcasting');
	    }
	
	    this.adapter.broadcast(packet, {
	      rooms: this.rooms,
	      flags: this.flags
	    });
	
	    delete this.rooms;
	    delete this.flags;
	  }
	  return this;
	};
	
	/**
	 * Sends a `message` event to all clients.
	 *
	 * @return {Namespace} self
	 * @api public
	 */
	
	Namespace.prototype.send =
	Namespace.prototype.write = function(){
	  var args = Array.prototype.slice.call(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};


/***/ },
/* 498 */
/*!***********************************!*\
  !*** ./~/socket.io/lib/socket.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Emitter = __webpack_require__(/*! events */ 447).EventEmitter;
	var parser = __webpack_require__(/*! socket.io-parser */ 437);
	var url = __webpack_require__(/*! url */ 444);
	var debug = __webpack_require__(/*! debug */ 439)('socket.io:socket');
	var hasBin = __webpack_require__(/*! has-binary-data */ 499);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Blacklisted events.
	 *
	 * @api public
	 */
	
	exports.events = [
	  'error',
	  'connect',
	  'disconnect',
	  'newListener',
	  'removeListener'
	];
	
	/**
	 * Flags.
	 *
	 * @api private
	 */
	
	var flags = [
	  'json',
	  'volatile',
	  'broadcast'
	];
	
	/**
	 * `EventEmitter#emit` reference.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * Interface to a `Client` for a given `Namespace`.
	 *
	 * @param {Namespace} nsp
	 * @param {Client} client
	 * @api public
	 */
	
	function Socket(nsp, client){
	  this.nsp = nsp;
	  this.server = nsp.server;
	  this.adapter = this.nsp.adapter;
	  this.id = client.id;
	  this.request = client.request;
	  this.client = client;
	  this.conn = client.conn;
	  this.rooms = [];
	  this.acks = {};
	  this.connected = true;
	  this.disconnected = false;
	  this.handshake = this.buildHandshake();
	}
	
	/**
	 * Inherits from `EventEmitter`.
	 */
	
	Socket.prototype.__proto__ = Emitter.prototype;
	
	/**
	 * Apply flags from `Socket`.
	 */
	
	flags.forEach(function(flag){
	  Socket.prototype.__defineGetter__(flag, function(){
	    this.flags = this.flags || {};
	    this.flags[flag] = true;
	    return this;
	  });
	});
	
	/**
	 * `request` engine.io shorcut.
	 *
	 * @api public
	 */
	
	Socket.prototype.__defineGetter__('request', function(){
	  return this.conn.request;
	});
	
	/**
	 * Builds the `handshake` BC object
	 *
	 * @api private
	 */
	
	Socket.prototype.buildHandshake = function(){
	  return {
	    headers: this.request.headers,
	    time: (new Date) + '',
	    address: this.conn.remoteAddress,
	    xdomain: !!this.request.headers.origin,
	    secure: !!this.request.connection.encrypted,
	    issued: +(new Date),
	    url: this.request.url,
	    query: url.parse(this.request.url, true).query || {}
	  };
	};
	
	/**
	 * Emits to this client.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function(ev){
	  if (~exports.events.indexOf(ev)) {
	    emit.apply(this, arguments);
	  } else {
	    var args = Array.prototype.slice.call(arguments);
	    var packet = {};
	    packet.type = hasBin(args) ? parser.BINARY_EVENT : parser.EVENT;
	    packet.data = args;
	
	    // access last argument to see if it's an ACK callback
	    if ('function' == typeof args[args.length - 1]) {
	      if (this._rooms || (this.flags && this.flags.broadcast)) {
	        throw new Error('Callbacks are not supported when broadcasting');
	      }
	
	      debug('emitting packet with ack id %d', this.nsp.ids);
	      this.acks[this.nsp.ids] = args.pop();
	      packet.id = this.nsp.ids++;
	    }
	
	    if (this._rooms || (this.flags && this.flags.broadcast)) {
	      this.adapter.broadcast(packet, {
	        except: [this.id],
	        rooms: this._rooms,
	        flags: this.flags
	      });
	    } else {
	      // dispatch packet
	      this.packet(packet);
	    }
	
	    // reset flags
	    delete this._rooms;
	    delete this.flags;
	  }
	  return this;
	};
	
	/**
	 * Targets a room when broadcasting.
	 *
	 * @param {String} name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.to =
	Socket.prototype.in = function(name){
	  this._rooms = this._rooms || [];
	  if (!~this._rooms.indexOf(name)) this._rooms.push(name);
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send =
	Socket.prototype.write = function(){
	  var args = Array.prototype.slice.call(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet object
	 * @api private
	 */
	
	Socket.prototype.packet = function(packet, preEncoded){
	  packet.nsp = this.nsp.name;
	  var volatile = this.flags && this.flags.volatile;
	  this.client.packet(packet, preEncoded, volatile);
	};
	
	/**
	 * Joins a room.
	 *
	 * @param {String} room
	 * @param {Function} optional, callback
	 * @return {Socket} self
	 * @api private
	 */
	
	Socket.prototype.join = function(room, fn){
	  debug('joining room %s', room);
	  var self = this;
	  if (~this.rooms.indexOf(room)) return this;
	  this.adapter.add(this.id, room, function(err){
	    if (err) return fn && fn(err);
	    debug('joined room %s', room);
	    self.rooms.push(room);
	    fn && fn(null);
	  });
	  return this;
	};
	
	/**
	 * Leaves a room.
	 *
	 * @param {String} room
	 * @param {Function} optional, callback
	 * @return {Socket} self
	 * @api private
	 */
	
	Socket.prototype.leave = function(room, fn){
	  debug('leave room %s', room);
	  var self = this;
	  this.adapter.del(this.id, room, function(err){
	    if (err) return fn && fn(err);
	    debug('left room %s', room);
	    var idx = self.rooms.indexOf(room);
	    if (idx >= 0) {
	      self.rooms.splice(idx, 1);
	    }
	    fn && fn(null);
	  });
	  return this;
	};
	
	/**
	 * Leave all rooms.
	 *
	 * @api private
	 */
	
	Socket.prototype.leaveAll = function(){
	  this.adapter.delAll(this.id);
	  this.rooms = [];
	};
	
	/**
	 * Called by `Namespace` upon succesful
	 * middleware execution (ie: authorization).
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function(){
	  debug('socket connected - writing packet');
	  this.join(this.id);
	  this.packet({ type: parser.CONNECT });
	  this.nsp.connected[this.id] = this;
	};
	
	/**
	 * Called with each packet. Called by `Client`.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function(packet){
	  debug('got packet %j', packet);
	  switch (packet.type) {
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	  }
	};
	
	/**
	 * Called upon event packet.
	 *
	 * @param {Object} packet object
	 * @api private
	 */
	
	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  emit.apply(this, args);
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @param {Number} packet id
	 * @api private
	 */
	
	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    var args = Array.prototype.slice.call(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      id: id,
	      type: type,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon ack packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onack = function(packet){
	  var ack = this.acks[packet.id];
	  if ('function' == typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon client disconnect packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function(){
	  debug('got disconnect packet');
	  this.onclose('client namespace disconnect');
	};
	
	/**
	 * Handles a client error.
	 *
	 * @api private
	 */
	
	Socket.prototype.onerror = function(err){
	  if (this.listeners('error').length) {
	    this.emit('error', err);
	  } else {
	    console.error('Missing error handler on `socket`.');
	    console.error(err.stack);
	  }
	};
	
	/**
	 * Called upon closing. Called by `Client`.
	 *
	 * @param {String} reason
	 * @param {Error} optional error object
	 * @api private
	 */
	
	Socket.prototype.onclose = function(reason){
	  if (!this.connected) return this;
	  debug('closing socket - reason %s', reason);
	  this.leaveAll();
	  this.nsp.remove(this);
	  this.client.remove(this);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.nsp.connected[this.id];
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Produces an `error` packet.
	 *
	 * @param {Object} error object
	 * @api private
	 */
	
	Socket.prototype.error = function(err){
	  this.packet({ type: parser.ERROR, data: err });
	};
	
	/**
	 * Disconnects this client.
	 *
	 * @param {Boolean} if `true`, closes the underlying connection
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.disconnect = function(close){
	  if (!this.connected) return this;
	  if (close) {
	    this.client.disconnect();
	  } else {
	    this.packet({ type: parser.DISCONNECT });
	    this.onclose('server namespace disconnect');
	  }
	  return this;
	};


/***/ },
/* 499 */
/*!**********************************!*\
  !*** external "has-binary-data" ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("has-binary-data");

/***/ },
/* 500 */
/*!**************************************************!*\
  !*** ./~/socket.io/~/socket.io-adapter/index.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(/*! object-keys */ 501);
	var Emitter = __webpack_require__(/*! events */ 447).EventEmitter;
	var parser = __webpack_require__(/*! socket.io-parser */ 502);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Adapter;
	
	/**
	 * Memory adapter constructor.
	 *
	 * @param {Namespace} nsp
	 * @api public
	 */
	
	function Adapter(nsp){
	  this.nsp = nsp;
	  this.rooms = {};
	  this.sids = {};
	  this.encoder = new parser.Encoder();
	}
	
	/**
	 * Inherits from `EventEmitter`.
	 */
	
	Adapter.prototype.__proto__ = Emitter.prototype;
	
	/**
	 * Adds a socket from a room.
	 *
	 * @param {String} socket id
	 * @param {String} room name
	 * @param {Function} callback
	 * @api public
	 */
	
	Adapter.prototype.add = function(id, room, fn){
	  this.sids[id] = this.sids[id] || {};
	  this.sids[id][room] = true;
	  this.rooms[room] = this.rooms[room] || {};
	  this.rooms[room][id] = true;
	  if (fn) process.nextTick(fn.bind(null, null));
	};
	
	/**
	 * Removes a socket from a room.
	 *
	 * @param {String} socket id
	 * @param {String} room name
	 * @param {Function} callback
	 * @api public
	 */
	
	Adapter.prototype.del = function(id, room, fn){
	  this.sids[id] = this.sids[id] || {};
	  this.rooms[room] = this.rooms[room] || {};
	  delete this.sids[id][room];
	  delete this.rooms[room][id];
	  if (this.rooms.hasOwnProperty(room) && !keys(this.rooms[room]).length) {
	    delete this.rooms[room];
	  }
	
	  if (fn) process.nextTick(fn.bind(null, null));
	};
	
	/**
	 * Removes a socket from all rooms it's joined.
	 *
	 * @param {String} socket id
	 * @api public
	 */
	
	Adapter.prototype.delAll = function(id, fn){
	  var rooms = this.sids[id];
	  if (rooms) {
	    for (var room in rooms) {
	      if (rooms.hasOwnProperty(room)) {
	        delete this.rooms[room][id];
	      }
	
	      if (this.rooms.hasOwnProperty(room) && !keys(this.rooms[room]).length) {
	        delete this.rooms[room];
	      }
	    }
	  }
	  delete this.sids[id];
	};
	
	/**
	 * Broadcasts a packet.
	 *
	 * Options:
	 *  - `flags` {Object} flags for this packet
	 *  - `except` {Array} sids that should be excluded
	 *  - `rooms` {Array} list of rooms to broadcast to
	 *
	 * @param {Object} packet object
	 * @api public
	 */
	
	Adapter.prototype.broadcast = function(packet, opts){
	  var rooms = opts.rooms || [];
	  var except = opts.except || [];
	  var flags = opts.flags || {};
	  var ids = {};
	  var self = this;
	  var socket;
	
	  packet.nsp = this.nsp.name;
	  this.encoder.encode(packet, function(encodedPackets) {
	    if (rooms.length) {
	      for (var i = 0; i < rooms.length; i++) {
	        var room = self.rooms[rooms[i]];
	        if (!room) continue;
	        for (var id in room) {
	          if (room.hasOwnProperty(id)) {
	            if (ids[id] || ~except.indexOf(id)) continue;
	            socket = self.nsp.connected[id];
	            if (socket) {
	              socket.packet(encodedPackets, true, flags.volatile);
	              ids[id] = true;
	            }
	          }
	        }
	      }
	    } else {
	      for (var id in self.sids) {
	        if (self.sids.hasOwnProperty(id)) {
	          if (~except.indexOf(id)) continue;
	          socket = self.nsp.connected[id];
	          if (socket) socket.packet(encodedPackets, true, flags.volatile);
	        }
	      }
	    }
	  });
	};


/***/ },
/* 501 */
/*!******************************!*\
  !*** external "object-keys" ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("object-keys");

/***/ },
/* 502 */
/*!*********************************************************************!*\
  !*** ./~/socket.io/~/socket.io-adapter/~/socket.io-parser/index.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(/*! debug */ 439)('socket.io-parser');
	var json = __webpack_require__(/*! json3 */ 440);
	var isArray = __webpack_require__(/*! isarray */ 441);
	var Emitter = __webpack_require__(/*! component-emitter */ 438);
	var binary = __webpack_require__(/*! ./binary */ 503);
	var isBuf = __webpack_require__(/*! ./is-buffer */ 504);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'BINARY_EVENT',
	  'ACK',
	  'BINARY_ACK',
	  'ERROR'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments == 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    p.attachments = '';
	    while (str.charAt(++i) != '-') {
	      p.attachments += str.charAt(i);
	    }
	    p.attachments = Number(p.attachments);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i + 1 == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' != next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i + 1 == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 503 */
/*!**********************************************************************!*\
  !*** ./~/socket.io/~/socket.io-adapter/~/socket.io-parser/binary.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(/*! isarray */ 441);
	var isBuf = __webpack_require__(/*! ./is-buffer */ 504);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};


/***/ },
/* 504 */
/*!*************************************************************************!*\
  !*** ./~/socket.io/~/socket.io-adapter/~/socket.io-parser/is-buffer.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}


/***/ },
/* 505 */
/*!*****************************************!*\
  !*** ./~/socket.io-client/socket.io.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var require;var require;!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	
	module.exports = _dereq_('./lib/');
	
	},{"./lib/":2}],2:[function(_dereq_,module,exports){
	
	/**
	 * Module dependencies.
	 */
	
	var url = _dereq_('./url');
	var parser = _dereq_('socket.io-parser');
	var Manager = _dereq_('./manager');
	var debug = _dereq_('debug')('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if (typeof uri == 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var io;
	
	  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	
	  return io.socket(parsed.path);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = _dereq_('./manager');
	exports.Socket = _dereq_('./socket');
	
	},{"./manager":3,"./socket":5,"./url":6,"debug":10,"socket.io-parser":46}],3:[function(_dereq_,module,exports){
	
	/**
	 * Module dependencies.
	 */
	
	var url = _dereq_('./url');
	var eio = _dereq_('engine.io-client');
	var Socket = _dereq_('./socket');
	var Emitter = _dereq_('component-emitter');
	var parser = _dereq_('socket.io-parser');
	var on = _dereq_('./on');
	var bind = _dereq_('component-bind');
	var object = _dereq_('object-component');
	var debug = _dereq_('debug')('socket.io-client:manager');
	var indexOf = _dereq_('indexof');
	var Backoff = _dereq_('backo2');
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts){
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' == typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connected = [];
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function() {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function(){
	  for (var nsp in this.nsps) {
	    this.nsps[nsp].id = this.engine.id;
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function(v){
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function(v){
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function(v){
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function(v){
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function(v){
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function(v){
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function() {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open =
	Manager.prototype.connect = function(fn){
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function() {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function(data){
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function(){
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function(){
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function(data){
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function(packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function(err){
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function(nsp){
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connect', function(){
	      socket.id = self.engine.id;
	      if (!~indexOf(self.connected, socket)) {
	        self.connected.push(socket);
	      }
	    });
	  }
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function(socket){
	  var index = indexOf(this.connected, socket);
	  if (~index) this.connected.splice(index, 1);
	  if (this.connected.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function(packet){
	  debug('writing packet %j', packet);
	  var self = this;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function(encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i]);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function() {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function(){
	  var sub;
	  while (sub = this.subs.shift()) sub.destroy();
	
	  this.packetBuffer = [];
	  this.encoding = false;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close =
	Manager.prototype.disconnect = function(){
	  this.skipReconnect = true;
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.engine && this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function(reason){
	  debug('close');
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function(){
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function(){
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function(err){
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function(){
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};
	
	},{"./on":4,"./socket":5,"./url":6,"backo2":7,"component-bind":8,"component-emitter":9,"debug":10,"engine.io-client":11,"indexof":42,"object-component":43,"socket.io-parser":46}],4:[function(_dereq_,module,exports){
	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function(){
	      obj.removeListener(ev, fn);
	    }
	  };
	}
	
	},{}],5:[function(_dereq_,module,exports){
	
	/**
	 * Module dependencies.
	 */
	
	var parser = _dereq_('socket.io-parser');
	var Emitter = _dereq_('component-emitter');
	var toArray = _dereq_('to-array');
	var on = _dereq_('./on');
	var bind = _dereq_('component-bind');
	var debug = _dereq_('debug')('socket.io-client:socket');
	var hasBin = _dereq_('has-binary');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp){
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  if (this.io.autoConnect) this.open();
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function() {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open =
	Socket.prototype.connect = function(){
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function(){
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function(ev){
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };
	
	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function(packet){
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function(){
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function(reason){
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function(packet){
	  if (packet.nsp != this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function(packet){
	  debug('calling ack %s with %j', packet.id, packet.data);
	  var fn = this.acks[packet.id];
	  fn.apply(this, packet.data);
	  delete this.acks[packet.id];
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function(){
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function(){
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function(){
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function(){
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close =
	Socket.prototype.disconnect = function(){
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	},{"./on":4,"component-bind":8,"component-emitter":9,"debug":10,"has-binary":38,"socket.io-parser":46,"to-array":50}],6:[function(_dereq_,module,exports){
	(function (global){
	
	/**
	 * Module dependencies.
	 */
	
	var parseuri = _dereq_('parseuri');
	var debug = _dereq_('debug')('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc){
	  var obj = uri;
	
	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.hostname + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    }
	    else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  // define unique id
	  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
	
	  return obj;
	}
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"debug":10,"parseuri":44}],7:[function(_dereq_,module,exports){
	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	
	
	},{}],8:[function(_dereq_,module,exports){
	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};
	
	},{}],9:[function(_dereq_,module,exports){
	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};
	
	},{}],10:[function(_dereq_,module,exports){
	
	/**
	 * Expose `debug()` as the module.
	 */
	
	module.exports = debug;
	
	/**
	 * Create a debugger with the given `name`.
	 *
	 * @param {String} name
	 * @return {Type}
	 * @api public
	 */
	
	function debug(name) {
	  if (!debug.enabled(name)) return function(){};
	
	  return function(fmt){
	    fmt = coerce(fmt);
	
	    var curr = new Date;
	    var ms = curr - (debug[name] || curr);
	    debug[name] = curr;
	
	    fmt = name
	      + ' '
	      + fmt
	      + ' +' + debug.humanize(ms);
	
	    // This hackery is required for IE8
	    // where `console.log` doesn't have 'apply'
	    window.console
	      && console.log
	      && Function.prototype.apply.call(console.log, console, arguments);
	  }
	}
	
	/**
	 * The currently active debug mode names.
	 */
	
	debug.names = [];
	debug.skips = [];
	
	/**
	 * Enables a debug mode by name. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} name
	 * @api public
	 */
	
	debug.enable = function(name) {
	  try {
	    localStorage.debug = name;
	  } catch(e){}
	
	  var split = (name || '').split(/[\s,]+/)
	    , len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    name = split[i].replace('*', '.*?');
	    if (name[0] === '-') {
	      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
	    }
	    else {
	      debug.names.push(new RegExp('^' + name + '$'));
	    }
	  }
	};
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	debug.disable = function(){
	  debug.enable('');
	};
	
	/**
	 * Humanize the given `ms`.
	 *
	 * @param {Number} m
	 * @return {String}
	 * @api private
	 */
	
	debug.humanize = function(ms) {
	  var sec = 1000
	    , min = 60 * 1000
	    , hour = 60 * min;
	
	  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
	  if (ms >= min) return (ms / min).toFixed(1) + 'm';
	  if (ms >= sec) return (ms / sec | 0) + 's';
	  return ms + 'ms';
	};
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	debug.enabled = function(name) {
	  for (var i = 0, len = debug.skips.length; i < len; i++) {
	    if (debug.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (var i = 0, len = debug.names.length; i < len; i++) {
	    if (debug.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	};
	
	/**
	 * Coerce `val`.
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}
	
	// persist
	
	try {
	  if (window.localStorage) debug.enable(localStorage.debug);
	} catch(e){}
	
	},{}],11:[function(_dereq_,module,exports){
	
	module.exports =  _dereq_('./lib/');
	
	},{"./lib/":12}],12:[function(_dereq_,module,exports){
	
	module.exports = _dereq_('./socket');
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = _dereq_('engine.io-parser');
	
	},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){
	(function (global){
	/**
	 * Module dependencies.
	 */
	
	var transports = _dereq_('./transports');
	var Emitter = _dereq_('component-emitter');
	var debug = _dereq_('debug')('engine.io-client:socket');
	var index = _dereq_('indexof');
	var parser = _dereq_('engine.io-parser');
	var parseuri = _dereq_('parseuri');
	var parsejson = _dereq_('parsejson');
	var parseqs = _dereq_('parseqs');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop(){}
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.host = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  }
	
	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);
	
	  if (opts.host) {
	    var pieces = opts.host.split(':');
	    opts.hostname = pieces.shift();
	    if (pieces.length) {
	      opts.port = pieces.pop();
	    } else if (!opts.port) {
	      // if no port is specified manually, use the protocol default
	      opts.port = this.secure ? '443' : '80';
	    }
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.callbackBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized || null;
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = _dereq_('./transport');
	Socket.transports = _dereq_('./transports');
	Socket.parser = _dereq_('engine.io-parser');
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized
	  });
	
	  return transport;
	};
	
	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 == this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  var transport;
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport() {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose(){
	    onerror("transport closed");
	  }
	
	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }
	
	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.emit('error', err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api public
	*/
	
	Socket.prototype.ping = function () {
	  this.sendPacket('ping');
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function() {
	  for (var i = 0; i < this.prevBufferLen; i++) {
	    if (this.callbackBuffer[i]) {
	      this.callbackBuffer[i]();
	    }
	  }
	
	  this.writeBuffer.splice(0, this.prevBufferLen);
	  this.callbackBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (this.writeBuffer.length == 0) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write =
	Socket.prototype.send = function (msg, fn) {
	  this.sendPacket('message', msg, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, fn) {
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }
	
	  var packet = { type: type, data: data };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  this.callbackBuffer.push(fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    function close() {
	      self.onClose('forced close');
	      debug('socket closing - telling transport to close');
	      self.transport.close();
	    }
	
	    function cleanupAndClose() {
	      self.removeListener('upgrade', cleanupAndClose);
	      self.removeListener('upgradeError', cleanupAndClose);
	      close();
	    }
	
	    function waitForUpgrade() {
	      // wait for upgrade to finish since we can't send packets while pausing a transport
	      self.once('upgrade', cleanupAndClose);
	      self.once('upgradeError', cleanupAndClose);
	    }
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // clean buffers in next tick, so developers can still
	    // grab the buffers on `close` event
	    setTimeout(function() {
	      self.writeBuffer = [];
	      self.callbackBuffer = [];
	      self.prevBufferLen = 0;
	    }, 0);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./transport":14,"./transports":15,"component-emitter":9,"debug":22,"engine.io-parser":25,"indexof":42,"parsejson":34,"parseqs":35,"parseuri":36}],14:[function(_dereq_,module,exports){
	/**
	 * Module dependencies.
	 */
	
	var parser = _dereq_('engine.io-parser');
	var Emitter = _dereq_('component-emitter');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * A counter used to prevent collisions in the timestamps used
	 * for cache busting.
	 */
	
	Transport.timestamps = 0;
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};
	
	},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){
	(function (global){
	/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = _dereq_('xmlhttprequest');
	var XHR = _dereq_('./polling-xhr');
	var JSONP = _dereq_('./polling-jsonp');
	var websocket = _dereq_('./websocket');
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,"xmlhttprequest":20}],16:[function(_dereq_,module,exports){
	(function (global){
	
	/**
	 * Module requirements.
	 */
	
	var Polling = _dereq_('./polling');
	var inherit = _dereq_('component-inherit');
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Callbacks count.
	 */
	
	var index = 0;
	
	/**
	 * Noop.
	 */
	
	function empty () { }
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling (opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  insertAt.parentNode.insertBefore(script, insertAt);
	  this.script = script;
	
	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete () {
	    initIframe();
	    fn();
	  }
	
	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch(e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){
	(function (global){
	/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = _dereq_('xmlhttprequest');
	var Polling = _dereq_('./polling');
	var Emitter = _dereq_('component-emitter');
	var inherit = _dereq_('component-inherit');
	var debug = _dereq_('debug')('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty(){}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR(opts){
	  Polling.call(this, opts);
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        data = 'ok';
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function(){
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./polling":18,"component-emitter":9,"component-inherit":21,"debug":22,"xmlhttprequest":20}],18:[function(_dereq_,module,exports){
	/**
	 * Module dependencies.
	 */
	
	var Transport = _dereq_('../transport');
	var parseqs = _dereq_('parseqs');
	var parser = _dereq_('engine.io-parser');
	var inherit = _dereq_('component-inherit');
	var debug = _dereq_('debug')('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = (function() {
	  var XMLHttpRequest = _dereq_('xmlhttprequest');
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function(){
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function(){
	  var self = this;
	
	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  return schema + '://' + this.hostname + port + this.path + query;
	};
	
	},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":35,"xmlhttprequest":20}],19:[function(_dereq_,module,exports){
	/**
	 * Module dependencies.
	 */
	
	var Transport = _dereq_('../transport');
	var parser = _dereq_('engine.io-parser');
	var parseqs = _dereq_('parseqs');
	var inherit = _dereq_('component-inherit');
	var debug = _dereq_('debug')('engine.io-client:websocket');
	
	/**
	 * `ws` exposes a WebSocket-compatible interface in
	 * Node, or the `WebSocket` or `MozWebSocket` globals
	 * in the browser.
	 */
	
	var WebSocket = _dereq_('ws');
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = { agent: this.agent };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  this.ws = new WebSocket(uri, protocols, opts);
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  this.ws.binaryType = 'arraybuffer';
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function(){
	  var self = this;
	
	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */
	
	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  for (var i = 0, l = packets.length; i < l; i++) {
	    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
	      //Sometimes the websocket has already been closed but the browser didn't
	      //have a chance of informing us about it yet, in that case send will
	      //throw an error
	      try {
	        self.ws.send(data);
	      } catch (e){
	        debug('websocket closed before onclose event');
	      }
	    });
	  }
	
	  function ondrain() {
	    self.writable = true;
	    self.emit('drain');
	  }
	  // fake drain
	  // defer to next tick to allow Socket to clear writeBuffer
	  setTimeout(ondrain, 0);
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = +new Date;
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  return schema + '://' + this.hostname + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};
	
	},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":35,"ws":37}],20:[function(_dereq_,module,exports){
	// browser shim for xmlhttprequest module
	var hasCORS = _dereq_('has-cors');
	
	module.exports = function(opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }
	
	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}
	
	},{"has-cors":40}],21:[function(_dereq_,module,exports){
	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};
	},{}],22:[function(_dereq_,module,exports){
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = _dereq_('./debug');
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // This hackery is required for IE8,
	  // where the `console.log` function doesn't have 'apply'
	  return 'object' == typeof console
	    && 'function' == typeof console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      localStorage.removeItem('debug');
	    } else {
	      localStorage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = localStorage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	},{"./debug":23}],23:[function(_dereq_,module,exports){
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = _dereq_('ms');
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}
	
	},{"ms":24}],24:[function(_dereq_,module,exports){
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 's':
	      return n * s;
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}
	
	},{}],25:[function(_dereq_,module,exports){
	(function (global){
	/**
	 * Module dependencies.
	 */
	
	var keys = _dereq_('./keys');
	var hasBinary = _dereq_('has-binary');
	var sliceBuffer = _dereq_('arraybuffer.slice');
	var base64encoder = _dereq_('base64-arraybuffer');
	var after = _dereq_('after');
	var utf8 = _dereq_('utf8');
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = navigator.userAgent.match(/Android/i);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = _dereq_('blob');
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = ''
	    , n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;
	
	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    if(numberTooLong) return callback(err, 0, 1);
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./keys":26,"after":27,"arraybuffer.slice":28,"base64-arraybuffer":29,"blob":30,"has-binary":31,"utf8":33}],26:[function(_dereq_,module,exports){
	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};
	
	},{}],27:[function(_dereq_,module,exports){
	module.exports = after
	
	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count
	
	    return (count === 0) ? callback() : proxy
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}
	
	function noop() {}
	
	},{}],28:[function(_dereq_,module,exports){
	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
	
	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};
	
	},{}],29:[function(_dereq_,module,exports){
	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";
	
	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";
	
	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);
	
	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	
	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
	
	},{}],30:[function(_dereq_,module,exports){
	(function (global){
	/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = (function() {
	  try {
	    var b = new Blob(['hi']);
	    return b.size == 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	module.exports = (function() {
	  if (blobSupported) {
	    return global.Blob;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],31:[function(_dereq_,module,exports){
	(function (global){
	
	/*
	 * Module requirements.
	 */
	
	var isArray = _dereq_('isarray');
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"isarray":32}],32:[function(_dereq_,module,exports){
	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};
	
	},{}],33:[function(_dereq_,module,exports){
	(function (global){
	/*! http://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from http://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from http://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
	
			// console.log(JSON.stringify(codePoints.map(function(x) {
			// 	return 'U+' + x.toString(16).toUpperCase();
			// })));
	
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			typeof define == 'function' &&
			typeof define.amd == 'object' &&
			define.amd
		) {
			define(function() {
				return utf8;
			});
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],34:[function(_dereq_,module,exports){
	(function (global){
	/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */
	
	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;
	
	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }
	
	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
	
	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }
	
	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],35:[function(_dereq_,module,exports){
	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};
	
	},{}],36:[function(_dereq_,module,exports){
	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};
	
	},{}],37:[function(_dereq_,module,exports){
	
	/**
	 * Module dependencies.
	 */
	
	var global = (function() { return this; })();
	
	/**
	 * WebSocket constructor.
	 */
	
	var WebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Module exports.
	 */
	
	module.exports = WebSocket ? ws : null;
	
	/**
	 * WebSocket constructor.
	 *
	 * The third `opts` options object gets ignored in web browsers, since it's
	 * non-standard, and throws a TypeError if passed to the constructor.
	 * See: https://github.com/einaros/ws/issues/227
	 *
	 * @param {String} uri
	 * @param {Array} protocols (optional)
	 * @param {Object) opts (optional)
	 * @api public
	 */
	
	function ws(uri, protocols, opts) {
	  var instance;
	  if (protocols) {
	    instance = new WebSocket(uri, protocols);
	  } else {
	    instance = new WebSocket(uri);
	  }
	  return instance;
	}
	
	if (WebSocket) ws.prototype = WebSocket.prototype;
	
	},{}],38:[function(_dereq_,module,exports){
	(function (global){
	
	/*
	 * Module requirements.
	 */
	
	var isArray = _dereq_('isarray');
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"isarray":39}],39:[function(_dereq_,module,exports){
	module.exports=_dereq_(32)
	},{}],40:[function(_dereq_,module,exports){
	
	/**
	 * Module dependencies.
	 */
	
	var global = _dereq_('global');
	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = 'XMLHttpRequest' in global &&
	    'withCredentials' in new global.XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}
	
	},{"global":41}],41:[function(_dereq_,module,exports){
	
	/**
	 * Returns `this`. Execute this without a "context" (i.e. without it being
	 * attached to an object of the left-hand side), and `this` points to the
	 * "global" scope of the current JS execution.
	 */
	
	module.exports = (function () { return this; })();
	
	},{}],42:[function(_dereq_,module,exports){
	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};
	},{}],43:[function(_dereq_,module,exports){
	
	/**
	 * HOP ref.
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Return own keys in `obj`.
	 *
	 * @param {Object} obj
	 * @return {Array}
	 * @api public
	 */
	
	exports.keys = Object.keys || function(obj){
	  var keys = [];
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      keys.push(key);
	    }
	  }
	  return keys;
	};
	
	/**
	 * Return own values in `obj`.
	 *
	 * @param {Object} obj
	 * @return {Array}
	 * @api public
	 */
	
	exports.values = function(obj){
	  var vals = [];
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      vals.push(obj[key]);
	    }
	  }
	  return vals;
	};
	
	/**
	 * Merge `b` into `a`.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api public
	 */
	
	exports.merge = function(a, b){
	  for (var key in b) {
	    if (has.call(b, key)) {
	      a[key] = b[key];
	    }
	  }
	  return a;
	};
	
	/**
	 * Return length of `obj`.
	 *
	 * @param {Object} obj
	 * @return {Number}
	 * @api public
	 */
	
	exports.length = function(obj){
	  return exports.keys(obj).length;
	};
	
	/**
	 * Check if `obj` is empty.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api public
	 */
	
	exports.isEmpty = function(obj){
	  return 0 == exports.length(obj);
	};
	},{}],44:[function(_dereq_,module,exports){
	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
	  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	  var m = re.exec(str || '')
	    , uri = {}
	    , i = 14;
	
	  while (i--) {
	    uri[parts[i]] = m[i] || '';
	  }
	
	  return uri;
	};
	
	},{}],45:[function(_dereq_,module,exports){
	(function (global){
	/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = _dereq_('isarray');
	var isBuf = _dereq_('./is-buffer');
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./is-buffer":47,"isarray":48}],46:[function(_dereq_,module,exports){
	
	/**
	 * Module dependencies.
	 */
	
	var debug = _dereq_('debug')('socket.io-parser');
	var json = _dereq_('json3');
	var isArray = _dereq_('isarray');
	var Emitter = _dereq_('component-emitter');
	var binary = _dereq_('./binary');
	var isBuf = _dereq_('./is-buffer');
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'BINARY_EVENT',
	  'ACK',
	  'BINARY_ACK',
	  'ERROR'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}
	
	},{"./binary":45,"./is-buffer":47,"component-emitter":9,"debug":10,"isarray":48,"json3":49}],47:[function(_dereq_,module,exports){
	(function (global){
	
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}
	
	}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],48:[function(_dereq_,module,exports){
	module.exports=_dereq_(32)
	},{}],49:[function(_dereq_,module,exports){
	/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
	;(function (window) {
	  // Convenience aliases.
	  var getClass = {}.toString, isProperty, forEach, undef;
	
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = typeof define === "function" && define.amd;
	
	  // Detect native implementations.
	  var nativeJSON = typeof JSON == "object" && JSON;
	
	  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
	  // available.
	  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;
	
	  if (JSON3 && nativeJSON) {
	    // Explicitly delegate to the native `stringify` and `parse`
	    // implementations in CommonJS environments.
	    JSON3.stringify = nativeJSON.stringify;
	    JSON3.parse = nativeJSON.parse;
	  } else {
	    // Export for web browsers, JavaScript engines, and asynchronous module
	    // loaders, using the global `JSON` object if available.
	    JSON3 = window.JSON = nativeJSON || {};
	  }
	
	  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	  var isExtended = new Date(-3509827334573292);
	  try {
	    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	    // results for certain dates in Opera >= 10.53.
	    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	      // Safari < 2.0.2 stores the internal millisecond time value correctly,
	      // but clips the values returned by the date methods to the range of
	      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	  } catch (exception) {}
	
	  // Internal: Determines whether the native `JSON.stringify` and `parse`
	  // implementations are spec-compliant. Based on work by Ken Snyder.
	  function has(name) {
	    if (has[name] !== undef) {
	      // Return cached feature test result.
	      return has[name];
	    }
	
	    var isSupported;
	    if (name == "bug-string-char-index") {
	      // IE <= 7 doesn't support accessing string characters using square
	      // bracket notation. IE 8 only supports this for primitives.
	      isSupported = "a"[0] != "a";
	    } else if (name == "json") {
	      // Indicates whether both `JSON.stringify` and `JSON.parse` are
	      // supported.
	      isSupported = has("json-stringify") && has("json-parse");
	    } else {
	      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	      // Test `JSON.stringify`.
	      if (name == "json-stringify") {
	        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	        if (stringifySupported) {
	          // A test function object with a custom `toJSON` method.
	          (value = function () {
	            return 1;
	          }).toJSON = value;
	          try {
	            stringifySupported =
	              // Firefox 3.1b1 and b2 serialize string, number, and boolean
	              // primitives as object literals.
	              stringify(0) === "0" &&
	              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	              // literals.
	              stringify(new Number()) === "0" &&
	              stringify(new String()) == '""' &&
	              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	              // does not define a canonical JSON representation (this applies to
	              // objects with `toJSON` properties as well, *unless* they are nested
	              // within an object or array).
	              stringify(getClass) === undef &&
	              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	              // FF 3.1b3 pass this test.
	              stringify(undef) === undef &&
	              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	              // respectively, if the value is omitted entirely.
	              stringify() === undef &&
	              // FF 3.1b1, 2 throw an error if the given value is not a number,
	              // string, array, object, Boolean, or `null` literal. This applies to
	              // objects with custom `toJSON` methods as well, unless they are nested
	              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	              // methods entirely.
	              stringify(value) === "1" &&
	              stringify([value]) == "[1]" &&
	              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	              // `"[null]"`.
	              stringify([undef]) == "[null]" &&
	              // YUI 3.0.0b1 fails to serialize `null` literals.
	              stringify(null) == "null" &&
	              // FF 3.1b1, 2 halts serialization if an array contains a function:
	              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	              // elides non-JSON values from objects and arrays, unless they
	              // define custom `toJSON` methods.
	              stringify([undef, getClass, null]) == "[null,null,null]" &&
	              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	              // where character escape codes are expected (e.g., `\b` => `\u0008`).
	              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	              stringify(null, value) === "1" &&
	              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	              // serialize extended years.
	              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	              // The milliseconds are optional in ES 5, but required in 5.1.
	              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	              // four-digit years instead of six-digit years. Credits: @Yaffle.
	              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	              // values less than 1000. Credits: @Yaffle.
	              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	          } catch (exception) {
	            stringifySupported = false;
	          }
	        }
	        isSupported = stringifySupported;
	      }
	      // Test `JSON.parse`.
	      if (name == "json-parse") {
	        var parse = JSON3.parse;
	        if (typeof parse == "function") {
	          try {
	            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	            // Conforming implementations should also coerce the initial argument to
	            // a string prior to parsing.
	            if (parse("0") === 0 && !parse(false)) {
	              // Simple parsing test.
	              value = parse(serialized);
	              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	              if (parseSupported) {
	                try {
	                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                  parseSupported = !parse('"\t"');
	                } catch (exception) {}
	                if (parseSupported) {
	                  try {
	                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                    // certain octal literals.
	                    parseSupported = parse("01") !== 1;
	                  } catch (exception) {}
	                }
	                if (parseSupported) {
	                  try {
	                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                    // points. These environments, along with FF 3.1b1 and 2,
	                    // also allow trailing commas in JSON objects and arrays.
	                    parseSupported = parse("1.") !== 1;
	                  } catch (exception) {}
	                }
	              }
	            }
	          } catch (exception) {
	            parseSupported = false;
	          }
	        }
	        isSupported = parseSupported;
	      }
	    }
	    return has[name] = !!isSupported;
	  }
	
	  if (!has("json")) {
	    // Common `[[Class]]` name aliases.
	    var functionClass = "[object Function]";
	    var dateClass = "[object Date]";
	    var numberClass = "[object Number]";
	    var stringClass = "[object String]";
	    var arrayClass = "[object Array]";
	    var booleanClass = "[object Boolean]";
	
	    // Detect incomplete support for accessing string characters by index.
	    var charIndexBuggy = has("bug-string-char-index");
	
	    // Define additional utility methods if the `Date` methods are buggy.
	    if (!isExtended) {
	      var floor = Math.floor;
	      // A mapping between the months of the year and the number of days between
	      // January 1st and the first of the respective month.
	      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	      // Internal: Calculates the number of days between the Unix epoch and the
	      // first day of the given month.
	      var getDay = function (year, month) {
	        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	      };
	    }
	
	    // Internal: Determines if a property is a direct property of the given
	    // object. Delegates to the native `Object#hasOwnProperty` method.
	    if (!(isProperty = {}.hasOwnProperty)) {
	      isProperty = function (property) {
	        var members = {}, constructor;
	        if ((members.__proto__ = null, members.__proto__ = {
	          // The *proto* property cannot be set multiple times in recent
	          // versions of Firefox and SeaMonkey.
	          "toString": 1
	        }, members).toString != getClass) {
	          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	          // supports the mutable *proto* property.
	          isProperty = function (property) {
	            // Capture and break the object's prototype chain (see section 8.6.2
	            // of the ES 5.1 spec). The parenthesized expression prevents an
	            // unsafe transformation by the Closure Compiler.
	            var original = this.__proto__, result = property in (this.__proto__ = null, this);
	            // Restore the original prototype chain.
	            this.__proto__ = original;
	            return result;
	          };
	        } else {
	          // Capture a reference to the top-level `Object` constructor.
	          constructor = members.constructor;
	          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	          // other environments.
	          isProperty = function (property) {
	            var parent = (this.constructor || constructor).prototype;
	            return property in this && !(property in parent && this[property] === parent[property]);
	          };
	        }
	        members = null;
	        return isProperty.call(this, property);
	      };
	    }
	
	    // Internal: A set of primitive types used by `isHostType`.
	    var PrimitiveTypes = {
	      'boolean': 1,
	      'number': 1,
	      'string': 1,
	      'undefined': 1
	    };
	
	    // Internal: Determines if the given object `property` value is a
	    // non-primitive.
	    var isHostType = function (object, property) {
	      var type = typeof object[property];
	      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
	    };
	
	    // Internal: Normalizes the `for...in` iteration algorithm across
	    // environments. Each enumerated key is yielded to a `callback` function.
	    forEach = function (object, callback) {
	      var size = 0, Properties, members, property;
	
	      // Tests for bugs in the current environment's `for...in` algorithm. The
	      // `valueOf` property inherits the non-enumerable flag from
	      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	      (Properties = function () {
	        this.valueOf = 0;
	      }).prototype.valueOf = 0;
	
	      // Iterate over a new instance of the `Properties` class.
	      members = new Properties();
	      for (property in members) {
	        // Ignore all properties inherited from `Object.prototype`.
	        if (isProperty.call(members, property)) {
	          size++;
	        }
	      }
	      Properties = members = null;
	
	      // Normalize the iteration algorithm.
	      if (!size) {
	        // A list of non-enumerable properties inherited from `Object.prototype`.
	        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	        // properties.
	        forEach = function (object, callback) {
	          var isFunction = getClass.call(object) == functionClass, property, length;
	          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
	          for (property in object) {
	            // Gecko <= 1.0 enumerates the `prototype` property of functions under
	            // certain conditions; IE does not.
	            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	              callback(property);
	            }
	          }
	          // Manually invoke the callback for each non-enumerable property.
	          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	        };
	      } else if (size == 2) {
	        // Safari <= 2.0.4 enumerates shadowed properties twice.
	        forEach = function (object, callback) {
	          // Create a set of iterated properties.
	          var members = {}, isFunction = getClass.call(object) == functionClass, property;
	          for (property in object) {
	            // Store each property name to prevent double enumeration. The
	            // `prototype` property of functions is not enumerated due to cross-
	            // environment inconsistencies.
	            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	              callback(property);
	            }
	          }
	        };
	      } else {
	        // No bugs detected; use the standard `for...in` algorithm.
	        forEach = function (object, callback) {
	          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	          for (property in object) {
	            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	              callback(property);
	            }
	          }
	          // Manually invoke the callback for the `constructor` property due to
	          // cross-environment inconsistencies.
	          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	            callback(property);
	          }
	        };
	      }
	      return forEach(object, callback);
	    };
	
	    // Public: Serializes a JavaScript `value` as a JSON string. The optional
	    // `filter` argument may specify either a function that alters how object and
	    // array members are serialized, or an array of strings and numbers that
	    // indicates which properties should be serialized. The optional `width`
	    // argument may be either a string or number that specifies the indentation
	    // level of the output.
	    if (!has("json-stringify")) {
	      // Internal: A map of control characters and their escaped equivalents.
	      var Escapes = {
	        92: "\\\\",
	        34: '\\"',
	        8: "\\b",
	        12: "\\f",
	        10: "\\n",
	        13: "\\r",
	        9: "\\t"
	      };
	
	      // Internal: Converts `value` into a zero-padded string such that its
	      // length is at least equal to `width`. The `width` must be <= 6.
	      var leadingZeroes = "000000";
	      var toPaddedString = function (width, value) {
	        // The `|| 0` expression is necessary to work around a bug in
	        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	        return (leadingZeroes + (value || 0)).slice(-width);
	      };
	
	      // Internal: Double-quotes a string `value`, replacing all ASCII control
	      // characters (characters with code unit values between 0 and 31) with
	      // their escaped equivalents. This is an implementation of the
	      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	      var unicodePrefix = "\\u00";
	      var quote = function (value) {
	        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
	        if (isLarge) {
	          symbols = value.split("");
	        }
	        for (; index < length; index++) {
	          var charCode = value.charCodeAt(index);
	          // If the character is a control character, append its Unicode or
	          // shorthand escape sequence; otherwise, append the character as-is.
	          switch (charCode) {
	            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	              result += Escapes[charCode];
	              break;
	            default:
	              if (charCode < 32) {
	                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                break;
	              }
	              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
	          }
	        }
	        return result + '"';
	      };
	
	      // Internal: Recursively serializes an object. Implements the
	      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	        try {
	          // Necessary for host object support.
	          value = object[property];
	        } catch (exception) {}
	        if (typeof value == "object" && value) {
	          className = getClass.call(value);
	          if (className == dateClass && !isProperty.call(value, "toJSON")) {
	            if (value > -1 / 0 && value < 1 / 0) {
	              // Dates are serialized according to the `Date#toJSON` method
	              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	              // for the ISO 8601 date time string format.
	              if (getDay) {
	                // Manually compute the year, month, date, hours, minutes,
	                // seconds, and milliseconds if the `getUTC*` methods are
	                // buggy. Adapted from @Yaffle's `date-shim` project.
	                date = floor(value / 864e5);
	                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                date = 1 + date - getDay(year, month);
	                // The `time` value specifies the time within the day (see ES
	                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                // to compute `A modulo B`, as the `%` operator does not
	                // correspond to the `modulo` operation for negative numbers.
	                time = (value % 864e5 + 864e5) % 864e5;
	                // The hours, minutes, seconds, and milliseconds are obtained by
	                // decomposing the time within the day. See section 15.9.1.10.
	                hours = floor(time / 36e5) % 24;
	                minutes = floor(time / 6e4) % 60;
	                seconds = floor(time / 1e3) % 60;
	                milliseconds = time % 1e3;
	              } else {
	                year = value.getUTCFullYear();
	                month = value.getUTCMonth();
	                date = value.getUTCDate();
	                hours = value.getUTCHours();
	                minutes = value.getUTCMinutes();
	                seconds = value.getUTCSeconds();
	                milliseconds = value.getUTCMilliseconds();
	              }
	              // Serialize extended years correctly.
	              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                // Months, dates, hours, minutes, and seconds should have two
	                // digits; milliseconds should have three.
	                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                // Milliseconds are optional in ES 5.0, but required in 5.1.
	                "." + toPaddedString(3, milliseconds) + "Z";
	            } else {
	              value = null;
	            }
	          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	            // ignores all `toJSON` methods on these objects unless they are
	            // defined directly on an instance.
	            value = value.toJSON(property);
	          }
	        }
	        if (callback) {
	          // If a replacement function was provided, call it to obtain the value
	          // for serialization.
	          value = callback.call(object, property, value);
	        }
	        if (value === null) {
	          return "null";
	        }
	        className = getClass.call(value);
	        if (className == booleanClass) {
	          // Booleans are represented literally.
	          return "" + value;
	        } else if (className == numberClass) {
	          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	          // `"null"`.
	          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	        } else if (className == stringClass) {
	          // Strings are double-quoted and escaped.
	          return quote("" + value);
	        }
	        // Recursively serialize objects and arrays.
	        if (typeof value == "object") {
	          // Check for cyclic structures. This is a linear search; performance
	          // is inversely proportional to the number of unique nested objects.
	          for (length = stack.length; length--;) {
	            if (stack[length] === value) {
	              // Cyclic structures cannot be serialized by `JSON.stringify`.
	              throw TypeError();
	            }
	          }
	          // Add the object to the stack of traversed objects.
	          stack.push(value);
	          results = [];
	          // Save the current indentation level and indent one additional level.
	          prefix = indentation;
	          indentation += whitespace;
	          if (className == arrayClass) {
	            // Recursively serialize array elements.
	            for (index = 0, length = value.length; index < length; index++) {
	              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	              results.push(element === undef ? "null" : element);
	            }
	            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	          } else {
	            // Recursively serialize object members. Members are selected from
	            // either a user-specified list of property names, or the object
	            // itself.
	            forEach(properties || value, function (property) {
	              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	              if (element !== undef) {
	                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                // is not the empty string, let `member` {quote(property) + ":"}
	                // be the concatenation of `member` and the `space` character."
	                // The "`space` character" refers to the literal space
	                // character, not the `space` {width} argument provided to
	                // `JSON.stringify`.
	                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	              }
	            });
	            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	          }
	          // Remove the object from the traversed object stack.
	          stack.pop();
	          return result;
	        }
	      };
	
	      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	      JSON3.stringify = function (source, filter, width) {
	        var whitespace, callback, properties, className;
	        if (typeof filter == "function" || typeof filter == "object" && filter) {
	          if ((className = getClass.call(filter)) == functionClass) {
	            callback = filter;
	          } else if (className == arrayClass) {
	            // Convert the property names array into a makeshift set.
	            properties = {};
	            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	          }
	        }
	        if (width) {
	          if ((className = getClass.call(width)) == numberClass) {
	            // Convert the `width` to an integer and create a string containing
	            // `width` number of space characters.
	            if ((width -= width % 1) > 0) {
	              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	            }
	          } else if (className == stringClass) {
	            whitespace = width.length <= 10 ? width : width.slice(0, 10);
	          }
	        }
	        // Opera <= 7.54u2 discards the values associated with empty string keys
	        // (`""`) only if they are used directly within an object member list
	        // (e.g., `!("" in { "": 1})`).
	        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	      };
	    }
	
	    // Public: Parses a JSON source string.
	    if (!has("json-parse")) {
	      var fromCharCode = String.fromCharCode;
	
	      // Internal: A map of escaped control characters and their unescaped
	      // equivalents.
	      var Unescapes = {
	        92: "\\",
	        34: '"',
	        47: "/",
	        98: "\b",
	        116: "\t",
	        110: "\n",
	        102: "\f",
	        114: "\r"
	      };
	
	      // Internal: Stores the parser state.
	      var Index, Source;
	
	      // Internal: Resets the parser state and throws a `SyntaxError`.
	      var abort = function() {
	        Index = Source = null;
	        throw SyntaxError();
	      };
	
	      // Internal: Returns the next token, or `"$"` if the parser has reached
	      // the end of the source string. A token may be a string, number, `null`
	      // literal, or Boolean literal.
	      var lex = function () {
	        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	        while (Index < length) {
	          charCode = source.charCodeAt(Index);
	          switch (charCode) {
	            case 9: case 10: case 13: case 32:
	              // Skip whitespace tokens, including tabs, carriage returns, line
	              // feeds, and space characters.
	              Index++;
	              break;
	            case 123: case 125: case 91: case 93: case 58: case 44:
	              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	              // the current position.
	              value = charIndexBuggy ? source.charAt(Index) : source[Index];
	              Index++;
	              return value;
	            case 34:
	              // `"` delimits a JSON string; advance to the next character and
	              // begin parsing the string. String tokens are prefixed with the
	              // sentinel `@` character to distinguish them from punctuators and
	              // end-of-string tokens.
	              for (value = "@", Index++; Index < length;) {
	                charCode = source.charCodeAt(Index);
	                if (charCode < 32) {
	                  // Unescaped ASCII control characters (those with a code unit
	                  // less than the space character) are not permitted.
	                  abort();
	                } else if (charCode == 92) {
	                  // A reverse solidus (`\`) marks the beginning of an escaped
	                  // control character (including `"`, `\`, and `/`) or Unicode
	                  // escape sequence.
	                  charCode = source.charCodeAt(++Index);
	                  switch (charCode) {
	                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                      // Revive escaped control characters.
	                      value += Unescapes[charCode];
	                      Index++;
	                      break;
	                    case 117:
	                      // `\u` marks the beginning of a Unicode escape sequence.
	                      // Advance to the first character and validate the
	                      // four-digit code point.
	                      begin = ++Index;
	                      for (position = Index + 4; Index < position; Index++) {
	                        charCode = source.charCodeAt(Index);
	                        // A valid sequence comprises four hexdigits (case-
	                        // insensitive) that form a single hexadecimal value.
	                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                          // Invalid Unicode escape sequence.
	                          abort();
	                        }
	                      }
	                      // Revive the escaped character.
	                      value += fromCharCode("0x" + source.slice(begin, Index));
	                      break;
	                    default:
	                      // Invalid escape sequence.
	                      abort();
	                  }
	                } else {
	                  if (charCode == 34) {
	                    // An unescaped double-quote character marks the end of the
	                    // string.
	                    break;
	                  }
	                  charCode = source.charCodeAt(Index);
	                  begin = Index;
	                  // Optimize for the common case where a string is valid.
	                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                    charCode = source.charCodeAt(++Index);
	                  }
	                  // Append the string as-is.
	                  value += source.slice(begin, Index);
	                }
	              }
	              if (source.charCodeAt(Index) == 34) {
	                // Advance to the next character and return the revived string.
	                Index++;
	                return value;
	              }
	              // Unterminated string.
	              abort();
	            default:
	              // Parse numbers and literals.
	              begin = Index;
	              // Advance past the negative sign, if one is specified.
	              if (charCode == 45) {
	                isSigned = true;
	                charCode = source.charCodeAt(++Index);
	              }
	              // Parse an integer or floating-point value.
	              if (charCode >= 48 && charCode <= 57) {
	                // Leading zeroes are interpreted as octal literals.
	                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                  // Illegal octal literal.
	                  abort();
	                }
	                isSigned = false;
	                // Parse the integer component.
	                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                // Floats cannot contain a leading decimal point; however, this
	                // case is already accounted for by the parser.
	                if (source.charCodeAt(Index) == 46) {
	                  position = ++Index;
	                  // Parse the decimal component.
	                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                  if (position == Index) {
	                    // Illegal trailing decimal.
	                    abort();
	                  }
	                  Index = position;
	                }
	                // Parse exponents. The `e` denoting the exponent is
	                // case-insensitive.
	                charCode = source.charCodeAt(Index);
	                if (charCode == 101 || charCode == 69) {
	                  charCode = source.charCodeAt(++Index);
	                  // Skip past the sign following the exponent, if one is
	                  // specified.
	                  if (charCode == 43 || charCode == 45) {
	                    Index++;
	                  }
	                  // Parse the exponential component.
	                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                  if (position == Index) {
	                    // Illegal empty exponent.
	                    abort();
	                  }
	                  Index = position;
	                }
	                // Coerce the parsed value to a JavaScript number.
	                return +source.slice(begin, Index);
	              }
	              // A negative sign may only precede numbers.
	              if (isSigned) {
	                abort();
	              }
	              // `true`, `false`, and `null` literals.
	              if (source.slice(Index, Index + 4) == "true") {
	                Index += 4;
	                return true;
	              } else if (source.slice(Index, Index + 5) == "false") {
	                Index += 5;
	                return false;
	              } else if (source.slice(Index, Index + 4) == "null") {
	                Index += 4;
	                return null;
	              }
	              // Unrecognized token.
	              abort();
	          }
	        }
	        // Return the sentinel `$` character if the parser has reached the end
	        // of the source string.
	        return "$";
	      };
	
	      // Internal: Parses a JSON `value` token.
	      var get = function (value) {
	        var results, hasMembers;
	        if (value == "$") {
	          // Unexpected end of input.
	          abort();
	        }
	        if (typeof value == "string") {
	          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	            // Remove the sentinel `@` character.
	            return value.slice(1);
	          }
	          // Parse object and array literals.
	          if (value == "[") {
	            // Parses a JSON array, returning a new JavaScript array.
	            results = [];
	            for (;; hasMembers || (hasMembers = true)) {
	              value = lex();
	              // A closing square bracket marks the end of the array literal.
	              if (value == "]") {
	                break;
	              }
	              // If the array literal contains elements, the current token
	              // should be a comma separating the previous element from the
	              // next.
	              if (hasMembers) {
	                if (value == ",") {
	                  value = lex();
	                  if (value == "]") {
	                    // Unexpected trailing `,` in array literal.
	                    abort();
	                  }
	                } else {
	                  // A `,` must separate each array element.
	                  abort();
	                }
	              }
	              // Elisions and leading commas are not permitted.
	              if (value == ",") {
	                abort();
	              }
	              results.push(get(value));
	            }
	            return results;
	          } else if (value == "{") {
	            // Parses a JSON object, returning a new JavaScript object.
	            results = {};
	            for (;; hasMembers || (hasMembers = true)) {
	              value = lex();
	              // A closing curly brace marks the end of the object literal.
	              if (value == "}") {
	                break;
	              }
	              // If the object literal contains members, the current token
	              // should be a comma separator.
	              if (hasMembers) {
	                if (value == ",") {
	                  value = lex();
	                  if (value == "}") {
	                    // Unexpected trailing `,` in object literal.
	                    abort();
	                  }
	                } else {
	                  // A `,` must separate each object member.
	                  abort();
	                }
	              }
	              // Leading commas are not permitted, object property names must be
	              // double-quoted strings, and a `:` must separate each property
	              // name and value.
	              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                abort();
	              }
	              results[value.slice(1)] = get(lex());
	            }
	            return results;
	          }
	          // Unexpected token encountered.
	          abort();
	        }
	        return value;
	      };
	
	      // Internal: Updates a traversed object member.
	      var update = function(source, property, callback) {
	        var element = walk(source, property, callback);
	        if (element === undef) {
	          delete source[property];
	        } else {
	          source[property] = element;
	        }
	      };
	
	      // Internal: Recursively traverses a parsed JSON object, invoking the
	      // `callback` function for each value. This is an implementation of the
	      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	      var walk = function (source, property, callback) {
	        var value = source[property], length;
	        if (typeof value == "object" && value) {
	          // `forEach` can't be used to traverse an array in Opera <= 8.54
	          // because its `Object#hasOwnProperty` implementation returns `false`
	          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	          if (getClass.call(value) == arrayClass) {
	            for (length = value.length; length--;) {
	              update(value, length, callback);
	            }
	          } else {
	            forEach(value, function (property) {
	              update(value, property, callback);
	            });
	          }
	        }
	        return callback.call(source, property, value);
	      };
	
	      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	      JSON3.parse = function (source, callback) {
	        var result, value;
	        Index = 0;
	        Source = "" + source;
	        result = get(lex());
	        // If a JSON string contains multiple tokens, it is invalid.
	        if (lex() != "$") {
	          abort();
	        }
	        // Reset the parser state.
	        Index = Source = null;
	        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	      };
	    }
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    define(function () {
	      return JSON3;
	    });
	  }
	}(this));
	
	},{}],50:[function(_dereq_,module,exports){
	module.exports = toArray
	
	function toArray(list, index) {
	    var array = []
	
	    index = index || 0
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }
	
	    return array
	}
	
	},{}]},{},[1])
	(1)
	});


/***/ },
/* 506 */
/*!***********************!*\
  !*** ./src/logger.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var winston = __webpack_require__(/*! winston */ 507);
	var os = __webpack_require__(/*! os */ 97);
	
	var logger = new winston.Logger({
	  transports: [new winston.transports.Console({ json: true, timestamp: true, level: 'emerg' })]
	});
	
	logger.setLevels(winston.config.syslog.levels);
	
	if (process.env.NODE_ENV === 'production') {
	  // eslint-disable-line
	  logger.log('info', 'adding syslog');
	  __webpack_require__(/*! winston-syslog */ 508).Syslog; // eslint-disable-line no-unused-expressions
	
	  logger.add(winston.transports.Syslog, {
	    protocol: 'udp4',
	    localhost: os.hostname(),
	    app_name: 'pallesgavebod',
	    json: true,
	    timestamp: true,
	    level: 'emerg'
	  });
	}
	
	module.exports = logger;

/***/ },
/* 507 */
/*!**************************!*\
  !*** external "winston" ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("winston");

/***/ },
/* 508 */
/*!*********************************!*\
  !*** external "winston-syslog" ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = require("winston-syslog");

/***/ }
/******/ ]);
//# sourceMappingURL=server.generated.js.map